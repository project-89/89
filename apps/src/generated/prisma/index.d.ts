
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Fingerprint
 * 
 */
export type Fingerprint = $Result.DefaultSelection<Prisma.$FingerprintPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Visit
 * 
 */
export type Visit = $Result.DefaultSelection<Prisma.$VisitPayload>
/**
 * Model Impression
 * 
 */
export type Impression = $Result.DefaultSelection<Prisma.$ImpressionPayload>
/**
 * Model SocialProfile
 * 
 */
export type SocialProfile = $Result.DefaultSelection<Prisma.$SocialProfilePayload>
/**
 * Model Knowledge
 * 
 */
export type Knowledge = $Result.DefaultSelection<Prisma.$KnowledgePayload>
/**
 * Model Mission
 * 
 */
export type Mission = $Result.DefaultSelection<Prisma.$MissionPayload>
/**
 * Model Proxim8User
 * 
 */
export type Proxim8User = $Result.DefaultSelection<Prisma.$Proxim8UserPayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NFTOwnership
 * 
 */
export type NFTOwnership = $Result.DefaultSelection<Prisma.$NFTOwnershipPayload>
/**
 * Model Lore
 * 
 */
export type Lore = $Result.DefaultSelection<Prisma.$LorePayload>
/**
 * Model Pipeline
 * 
 */
export type Pipeline = $Result.DefaultSelection<Prisma.$PipelinePayload>
/**
 * Model PublicVideo
 * 
 */
export type PublicVideo = $Result.DefaultSelection<Prisma.$PublicVideoPayload>
/**
 * Model GameAgent
 * 
 */
export type GameAgent = $Result.DefaultSelection<Prisma.$GameAgentPayload>
/**
 * Model GameProxim8
 * 
 */
export type GameProxim8 = $Result.DefaultSelection<Prisma.$GameProxim8Payload>
/**
 * Model TrainingMissionDeployment
 * 
 */
export type TrainingMissionDeployment = $Result.DefaultSelection<Prisma.$TrainingMissionDeploymentPayload>
/**
 * Model UserStats
 * 
 */
export type UserStats = $Result.DefaultSelection<Prisma.$UserStatsPayload>
/**
 * Model NFT
 * 
 */
export type NFT = $Result.DefaultSelection<Prisma.$NFTPayload>
/**
 * Model TrainingMission
 * 
 */
export type TrainingMission = $Result.DefaultSelection<Prisma.$TrainingMissionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const VideoStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type VideoStatus = (typeof VideoStatus)[keyof typeof VideoStatus]


export const NotificationType: {
  VIDEO_COMPLETED: 'VIDEO_COMPLETED',
  VIDEO_FAILED: 'VIDEO_FAILED',
  SYSTEM_ANNOUNCEMENT: 'SYSTEM_ANNOUNCEMENT',
  NFT_VERIFIED: 'NFT_VERIFIED',
  PROFILE_UPDATE: 'PROFILE_UPDATE',
  MISSION_COMPLETED: 'MISSION_COMPLETED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const MissionStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type MissionStatus = (typeof MissionStatus)[keyof typeof MissionStatus]


export const PipelineType: {
  VIDEO_GENERATION: 'VIDEO_GENERATION',
  DATA_PROCESSING: 'DATA_PROCESSING',
  NOTIFICATION: 'NOTIFICATION',
  ANALYTICS: 'ANALYTICS'
};

export type PipelineType = (typeof PipelineType)[keyof typeof PipelineType]


export const PipelineStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ERROR: 'ERROR',
  MAINTENANCE: 'MAINTENANCE'
};

export type PipelineStatus = (typeof PipelineStatus)[keyof typeof PipelineStatus]


export const AgentRank: {
  OBSERVER: 'OBSERVER',
  FIELD_AGENT: 'FIELD_AGENT',
  SENIOR_AGENT: 'SENIOR_AGENT',
  ARCHITECT: 'ARCHITECT'
};

export type AgentRank = (typeof AgentRank)[keyof typeof AgentRank]


export const Proxim8Personality: {
  ANALYTICAL: 'ANALYTICAL',
  AGGRESSIVE: 'AGGRESSIVE',
  DIPLOMATIC: 'DIPLOMATIC',
  ADAPTIVE: 'ADAPTIVE'
};

export type Proxim8Personality = (typeof Proxim8Personality)[keyof typeof Proxim8Personality]


export const MissionApproach: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type MissionApproach = (typeof MissionApproach)[keyof typeof MissionApproach]


export const DeploymentStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED'
};

export type DeploymentStatus = (typeof DeploymentStatus)[keyof typeof DeploymentStatus]

}

export type VideoStatus = $Enums.VideoStatus

export const VideoStatus: typeof $Enums.VideoStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type MissionStatus = $Enums.MissionStatus

export const MissionStatus: typeof $Enums.MissionStatus

export type PipelineType = $Enums.PipelineType

export const PipelineType: typeof $Enums.PipelineType

export type PipelineStatus = $Enums.PipelineStatus

export const PipelineStatus: typeof $Enums.PipelineStatus

export type AgentRank = $Enums.AgentRank

export const AgentRank: typeof $Enums.AgentRank

export type Proxim8Personality = $Enums.Proxim8Personality

export const Proxim8Personality: typeof $Enums.Proxim8Personality

export type MissionApproach = $Enums.MissionApproach

export const MissionApproach: typeof $Enums.MissionApproach

export type DeploymentStatus = $Enums.DeploymentStatus

export const DeploymentStatus: typeof $Enums.DeploymentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fingerprint`: Exposes CRUD operations for the **Fingerprint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fingerprints
    * const fingerprints = await prisma.fingerprint.findMany()
    * ```
    */
  get fingerprint(): Prisma.FingerprintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visit`: Exposes CRUD operations for the **Visit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visits
    * const visits = await prisma.visit.findMany()
    * ```
    */
  get visit(): Prisma.VisitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.impression`: Exposes CRUD operations for the **Impression** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Impressions
    * const impressions = await prisma.impression.findMany()
    * ```
    */
  get impression(): Prisma.ImpressionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialProfile`: Exposes CRUD operations for the **SocialProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialProfiles
    * const socialProfiles = await prisma.socialProfile.findMany()
    * ```
    */
  get socialProfile(): Prisma.SocialProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledge`: Exposes CRUD operations for the **Knowledge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Knowledges
    * const knowledges = await prisma.knowledge.findMany()
    * ```
    */
  get knowledge(): Prisma.KnowledgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mission`: Exposes CRUD operations for the **Mission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Missions
    * const missions = await prisma.mission.findMany()
    * ```
    */
  get mission(): Prisma.MissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxim8User`: Exposes CRUD operations for the **Proxim8User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proxim8Users
    * const proxim8Users = await prisma.proxim8User.findMany()
    * ```
    */
  get proxim8User(): Prisma.Proxim8UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nFTOwnership`: Exposes CRUD operations for the **NFTOwnership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NFTOwnerships
    * const nFTOwnerships = await prisma.nFTOwnership.findMany()
    * ```
    */
  get nFTOwnership(): Prisma.NFTOwnershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lore`: Exposes CRUD operations for the **Lore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lores
    * const lores = await prisma.lore.findMany()
    * ```
    */
  get lore(): Prisma.LoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pipeline`: Exposes CRUD operations for the **Pipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipeline.findMany()
    * ```
    */
  get pipeline(): Prisma.PipelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publicVideo`: Exposes CRUD operations for the **PublicVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublicVideos
    * const publicVideos = await prisma.publicVideo.findMany()
    * ```
    */
  get publicVideo(): Prisma.PublicVideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameAgent`: Exposes CRUD operations for the **GameAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameAgents
    * const gameAgents = await prisma.gameAgent.findMany()
    * ```
    */
  get gameAgent(): Prisma.GameAgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameProxim8`: Exposes CRUD operations for the **GameProxim8** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameProxim8s
    * const gameProxim8s = await prisma.gameProxim8.findMany()
    * ```
    */
  get gameProxim8(): Prisma.GameProxim8Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingMissionDeployment`: Exposes CRUD operations for the **TrainingMissionDeployment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingMissionDeployments
    * const trainingMissionDeployments = await prisma.trainingMissionDeployment.findMany()
    * ```
    */
  get trainingMissionDeployment(): Prisma.TrainingMissionDeploymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStats`: Exposes CRUD operations for the **UserStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStats
    * const userStats = await prisma.userStats.findMany()
    * ```
    */
  get userStats(): Prisma.UserStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nFT`: Exposes CRUD operations for the **NFT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NFTS
    * const nFTS = await prisma.nFT.findMany()
    * ```
    */
  get nFT(): Prisma.NFTDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingMission`: Exposes CRUD operations for the **TrainingMission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingMissions
    * const trainingMissions = await prisma.trainingMission.findMany()
    * ```
    */
  get trainingMission(): Prisma.TrainingMissionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Profile: 'Profile',
    Fingerprint: 'Fingerprint',
    Agent: 'Agent',
    Visit: 'Visit',
    Impression: 'Impression',
    SocialProfile: 'SocialProfile',
    Knowledge: 'Knowledge',
    Mission: 'Mission',
    Proxim8User: 'Proxim8User',
    Video: 'Video',
    Notification: 'Notification',
    NFTOwnership: 'NFTOwnership',
    Lore: 'Lore',
    Pipeline: 'Pipeline',
    PublicVideo: 'PublicVideo',
    GameAgent: 'GameAgent',
    GameProxim8: 'GameProxim8',
    TrainingMissionDeployment: 'TrainingMissionDeployment',
    UserStats: 'UserStats',
    NFT: 'NFT',
    TrainingMission: 'TrainingMission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "profile" | "fingerprint" | "agent" | "visit" | "impression" | "socialProfile" | "knowledge" | "mission" | "proxim8User" | "video" | "notification" | "nFTOwnership" | "lore" | "pipeline" | "publicVideo" | "gameAgent" | "gameProxim8" | "trainingMissionDeployment" | "userStats" | "nFT" | "trainingMission"
      txIsolationLevel: never
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProfileFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProfileAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Fingerprint: {
        payload: Prisma.$FingerprintPayload<ExtArgs>
        fields: Prisma.FingerprintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FingerprintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FingerprintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload>
          }
          findFirst: {
            args: Prisma.FingerprintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FingerprintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload>
          }
          findMany: {
            args: Prisma.FingerprintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload>[]
          }
          create: {
            args: Prisma.FingerprintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload>
          }
          createMany: {
            args: Prisma.FingerprintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FingerprintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload>
          }
          update: {
            args: Prisma.FingerprintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload>
          }
          deleteMany: {
            args: Prisma.FingerprintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FingerprintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FingerprintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FingerprintPayload>
          }
          aggregate: {
            args: Prisma.FingerprintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFingerprint>
          }
          groupBy: {
            args: Prisma.FingerprintGroupByArgs<ExtArgs>
            result: $Utils.Optional<FingerprintGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FingerprintFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FingerprintAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FingerprintCountArgs<ExtArgs>
            result: $Utils.Optional<FingerprintCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Visit: {
        payload: Prisma.$VisitPayload<ExtArgs>
        fields: Prisma.VisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          findFirst: {
            args: Prisma.VisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          findMany: {
            args: Prisma.VisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>[]
          }
          create: {
            args: Prisma.VisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          createMany: {
            args: Prisma.VisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          update: {
            args: Prisma.VisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          deleteMany: {
            args: Prisma.VisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          aggregate: {
            args: Prisma.VisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisit>
          }
          groupBy: {
            args: Prisma.VisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VisitFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VisitAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VisitCountArgs<ExtArgs>
            result: $Utils.Optional<VisitCountAggregateOutputType> | number
          }
        }
      }
      Impression: {
        payload: Prisma.$ImpressionPayload<ExtArgs>
        fields: Prisma.ImpressionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImpressionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImpressionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          findFirst: {
            args: Prisma.ImpressionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImpressionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          findMany: {
            args: Prisma.ImpressionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>[]
          }
          create: {
            args: Prisma.ImpressionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          createMany: {
            args: Prisma.ImpressionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImpressionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          update: {
            args: Prisma.ImpressionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          deleteMany: {
            args: Prisma.ImpressionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImpressionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImpressionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          aggregate: {
            args: Prisma.ImpressionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImpression>
          }
          groupBy: {
            args: Prisma.ImpressionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImpressionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ImpressionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ImpressionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ImpressionCountArgs<ExtArgs>
            result: $Utils.Optional<ImpressionCountAggregateOutputType> | number
          }
        }
      }
      SocialProfile: {
        payload: Prisma.$SocialProfilePayload<ExtArgs>
        fields: Prisma.SocialProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          findFirst: {
            args: Prisma.SocialProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          findMany: {
            args: Prisma.SocialProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>[]
          }
          create: {
            args: Prisma.SocialProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          createMany: {
            args: Prisma.SocialProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocialProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          update: {
            args: Prisma.SocialProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          deleteMany: {
            args: Prisma.SocialProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          aggregate: {
            args: Prisma.SocialProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialProfile>
          }
          groupBy: {
            args: Prisma.SocialProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialProfileGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SocialProfileFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SocialProfileAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SocialProfileCountArgs<ExtArgs>
            result: $Utils.Optional<SocialProfileCountAggregateOutputType> | number
          }
        }
      }
      Knowledge: {
        payload: Prisma.$KnowledgePayload<ExtArgs>
        fields: Prisma.KnowledgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          findMany: {
            args: Prisma.KnowledgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>[]
          }
          create: {
            args: Prisma.KnowledgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          createMany: {
            args: Prisma.KnowledgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KnowledgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          update: {
            args: Prisma.KnowledgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledge>
          }
          groupBy: {
            args: Prisma.KnowledgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.KnowledgeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.KnowledgeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.KnowledgeCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeCountAggregateOutputType> | number
          }
        }
      }
      Mission: {
        payload: Prisma.$MissionPayload<ExtArgs>
        fields: Prisma.MissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findFirst: {
            args: Prisma.MissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findMany: {
            args: Prisma.MissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>[]
          }
          create: {
            args: Prisma.MissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          createMany: {
            args: Prisma.MissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          update: {
            args: Prisma.MissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          deleteMany: {
            args: Prisma.MissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          aggregate: {
            args: Prisma.MissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMission>
          }
          groupBy: {
            args: Prisma.MissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MissionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MissionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MissionCountArgs<ExtArgs>
            result: $Utils.Optional<MissionCountAggregateOutputType> | number
          }
        }
      }
      Proxim8User: {
        payload: Prisma.$Proxim8UserPayload<ExtArgs>
        fields: Prisma.Proxim8UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Proxim8UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Proxim8UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload>
          }
          findFirst: {
            args: Prisma.Proxim8UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Proxim8UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload>
          }
          findMany: {
            args: Prisma.Proxim8UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload>[]
          }
          create: {
            args: Prisma.Proxim8UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload>
          }
          createMany: {
            args: Prisma.Proxim8UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Proxim8UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload>
          }
          update: {
            args: Prisma.Proxim8UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload>
          }
          deleteMany: {
            args: Prisma.Proxim8UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Proxim8UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Proxim8UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Proxim8UserPayload>
          }
          aggregate: {
            args: Prisma.Proxim8UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxim8User>
          }
          groupBy: {
            args: Prisma.Proxim8UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<Proxim8UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Proxim8UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Proxim8UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Proxim8UserCountArgs<ExtArgs>
            result: $Utils.Optional<Proxim8UserCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VideoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VideoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NFTOwnership: {
        payload: Prisma.$NFTOwnershipPayload<ExtArgs>
        fields: Prisma.NFTOwnershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NFTOwnershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NFTOwnershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload>
          }
          findFirst: {
            args: Prisma.NFTOwnershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NFTOwnershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload>
          }
          findMany: {
            args: Prisma.NFTOwnershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload>[]
          }
          create: {
            args: Prisma.NFTOwnershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload>
          }
          createMany: {
            args: Prisma.NFTOwnershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NFTOwnershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload>
          }
          update: {
            args: Prisma.NFTOwnershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload>
          }
          deleteMany: {
            args: Prisma.NFTOwnershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NFTOwnershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NFTOwnershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTOwnershipPayload>
          }
          aggregate: {
            args: Prisma.NFTOwnershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNFTOwnership>
          }
          groupBy: {
            args: Prisma.NFTOwnershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<NFTOwnershipGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NFTOwnershipFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NFTOwnershipAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NFTOwnershipCountArgs<ExtArgs>
            result: $Utils.Optional<NFTOwnershipCountAggregateOutputType> | number
          }
        }
      }
      Lore: {
        payload: Prisma.$LorePayload<ExtArgs>
        fields: Prisma.LoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload>
          }
          findFirst: {
            args: Prisma.LoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload>
          }
          findMany: {
            args: Prisma.LoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload>[]
          }
          create: {
            args: Prisma.LoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload>
          }
          createMany: {
            args: Prisma.LoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload>
          }
          update: {
            args: Prisma.LoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload>
          }
          deleteMany: {
            args: Prisma.LoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LorePayload>
          }
          aggregate: {
            args: Prisma.LoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLore>
          }
          groupBy: {
            args: Prisma.LoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoreGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LoreFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LoreAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LoreCountArgs<ExtArgs>
            result: $Utils.Optional<LoreCountAggregateOutputType> | number
          }
        }
      }
      Pipeline: {
        payload: Prisma.$PipelinePayload<ExtArgs>
        fields: Prisma.PipelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findFirst: {
            args: Prisma.PipelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findMany: {
            args: Prisma.PipelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          create: {
            args: Prisma.PipelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          createMany: {
            args: Prisma.PipelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PipelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          update: {
            args: Prisma.PipelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          deleteMany: {
            args: Prisma.PipelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PipelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          aggregate: {
            args: Prisma.PipelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipeline>
          }
          groupBy: {
            args: Prisma.PipelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PipelineFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PipelineAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PipelineCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineCountAggregateOutputType> | number
          }
        }
      }
      PublicVideo: {
        payload: Prisma.$PublicVideoPayload<ExtArgs>
        fields: Prisma.PublicVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload>
          }
          findFirst: {
            args: Prisma.PublicVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload>
          }
          findMany: {
            args: Prisma.PublicVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload>[]
          }
          create: {
            args: Prisma.PublicVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload>
          }
          createMany: {
            args: Prisma.PublicVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PublicVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload>
          }
          update: {
            args: Prisma.PublicVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload>
          }
          deleteMany: {
            args: Prisma.PublicVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PublicVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicVideoPayload>
          }
          aggregate: {
            args: Prisma.PublicVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublicVideo>
          }
          groupBy: {
            args: Prisma.PublicVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicVideoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PublicVideoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PublicVideoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PublicVideoCountArgs<ExtArgs>
            result: $Utils.Optional<PublicVideoCountAggregateOutputType> | number
          }
        }
      }
      GameAgent: {
        payload: Prisma.$GameAgentPayload<ExtArgs>
        fields: Prisma.GameAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameAgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameAgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload>
          }
          findFirst: {
            args: Prisma.GameAgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameAgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload>
          }
          findMany: {
            args: Prisma.GameAgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload>[]
          }
          create: {
            args: Prisma.GameAgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload>
          }
          createMany: {
            args: Prisma.GameAgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GameAgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload>
          }
          update: {
            args: Prisma.GameAgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload>
          }
          deleteMany: {
            args: Prisma.GameAgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameAgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameAgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAgentPayload>
          }
          aggregate: {
            args: Prisma.GameAgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameAgent>
          }
          groupBy: {
            args: Prisma.GameAgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameAgentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GameAgentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GameAgentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GameAgentCountArgs<ExtArgs>
            result: $Utils.Optional<GameAgentCountAggregateOutputType> | number
          }
        }
      }
      GameProxim8: {
        payload: Prisma.$GameProxim8Payload<ExtArgs>
        fields: Prisma.GameProxim8FieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameProxim8FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameProxim8FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload>
          }
          findFirst: {
            args: Prisma.GameProxim8FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameProxim8FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload>
          }
          findMany: {
            args: Prisma.GameProxim8FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload>[]
          }
          create: {
            args: Prisma.GameProxim8CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload>
          }
          createMany: {
            args: Prisma.GameProxim8CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GameProxim8DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload>
          }
          update: {
            args: Prisma.GameProxim8UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload>
          }
          deleteMany: {
            args: Prisma.GameProxim8DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameProxim8UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameProxim8UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameProxim8Payload>
          }
          aggregate: {
            args: Prisma.GameProxim8AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameProxim8>
          }
          groupBy: {
            args: Prisma.GameProxim8GroupByArgs<ExtArgs>
            result: $Utils.Optional<GameProxim8GroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GameProxim8FindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GameProxim8AggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GameProxim8CountArgs<ExtArgs>
            result: $Utils.Optional<GameProxim8CountAggregateOutputType> | number
          }
        }
      }
      TrainingMissionDeployment: {
        payload: Prisma.$TrainingMissionDeploymentPayload<ExtArgs>
        fields: Prisma.TrainingMissionDeploymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingMissionDeploymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingMissionDeploymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload>
          }
          findFirst: {
            args: Prisma.TrainingMissionDeploymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingMissionDeploymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload>
          }
          findMany: {
            args: Prisma.TrainingMissionDeploymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload>[]
          }
          create: {
            args: Prisma.TrainingMissionDeploymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload>
          }
          createMany: {
            args: Prisma.TrainingMissionDeploymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrainingMissionDeploymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload>
          }
          update: {
            args: Prisma.TrainingMissionDeploymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload>
          }
          deleteMany: {
            args: Prisma.TrainingMissionDeploymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingMissionDeploymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingMissionDeploymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionDeploymentPayload>
          }
          aggregate: {
            args: Prisma.TrainingMissionDeploymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingMissionDeployment>
          }
          groupBy: {
            args: Prisma.TrainingMissionDeploymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingMissionDeploymentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TrainingMissionDeploymentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TrainingMissionDeploymentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TrainingMissionDeploymentCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingMissionDeploymentCountAggregateOutputType> | number
          }
        }
      }
      UserStats: {
        payload: Prisma.$UserStatsPayload<ExtArgs>
        fields: Prisma.UserStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findFirst: {
            args: Prisma.UserStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findMany: {
            args: Prisma.UserStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          create: {
            args: Prisma.UserStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          createMany: {
            args: Prisma.UserStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          update: {
            args: Prisma.UserStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          deleteMany: {
            args: Prisma.UserStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          aggregate: {
            args: Prisma.UserStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStats>
          }
          groupBy: {
            args: Prisma.UserStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStatsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserStatsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserStatsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserStatsCountArgs<ExtArgs>
            result: $Utils.Optional<UserStatsCountAggregateOutputType> | number
          }
        }
      }
      NFT: {
        payload: Prisma.$NFTPayload<ExtArgs>
        fields: Prisma.NFTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NFTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NFTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          findFirst: {
            args: Prisma.NFTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NFTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          findMany: {
            args: Prisma.NFTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>[]
          }
          create: {
            args: Prisma.NFTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          createMany: {
            args: Prisma.NFTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NFTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          update: {
            args: Prisma.NFTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          deleteMany: {
            args: Prisma.NFTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NFTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NFTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          aggregate: {
            args: Prisma.NFTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNFT>
          }
          groupBy: {
            args: Prisma.NFTGroupByArgs<ExtArgs>
            result: $Utils.Optional<NFTGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NFTFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NFTAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NFTCountArgs<ExtArgs>
            result: $Utils.Optional<NFTCountAggregateOutputType> | number
          }
        }
      }
      TrainingMission: {
        payload: Prisma.$TrainingMissionPayload<ExtArgs>
        fields: Prisma.TrainingMissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingMissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingMissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload>
          }
          findFirst: {
            args: Prisma.TrainingMissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingMissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload>
          }
          findMany: {
            args: Prisma.TrainingMissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload>[]
          }
          create: {
            args: Prisma.TrainingMissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload>
          }
          createMany: {
            args: Prisma.TrainingMissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrainingMissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload>
          }
          update: {
            args: Prisma.TrainingMissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload>
          }
          deleteMany: {
            args: Prisma.TrainingMissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingMissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingMissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingMissionPayload>
          }
          aggregate: {
            args: Prisma.TrainingMissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingMission>
          }
          groupBy: {
            args: Prisma.TrainingMissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingMissionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TrainingMissionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TrainingMissionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TrainingMissionCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingMissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    profile?: ProfileOmit
    fingerprint?: FingerprintOmit
    agent?: AgentOmit
    visit?: VisitOmit
    impression?: ImpressionOmit
    socialProfile?: SocialProfileOmit
    knowledge?: KnowledgeOmit
    mission?: MissionOmit
    proxim8User?: Proxim8UserOmit
    video?: VideoOmit
    notification?: NotificationOmit
    nFTOwnership?: NFTOwnershipOmit
    lore?: LoreOmit
    pipeline?: PipelineOmit
    publicVideo?: PublicVideoOmit
    gameAgent?: GameAgentOmit
    gameProxim8?: GameProxim8Omit
    trainingMissionDeployment?: TrainingMissionDeploymentOmit
    userStats?: UserStatsOmit
    nFT?: NFTOmit
    trainingMission?: TrainingMissionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    profiles: number
    fingerprints: number
    agents: number
    videos: number
    notifications: number
    nftOwnerships: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | AccountCountOutputTypeCountProfilesArgs
    fingerprints?: boolean | AccountCountOutputTypeCountFingerprintsArgs
    agents?: boolean | AccountCountOutputTypeCountAgentsArgs
    videos?: boolean | AccountCountOutputTypeCountVideosArgs
    notifications?: boolean | AccountCountOutputTypeCountNotificationsArgs
    nftOwnerships?: boolean | AccountCountOutputTypeCountNftOwnershipsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountFingerprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FingerprintWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountNftOwnershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTOwnershipWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    visits: number
    impressions: number
    socialProfiles: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | ProfileCountOutputTypeCountVisitsArgs
    impressions?: boolean | ProfileCountOutputTypeCountImpressionsArgs
    socialProfiles?: boolean | ProfileCountOutputTypeCountSocialProfilesArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountImpressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpressionWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountSocialProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialProfileWhereInput
  }


  /**
   * Count Type FingerprintCountOutputType
   */

  export type FingerprintCountOutputType = {
    visits: number
  }

  export type FingerprintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | FingerprintCountOutputTypeCountVisitsArgs
  }

  // Custom InputTypes
  /**
   * FingerprintCountOutputType without action
   */
  export type FingerprintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FingerprintCountOutputType
     */
    select?: FingerprintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FingerprintCountOutputType without action
   */
  export type FingerprintCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    knowledge: number
    missions: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | AgentCountOutputTypeCountKnowledgeArgs
    missions?: boolean | AgentCountOutputTypeCountMissionsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountKnowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
  }


  /**
   * Count Type GameAgentCountOutputType
   */

  export type GameAgentCountOutputType = {
    proxim8s: number
    missionDeployments: number
  }

  export type GameAgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proxim8s?: boolean | GameAgentCountOutputTypeCountProxim8sArgs
    missionDeployments?: boolean | GameAgentCountOutputTypeCountMissionDeploymentsArgs
  }

  // Custom InputTypes
  /**
   * GameAgentCountOutputType without action
   */
  export type GameAgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgentCountOutputType
     */
    select?: GameAgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameAgentCountOutputType without action
   */
  export type GameAgentCountOutputTypeCountProxim8sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameProxim8WhereInput
  }

  /**
   * GameAgentCountOutputType without action
   */
  export type GameAgentCountOutputTypeCountMissionDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingMissionDeploymentWhereInput
  }


  /**
   * Count Type GameProxim8CountOutputType
   */

  export type GameProxim8CountOutputType = {
    missionDeployments: number
  }

  export type GameProxim8CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    missionDeployments?: boolean | GameProxim8CountOutputTypeCountMissionDeploymentsArgs
  }

  // Custom InputTypes
  /**
   * GameProxim8CountOutputType without action
   */
  export type GameProxim8CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8CountOutputType
     */
    select?: GameProxim8CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameProxim8CountOutputType without action
   */
  export type GameProxim8CountOutputTypeCountMissionDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingMissionDeploymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    walletAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    walletAddress: string
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profiles?: boolean | Account$profilesArgs<ExtArgs>
    fingerprints?: boolean | Account$fingerprintsArgs<ExtArgs>
    agents?: boolean | Account$agentsArgs<ExtArgs>
    videos?: boolean | Account$videosArgs<ExtArgs>
    notifications?: boolean | Account$notificationsArgs<ExtArgs>
    nftOwnerships?: boolean | Account$nftOwnershipsArgs<ExtArgs>
    proxim8User?: boolean | Account$proxim8UserArgs<ExtArgs>
    gameAgent?: boolean | Account$gameAgentArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | Account$profilesArgs<ExtArgs>
    fingerprints?: boolean | Account$fingerprintsArgs<ExtArgs>
    agents?: boolean | Account$agentsArgs<ExtArgs>
    videos?: boolean | Account$videosArgs<ExtArgs>
    notifications?: boolean | Account$notificationsArgs<ExtArgs>
    nftOwnerships?: boolean | Account$nftOwnershipsArgs<ExtArgs>
    proxim8User?: boolean | Account$proxim8UserArgs<ExtArgs>
    gameAgent?: boolean | Account$gameAgentArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      profiles: Prisma.$ProfilePayload<ExtArgs>[]
      fingerprints: Prisma.$FingerprintPayload<ExtArgs>[]
      agents: Prisma.$AgentPayload<ExtArgs>[]
      videos: Prisma.$VideoPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      nftOwnerships: Prisma.$NFTOwnershipPayload<ExtArgs>[]
      proxim8User: Prisma.$Proxim8UserPayload<ExtArgs> | null
      gameAgent: Prisma.$GameAgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletAddress: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profiles<T extends Account$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Account$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fingerprints<T extends Account$fingerprintsArgs<ExtArgs> = {}>(args?: Subset<T, Account$fingerprintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agents<T extends Account$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Account$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    videos<T extends Account$videosArgs<ExtArgs> = {}>(args?: Subset<T, Account$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Account$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Account$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nftOwnerships<T extends Account$nftOwnershipsArgs<ExtArgs> = {}>(args?: Subset<T, Account$nftOwnershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proxim8User<T extends Account$proxim8UserArgs<ExtArgs> = {}>(args?: Subset<T, Account$proxim8UserArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gameAgent<T extends Account$gameAgentArgs<ExtArgs> = {}>(args?: Subset<T, Account$gameAgentArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly walletAddress: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account.profiles
   */
  export type Account$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Account.fingerprints
   */
  export type Account$fingerprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    where?: FingerprintWhereInput
    orderBy?: FingerprintOrderByWithRelationInput | FingerprintOrderByWithRelationInput[]
    cursor?: FingerprintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FingerprintScalarFieldEnum | FingerprintScalarFieldEnum[]
  }

  /**
   * Account.agents
   */
  export type Account$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Account.videos
   */
  export type Account$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Account.notifications
   */
  export type Account$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Account.nftOwnerships
   */
  export type Account$nftOwnershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    where?: NFTOwnershipWhereInput
    orderBy?: NFTOwnershipOrderByWithRelationInput | NFTOwnershipOrderByWithRelationInput[]
    cursor?: NFTOwnershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NFTOwnershipScalarFieldEnum | NFTOwnershipScalarFieldEnum[]
  }

  /**
   * Account.proxim8User
   */
  export type Account$proxim8UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    where?: Proxim8UserWhereInput
  }

  /**
   * Account.gameAgent
   */
  export type Account$gameAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    where?: GameAgentWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    username: string | null
    bio: string | null
    avatar: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    username: string | null
    bio: string | null
    avatar: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    accountId: number
    username: number
    bio: number
    avatar: number
    isPublic: number
    socialLinks: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    accountId?: true
    username?: true
    bio?: true
    avatar?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    accountId?: true
    username?: true
    bio?: true
    avatar?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    accountId?: true
    username?: true
    bio?: true
    avatar?: true
    isPublic?: true
    socialLinks?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    accountId: string
    username: string
    bio: string | null
    avatar: string | null
    isPublic: boolean
    socialLinks: JsonValue | null
    preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    username?: boolean
    bio?: boolean
    avatar?: boolean
    isPublic?: boolean
    socialLinks?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    visits?: boolean | Profile$visitsArgs<ExtArgs>
    impressions?: boolean | Profile$impressionsArgs<ExtArgs>
    socialProfiles?: boolean | Profile$socialProfilesArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>



  export type ProfileSelectScalar = {
    id?: boolean
    accountId?: boolean
    username?: boolean
    bio?: boolean
    avatar?: boolean
    isPublic?: boolean
    socialLinks?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "username" | "bio" | "avatar" | "isPublic" | "socialLinks" | "preferences" | "createdAt" | "updatedAt", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    visits?: boolean | Profile$visitsArgs<ExtArgs>
    impressions?: boolean | Profile$impressionsArgs<ExtArgs>
    socialProfiles?: boolean | Profile$socialProfilesArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      visits: Prisma.$VisitPayload<ExtArgs>[]
      impressions: Prisma.$ImpressionPayload<ExtArgs>[]
      socialProfiles: Prisma.$SocialProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      username: string
      bio: string | null
      avatar: string | null
      isPublic: boolean
      socialLinks: Prisma.JsonValue | null
      preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * @param {ProfileFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const profile = await prisma.profile.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProfileFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Profile.
     * @param {ProfileAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const profile = await prisma.profile.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProfileAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    visits<T extends Profile$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    impressions<T extends Profile$impressionsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$impressionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialProfiles<T extends Profile$socialProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$socialProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly accountId: FieldRef<"Profile", 'String'>
    readonly username: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly avatar: FieldRef<"Profile", 'String'>
    readonly isPublic: FieldRef<"Profile", 'Boolean'>
    readonly socialLinks: FieldRef<"Profile", 'Json'>
    readonly preferences: FieldRef<"Profile", 'Json'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile findRaw
   */
  export type ProfileFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Profile aggregateRaw
   */
  export type ProfileAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Profile.visits
   */
  export type Profile$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Profile.impressions
   */
  export type Profile$impressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    where?: ImpressionWhereInput
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    cursor?: ImpressionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Profile.socialProfiles
   */
  export type Profile$socialProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    where?: SocialProfileWhereInput
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    cursor?: SocialProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialProfileScalarFieldEnum | SocialProfileScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Fingerprint
   */

  export type AggregateFingerprint = {
    _count: FingerprintCountAggregateOutputType | null
    _min: FingerprintMinAggregateOutputType | null
    _max: FingerprintMaxAggregateOutputType | null
  }

  export type FingerprintMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FingerprintMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FingerprintCountAggregateOutputType = {
    id: number
    accountId: number
    fingerprint: number
    roles: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FingerprintMinAggregateInputType = {
    id?: true
    accountId?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FingerprintMaxAggregateInputType = {
    id?: true
    accountId?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FingerprintCountAggregateInputType = {
    id?: true
    accountId?: true
    fingerprint?: true
    roles?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FingerprintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fingerprint to aggregate.
     */
    where?: FingerprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fingerprints to fetch.
     */
    orderBy?: FingerprintOrderByWithRelationInput | FingerprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FingerprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fingerprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fingerprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fingerprints
    **/
    _count?: true | FingerprintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FingerprintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FingerprintMaxAggregateInputType
  }

  export type GetFingerprintAggregateType<T extends FingerprintAggregateArgs> = {
        [P in keyof T & keyof AggregateFingerprint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFingerprint[P]>
      : GetScalarType<T[P], AggregateFingerprint[P]>
  }




  export type FingerprintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FingerprintWhereInput
    orderBy?: FingerprintOrderByWithAggregationInput | FingerprintOrderByWithAggregationInput[]
    by: FingerprintScalarFieldEnum[] | FingerprintScalarFieldEnum
    having?: FingerprintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FingerprintCountAggregateInputType | true
    _min?: FingerprintMinAggregateInputType
    _max?: FingerprintMaxAggregateInputType
  }

  export type FingerprintGroupByOutputType = {
    id: string
    accountId: string | null
    fingerprint: string
    roles: string[]
    createdAt: Date
    updatedAt: Date
    _count: FingerprintCountAggregateOutputType | null
    _min: FingerprintMinAggregateOutputType | null
    _max: FingerprintMaxAggregateOutputType | null
  }

  type GetFingerprintGroupByPayload<T extends FingerprintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FingerprintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FingerprintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FingerprintGroupByOutputType[P]>
            : GetScalarType<T[P], FingerprintGroupByOutputType[P]>
        }
      >
    >


  export type FingerprintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    fingerprint?: boolean
    roles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | Fingerprint$accountArgs<ExtArgs>
    visits?: boolean | Fingerprint$visitsArgs<ExtArgs>
    _count?: boolean | FingerprintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fingerprint"]>



  export type FingerprintSelectScalar = {
    id?: boolean
    accountId?: boolean
    fingerprint?: boolean
    roles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FingerprintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "fingerprint" | "roles" | "createdAt" | "updatedAt", ExtArgs["result"]["fingerprint"]>
  export type FingerprintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Fingerprint$accountArgs<ExtArgs>
    visits?: boolean | Fingerprint$visitsArgs<ExtArgs>
    _count?: boolean | FingerprintCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FingerprintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fingerprint"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      visits: Prisma.$VisitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string | null
      fingerprint: string
      roles: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fingerprint"]>
    composites: {}
  }

  type FingerprintGetPayload<S extends boolean | null | undefined | FingerprintDefaultArgs> = $Result.GetResult<Prisma.$FingerprintPayload, S>

  type FingerprintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FingerprintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FingerprintCountAggregateInputType | true
    }

  export interface FingerprintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fingerprint'], meta: { name: 'Fingerprint' } }
    /**
     * Find zero or one Fingerprint that matches the filter.
     * @param {FingerprintFindUniqueArgs} args - Arguments to find a Fingerprint
     * @example
     * // Get one Fingerprint
     * const fingerprint = await prisma.fingerprint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FingerprintFindUniqueArgs>(args: SelectSubset<T, FingerprintFindUniqueArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fingerprint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FingerprintFindUniqueOrThrowArgs} args - Arguments to find a Fingerprint
     * @example
     * // Get one Fingerprint
     * const fingerprint = await prisma.fingerprint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FingerprintFindUniqueOrThrowArgs>(args: SelectSubset<T, FingerprintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fingerprint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintFindFirstArgs} args - Arguments to find a Fingerprint
     * @example
     * // Get one Fingerprint
     * const fingerprint = await prisma.fingerprint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FingerprintFindFirstArgs>(args?: SelectSubset<T, FingerprintFindFirstArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fingerprint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintFindFirstOrThrowArgs} args - Arguments to find a Fingerprint
     * @example
     * // Get one Fingerprint
     * const fingerprint = await prisma.fingerprint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FingerprintFindFirstOrThrowArgs>(args?: SelectSubset<T, FingerprintFindFirstOrThrowArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fingerprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fingerprints
     * const fingerprints = await prisma.fingerprint.findMany()
     * 
     * // Get first 10 Fingerprints
     * const fingerprints = await prisma.fingerprint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fingerprintWithIdOnly = await prisma.fingerprint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FingerprintFindManyArgs>(args?: SelectSubset<T, FingerprintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fingerprint.
     * @param {FingerprintCreateArgs} args - Arguments to create a Fingerprint.
     * @example
     * // Create one Fingerprint
     * const Fingerprint = await prisma.fingerprint.create({
     *   data: {
     *     // ... data to create a Fingerprint
     *   }
     * })
     * 
     */
    create<T extends FingerprintCreateArgs>(args: SelectSubset<T, FingerprintCreateArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fingerprints.
     * @param {FingerprintCreateManyArgs} args - Arguments to create many Fingerprints.
     * @example
     * // Create many Fingerprints
     * const fingerprint = await prisma.fingerprint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FingerprintCreateManyArgs>(args?: SelectSubset<T, FingerprintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fingerprint.
     * @param {FingerprintDeleteArgs} args - Arguments to delete one Fingerprint.
     * @example
     * // Delete one Fingerprint
     * const Fingerprint = await prisma.fingerprint.delete({
     *   where: {
     *     // ... filter to delete one Fingerprint
     *   }
     * })
     * 
     */
    delete<T extends FingerprintDeleteArgs>(args: SelectSubset<T, FingerprintDeleteArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fingerprint.
     * @param {FingerprintUpdateArgs} args - Arguments to update one Fingerprint.
     * @example
     * // Update one Fingerprint
     * const fingerprint = await prisma.fingerprint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FingerprintUpdateArgs>(args: SelectSubset<T, FingerprintUpdateArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fingerprints.
     * @param {FingerprintDeleteManyArgs} args - Arguments to filter Fingerprints to delete.
     * @example
     * // Delete a few Fingerprints
     * const { count } = await prisma.fingerprint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FingerprintDeleteManyArgs>(args?: SelectSubset<T, FingerprintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fingerprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fingerprints
     * const fingerprint = await prisma.fingerprint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FingerprintUpdateManyArgs>(args: SelectSubset<T, FingerprintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fingerprint.
     * @param {FingerprintUpsertArgs} args - Arguments to update or create a Fingerprint.
     * @example
     * // Update or create a Fingerprint
     * const fingerprint = await prisma.fingerprint.upsert({
     *   create: {
     *     // ... data to create a Fingerprint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fingerprint we want to update
     *   }
     * })
     */
    upsert<T extends FingerprintUpsertArgs>(args: SelectSubset<T, FingerprintUpsertArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fingerprints that matches the filter.
     * @param {FingerprintFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fingerprint = await prisma.fingerprint.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FingerprintFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Fingerprint.
     * @param {FingerprintAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fingerprint = await prisma.fingerprint.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FingerprintAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Fingerprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintCountArgs} args - Arguments to filter Fingerprints to count.
     * @example
     * // Count the number of Fingerprints
     * const count = await prisma.fingerprint.count({
     *   where: {
     *     // ... the filter for the Fingerprints we want to count
     *   }
     * })
    **/
    count<T extends FingerprintCountArgs>(
      args?: Subset<T, FingerprintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FingerprintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fingerprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FingerprintAggregateArgs>(args: Subset<T, FingerprintAggregateArgs>): Prisma.PrismaPromise<GetFingerprintAggregateType<T>>

    /**
     * Group by Fingerprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FingerprintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FingerprintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FingerprintGroupByArgs['orderBy'] }
        : { orderBy?: FingerprintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FingerprintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFingerprintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fingerprint model
   */
  readonly fields: FingerprintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fingerprint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FingerprintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends Fingerprint$accountArgs<ExtArgs> = {}>(args?: Subset<T, Fingerprint$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visits<T extends Fingerprint$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Fingerprint$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fingerprint model
   */
  interface FingerprintFieldRefs {
    readonly id: FieldRef<"Fingerprint", 'String'>
    readonly accountId: FieldRef<"Fingerprint", 'String'>
    readonly fingerprint: FieldRef<"Fingerprint", 'String'>
    readonly roles: FieldRef<"Fingerprint", 'String[]'>
    readonly createdAt: FieldRef<"Fingerprint", 'DateTime'>
    readonly updatedAt: FieldRef<"Fingerprint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fingerprint findUnique
   */
  export type FingerprintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * Filter, which Fingerprint to fetch.
     */
    where: FingerprintWhereUniqueInput
  }

  /**
   * Fingerprint findUniqueOrThrow
   */
  export type FingerprintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * Filter, which Fingerprint to fetch.
     */
    where: FingerprintWhereUniqueInput
  }

  /**
   * Fingerprint findFirst
   */
  export type FingerprintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * Filter, which Fingerprint to fetch.
     */
    where?: FingerprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fingerprints to fetch.
     */
    orderBy?: FingerprintOrderByWithRelationInput | FingerprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fingerprints.
     */
    cursor?: FingerprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fingerprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fingerprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fingerprints.
     */
    distinct?: FingerprintScalarFieldEnum | FingerprintScalarFieldEnum[]
  }

  /**
   * Fingerprint findFirstOrThrow
   */
  export type FingerprintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * Filter, which Fingerprint to fetch.
     */
    where?: FingerprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fingerprints to fetch.
     */
    orderBy?: FingerprintOrderByWithRelationInput | FingerprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fingerprints.
     */
    cursor?: FingerprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fingerprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fingerprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fingerprints.
     */
    distinct?: FingerprintScalarFieldEnum | FingerprintScalarFieldEnum[]
  }

  /**
   * Fingerprint findMany
   */
  export type FingerprintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * Filter, which Fingerprints to fetch.
     */
    where?: FingerprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fingerprints to fetch.
     */
    orderBy?: FingerprintOrderByWithRelationInput | FingerprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fingerprints.
     */
    cursor?: FingerprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fingerprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fingerprints.
     */
    skip?: number
    distinct?: FingerprintScalarFieldEnum | FingerprintScalarFieldEnum[]
  }

  /**
   * Fingerprint create
   */
  export type FingerprintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * The data needed to create a Fingerprint.
     */
    data: XOR<FingerprintCreateInput, FingerprintUncheckedCreateInput>
  }

  /**
   * Fingerprint createMany
   */
  export type FingerprintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fingerprints.
     */
    data: FingerprintCreateManyInput | FingerprintCreateManyInput[]
  }

  /**
   * Fingerprint update
   */
  export type FingerprintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * The data needed to update a Fingerprint.
     */
    data: XOR<FingerprintUpdateInput, FingerprintUncheckedUpdateInput>
    /**
     * Choose, which Fingerprint to update.
     */
    where: FingerprintWhereUniqueInput
  }

  /**
   * Fingerprint updateMany
   */
  export type FingerprintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fingerprints.
     */
    data: XOR<FingerprintUpdateManyMutationInput, FingerprintUncheckedUpdateManyInput>
    /**
     * Filter which Fingerprints to update
     */
    where?: FingerprintWhereInput
    /**
     * Limit how many Fingerprints to update.
     */
    limit?: number
  }

  /**
   * Fingerprint upsert
   */
  export type FingerprintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * The filter to search for the Fingerprint to update in case it exists.
     */
    where: FingerprintWhereUniqueInput
    /**
     * In case the Fingerprint found by the `where` argument doesn't exist, create a new Fingerprint with this data.
     */
    create: XOR<FingerprintCreateInput, FingerprintUncheckedCreateInput>
    /**
     * In case the Fingerprint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FingerprintUpdateInput, FingerprintUncheckedUpdateInput>
  }

  /**
   * Fingerprint delete
   */
  export type FingerprintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
    /**
     * Filter which Fingerprint to delete.
     */
    where: FingerprintWhereUniqueInput
  }

  /**
   * Fingerprint deleteMany
   */
  export type FingerprintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fingerprints to delete
     */
    where?: FingerprintWhereInput
    /**
     * Limit how many Fingerprints to delete.
     */
    limit?: number
  }

  /**
   * Fingerprint findRaw
   */
  export type FingerprintFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Fingerprint aggregateRaw
   */
  export type FingerprintAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Fingerprint.account
   */
  export type Fingerprint$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Fingerprint.visits
   */
  export type Fingerprint$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Fingerprint without action
   */
  export type FingerprintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fingerprint
     */
    select?: FingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fingerprint
     */
    omit?: FingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FingerprintInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    name: string | null
    description: string | null
    avatar: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    name: string | null
    description: string | null
    avatar: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    accountId: number
    name: number
    description: number
    avatar: number
    isActive: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentMinAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    description?: true
    avatar?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    description?: true
    avatar?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    description?: true
    avatar?: true
    isActive?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    accountId: string
    name: string
    description: string | null
    avatar: string | null
    isActive: boolean
    config: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    name?: boolean
    description?: boolean
    avatar?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    knowledge?: boolean | Agent$knowledgeArgs<ExtArgs>
    missions?: boolean | Agent$missionsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>



  export type AgentSelectScalar = {
    id?: boolean
    accountId?: boolean
    name?: boolean
    description?: boolean
    avatar?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "name" | "description" | "avatar" | "isActive" | "config" | "createdAt" | "updatedAt", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    knowledge?: boolean | Agent$knowledgeArgs<ExtArgs>
    missions?: boolean | Agent$missionsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      knowledge: Prisma.$KnowledgePayload<ExtArgs>[]
      missions: Prisma.$MissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      name: string
      description: string | null
      avatar: string | null
      isActive: boolean
      config: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * @param {AgentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agent = await prisma.agent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Agent.
     * @param {AgentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agent = await prisma.agent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    knowledge<T extends Agent$knowledgeArgs<ExtArgs> = {}>(args?: Subset<T, Agent$knowledgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    missions<T extends Agent$missionsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$missionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly accountId: FieldRef<"Agent", 'String'>
    readonly name: FieldRef<"Agent", 'String'>
    readonly description: FieldRef<"Agent", 'String'>
    readonly avatar: FieldRef<"Agent", 'String'>
    readonly isActive: FieldRef<"Agent", 'Boolean'>
    readonly config: FieldRef<"Agent", 'Json'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent findRaw
   */
  export type AgentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Agent aggregateRaw
   */
  export type AgentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Agent.knowledge
   */
  export type Agent$knowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    where?: KnowledgeWhereInput
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    cursor?: KnowledgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Agent.missions
   */
  export type Agent$missionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    cursor?: MissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Visit
   */

  export type AggregateVisit = {
    _count: VisitCountAggregateOutputType | null
    _avg: VisitAvgAggregateOutputType | null
    _sum: VisitSumAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  export type VisitAvgAggregateOutputType = {
    duration: number | null
  }

  export type VisitSumAggregateOutputType = {
    duration: number | null
  }

  export type VisitMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    fingerprintId: string | null
    path: string | null
    userAgent: string | null
    ipAddress: string | null
    referrer: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type VisitMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    fingerprintId: string | null
    path: string | null
    userAgent: string | null
    ipAddress: string | null
    referrer: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type VisitCountAggregateOutputType = {
    id: number
    profileId: number
    fingerprintId: number
    path: number
    userAgent: number
    ipAddress: number
    referrer: number
    duration: number
    createdAt: number
    _all: number
  }


  export type VisitAvgAggregateInputType = {
    duration?: true
  }

  export type VisitSumAggregateInputType = {
    duration?: true
  }

  export type VisitMinAggregateInputType = {
    id?: true
    profileId?: true
    fingerprintId?: true
    path?: true
    userAgent?: true
    ipAddress?: true
    referrer?: true
    duration?: true
    createdAt?: true
  }

  export type VisitMaxAggregateInputType = {
    id?: true
    profileId?: true
    fingerprintId?: true
    path?: true
    userAgent?: true
    ipAddress?: true
    referrer?: true
    duration?: true
    createdAt?: true
  }

  export type VisitCountAggregateInputType = {
    id?: true
    profileId?: true
    fingerprintId?: true
    path?: true
    userAgent?: true
    ipAddress?: true
    referrer?: true
    duration?: true
    createdAt?: true
    _all?: true
  }

  export type VisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visit to aggregate.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visits
    **/
    _count?: true | VisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitMaxAggregateInputType
  }

  export type GetVisitAggregateType<T extends VisitAggregateArgs> = {
        [P in keyof T & keyof AggregateVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisit[P]>
      : GetScalarType<T[P], AggregateVisit[P]>
  }




  export type VisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithAggregationInput | VisitOrderByWithAggregationInput[]
    by: VisitScalarFieldEnum[] | VisitScalarFieldEnum
    having?: VisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitCountAggregateInputType | true
    _avg?: VisitAvgAggregateInputType
    _sum?: VisitSumAggregateInputType
    _min?: VisitMinAggregateInputType
    _max?: VisitMaxAggregateInputType
  }

  export type VisitGroupByOutputType = {
    id: string
    profileId: string | null
    fingerprintId: string
    path: string
    userAgent: string | null
    ipAddress: string | null
    referrer: string | null
    duration: number | null
    createdAt: Date
    _count: VisitCountAggregateOutputType | null
    _avg: VisitAvgAggregateOutputType | null
    _sum: VisitSumAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  type GetVisitGroupByPayload<T extends VisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitGroupByOutputType[P]>
            : GetScalarType<T[P], VisitGroupByOutputType[P]>
        }
      >
    >


  export type VisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    fingerprintId?: boolean
    path?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referrer?: boolean
    duration?: boolean
    createdAt?: boolean
    profile?: boolean | Visit$profileArgs<ExtArgs>
    fingerprint?: boolean | FingerprintDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visit"]>



  export type VisitSelectScalar = {
    id?: boolean
    profileId?: boolean
    fingerprintId?: boolean
    path?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referrer?: boolean
    duration?: boolean
    createdAt?: boolean
  }

  export type VisitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "fingerprintId" | "path" | "userAgent" | "ipAddress" | "referrer" | "duration" | "createdAt", ExtArgs["result"]["visit"]>
  export type VisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | Visit$profileArgs<ExtArgs>
    fingerprint?: boolean | FingerprintDefaultArgs<ExtArgs>
  }

  export type $VisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visit"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      fingerprint: Prisma.$FingerprintPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string | null
      fingerprintId: string
      path: string
      userAgent: string | null
      ipAddress: string | null
      referrer: string | null
      duration: number | null
      createdAt: Date
    }, ExtArgs["result"]["visit"]>
    composites: {}
  }

  type VisitGetPayload<S extends boolean | null | undefined | VisitDefaultArgs> = $Result.GetResult<Prisma.$VisitPayload, S>

  type VisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitCountAggregateInputType | true
    }

  export interface VisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visit'], meta: { name: 'Visit' } }
    /**
     * Find zero or one Visit that matches the filter.
     * @param {VisitFindUniqueArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitFindUniqueArgs>(args: SelectSubset<T, VisitFindUniqueArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitFindUniqueOrThrowArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitFindFirstArgs>(args?: SelectSubset<T, VisitFindFirstArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstOrThrowArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visits
     * const visits = await prisma.visit.findMany()
     * 
     * // Get first 10 Visits
     * const visits = await prisma.visit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitWithIdOnly = await prisma.visit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitFindManyArgs>(args?: SelectSubset<T, VisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visit.
     * @param {VisitCreateArgs} args - Arguments to create a Visit.
     * @example
     * // Create one Visit
     * const Visit = await prisma.visit.create({
     *   data: {
     *     // ... data to create a Visit
     *   }
     * })
     * 
     */
    create<T extends VisitCreateArgs>(args: SelectSubset<T, VisitCreateArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visits.
     * @param {VisitCreateManyArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visit = await prisma.visit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitCreateManyArgs>(args?: SelectSubset<T, VisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visit.
     * @param {VisitDeleteArgs} args - Arguments to delete one Visit.
     * @example
     * // Delete one Visit
     * const Visit = await prisma.visit.delete({
     *   where: {
     *     // ... filter to delete one Visit
     *   }
     * })
     * 
     */
    delete<T extends VisitDeleteArgs>(args: SelectSubset<T, VisitDeleteArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visit.
     * @param {VisitUpdateArgs} args - Arguments to update one Visit.
     * @example
     * // Update one Visit
     * const visit = await prisma.visit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitUpdateArgs>(args: SelectSubset<T, VisitUpdateArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visits.
     * @param {VisitDeleteManyArgs} args - Arguments to filter Visits to delete.
     * @example
     * // Delete a few Visits
     * const { count } = await prisma.visit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitDeleteManyArgs>(args?: SelectSubset<T, VisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visits
     * const visit = await prisma.visit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitUpdateManyArgs>(args: SelectSubset<T, VisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visit.
     * @param {VisitUpsertArgs} args - Arguments to update or create a Visit.
     * @example
     * // Update or create a Visit
     * const visit = await prisma.visit.upsert({
     *   create: {
     *     // ... data to create a Visit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visit we want to update
     *   }
     * })
     */
    upsert<T extends VisitUpsertArgs>(args: SelectSubset<T, VisitUpsertArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visits that matches the filter.
     * @param {VisitFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const visit = await prisma.visit.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VisitFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Visit.
     * @param {VisitAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const visit = await prisma.visit.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VisitAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCountArgs} args - Arguments to filter Visits to count.
     * @example
     * // Count the number of Visits
     * const count = await prisma.visit.count({
     *   where: {
     *     // ... the filter for the Visits we want to count
     *   }
     * })
    **/
    count<T extends VisitCountArgs>(
      args?: Subset<T, VisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitAggregateArgs>(args: Subset<T, VisitAggregateArgs>): Prisma.PrismaPromise<GetVisitAggregateType<T>>

    /**
     * Group by Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitGroupByArgs['orderBy'] }
        : { orderBy?: VisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visit model
   */
  readonly fields: VisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends Visit$profileArgs<ExtArgs> = {}>(args?: Subset<T, Visit$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fingerprint<T extends FingerprintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FingerprintDefaultArgs<ExtArgs>>): Prisma__FingerprintClient<$Result.GetResult<Prisma.$FingerprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visit model
   */
  interface VisitFieldRefs {
    readonly id: FieldRef<"Visit", 'String'>
    readonly profileId: FieldRef<"Visit", 'String'>
    readonly fingerprintId: FieldRef<"Visit", 'String'>
    readonly path: FieldRef<"Visit", 'String'>
    readonly userAgent: FieldRef<"Visit", 'String'>
    readonly ipAddress: FieldRef<"Visit", 'String'>
    readonly referrer: FieldRef<"Visit", 'String'>
    readonly duration: FieldRef<"Visit", 'Int'>
    readonly createdAt: FieldRef<"Visit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visit findUnique
   */
  export type VisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit findUniqueOrThrow
   */
  export type VisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit findFirst
   */
  export type VisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit findFirstOrThrow
   */
  export type VisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit findMany
   */
  export type VisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit create
   */
  export type VisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The data needed to create a Visit.
     */
    data: XOR<VisitCreateInput, VisitUncheckedCreateInput>
  }

  /**
   * Visit createMany
   */
  export type VisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visits.
     */
    data: VisitCreateManyInput | VisitCreateManyInput[]
  }

  /**
   * Visit update
   */
  export type VisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The data needed to update a Visit.
     */
    data: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
    /**
     * Choose, which Visit to update.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit updateMany
   */
  export type VisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visits.
     */
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyInput>
    /**
     * Filter which Visits to update
     */
    where?: VisitWhereInput
    /**
     * Limit how many Visits to update.
     */
    limit?: number
  }

  /**
   * Visit upsert
   */
  export type VisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The filter to search for the Visit to update in case it exists.
     */
    where: VisitWhereUniqueInput
    /**
     * In case the Visit found by the `where` argument doesn't exist, create a new Visit with this data.
     */
    create: XOR<VisitCreateInput, VisitUncheckedCreateInput>
    /**
     * In case the Visit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
  }

  /**
   * Visit delete
   */
  export type VisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter which Visit to delete.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit deleteMany
   */
  export type VisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visits to delete
     */
    where?: VisitWhereInput
    /**
     * Limit how many Visits to delete.
     */
    limit?: number
  }

  /**
   * Visit findRaw
   */
  export type VisitFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Visit aggregateRaw
   */
  export type VisitAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Visit.profile
   */
  export type Visit$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Visit without action
   */
  export type VisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visit
     */
    omit?: VisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
  }


  /**
   * Model Impression
   */

  export type AggregateImpression = {
    _count: ImpressionCountAggregateOutputType | null
    _min: ImpressionMinAggregateOutputType | null
    _max: ImpressionMaxAggregateOutputType | null
  }

  export type ImpressionMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type ImpressionMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type ImpressionCountAggregateOutputType = {
    id: number
    profileId: number
    type: number
    context: number
    createdAt: number
    _all: number
  }


  export type ImpressionMinAggregateInputType = {
    id?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type ImpressionMaxAggregateInputType = {
    id?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type ImpressionCountAggregateInputType = {
    id?: true
    profileId?: true
    type?: true
    context?: true
    createdAt?: true
    _all?: true
  }

  export type ImpressionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Impression to aggregate.
     */
    where?: ImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impressions to fetch.
     */
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Impressions
    **/
    _count?: true | ImpressionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImpressionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImpressionMaxAggregateInputType
  }

  export type GetImpressionAggregateType<T extends ImpressionAggregateArgs> = {
        [P in keyof T & keyof AggregateImpression]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpression[P]>
      : GetScalarType<T[P], AggregateImpression[P]>
  }




  export type ImpressionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpressionWhereInput
    orderBy?: ImpressionOrderByWithAggregationInput | ImpressionOrderByWithAggregationInput[]
    by: ImpressionScalarFieldEnum[] | ImpressionScalarFieldEnum
    having?: ImpressionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImpressionCountAggregateInputType | true
    _min?: ImpressionMinAggregateInputType
    _max?: ImpressionMaxAggregateInputType
  }

  export type ImpressionGroupByOutputType = {
    id: string
    profileId: string
    type: string
    context: JsonValue | null
    createdAt: Date
    _count: ImpressionCountAggregateOutputType | null
    _min: ImpressionMinAggregateOutputType | null
    _max: ImpressionMaxAggregateOutputType | null
  }

  type GetImpressionGroupByPayload<T extends ImpressionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImpressionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImpressionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImpressionGroupByOutputType[P]>
            : GetScalarType<T[P], ImpressionGroupByOutputType[P]>
        }
      >
    >


  export type ImpressionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    type?: boolean
    context?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impression"]>



  export type ImpressionSelectScalar = {
    id?: boolean
    profileId?: boolean
    type?: boolean
    context?: boolean
    createdAt?: boolean
  }

  export type ImpressionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "type" | "context" | "createdAt", ExtArgs["result"]["impression"]>
  export type ImpressionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ImpressionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Impression"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      type: string
      context: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["impression"]>
    composites: {}
  }

  type ImpressionGetPayload<S extends boolean | null | undefined | ImpressionDefaultArgs> = $Result.GetResult<Prisma.$ImpressionPayload, S>

  type ImpressionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImpressionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImpressionCountAggregateInputType | true
    }

  export interface ImpressionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Impression'], meta: { name: 'Impression' } }
    /**
     * Find zero or one Impression that matches the filter.
     * @param {ImpressionFindUniqueArgs} args - Arguments to find a Impression
     * @example
     * // Get one Impression
     * const impression = await prisma.impression.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImpressionFindUniqueArgs>(args: SelectSubset<T, ImpressionFindUniqueArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Impression that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImpressionFindUniqueOrThrowArgs} args - Arguments to find a Impression
     * @example
     * // Get one Impression
     * const impression = await prisma.impression.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImpressionFindUniqueOrThrowArgs>(args: SelectSubset<T, ImpressionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impression that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionFindFirstArgs} args - Arguments to find a Impression
     * @example
     * // Get one Impression
     * const impression = await prisma.impression.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImpressionFindFirstArgs>(args?: SelectSubset<T, ImpressionFindFirstArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impression that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionFindFirstOrThrowArgs} args - Arguments to find a Impression
     * @example
     * // Get one Impression
     * const impression = await prisma.impression.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImpressionFindFirstOrThrowArgs>(args?: SelectSubset<T, ImpressionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Impressions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Impressions
     * const impressions = await prisma.impression.findMany()
     * 
     * // Get first 10 Impressions
     * const impressions = await prisma.impression.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impressionWithIdOnly = await prisma.impression.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImpressionFindManyArgs>(args?: SelectSubset<T, ImpressionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Impression.
     * @param {ImpressionCreateArgs} args - Arguments to create a Impression.
     * @example
     * // Create one Impression
     * const Impression = await prisma.impression.create({
     *   data: {
     *     // ... data to create a Impression
     *   }
     * })
     * 
     */
    create<T extends ImpressionCreateArgs>(args: SelectSubset<T, ImpressionCreateArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Impressions.
     * @param {ImpressionCreateManyArgs} args - Arguments to create many Impressions.
     * @example
     * // Create many Impressions
     * const impression = await prisma.impression.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImpressionCreateManyArgs>(args?: SelectSubset<T, ImpressionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Impression.
     * @param {ImpressionDeleteArgs} args - Arguments to delete one Impression.
     * @example
     * // Delete one Impression
     * const Impression = await prisma.impression.delete({
     *   where: {
     *     // ... filter to delete one Impression
     *   }
     * })
     * 
     */
    delete<T extends ImpressionDeleteArgs>(args: SelectSubset<T, ImpressionDeleteArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Impression.
     * @param {ImpressionUpdateArgs} args - Arguments to update one Impression.
     * @example
     * // Update one Impression
     * const impression = await prisma.impression.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImpressionUpdateArgs>(args: SelectSubset<T, ImpressionUpdateArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Impressions.
     * @param {ImpressionDeleteManyArgs} args - Arguments to filter Impressions to delete.
     * @example
     * // Delete a few Impressions
     * const { count } = await prisma.impression.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImpressionDeleteManyArgs>(args?: SelectSubset<T, ImpressionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Impressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Impressions
     * const impression = await prisma.impression.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImpressionUpdateManyArgs>(args: SelectSubset<T, ImpressionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Impression.
     * @param {ImpressionUpsertArgs} args - Arguments to update or create a Impression.
     * @example
     * // Update or create a Impression
     * const impression = await prisma.impression.upsert({
     *   create: {
     *     // ... data to create a Impression
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Impression we want to update
     *   }
     * })
     */
    upsert<T extends ImpressionUpsertArgs>(args: SelectSubset<T, ImpressionUpsertArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Impressions that matches the filter.
     * @param {ImpressionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const impression = await prisma.impression.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ImpressionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Impression.
     * @param {ImpressionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const impression = await prisma.impression.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ImpressionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Impressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionCountArgs} args - Arguments to filter Impressions to count.
     * @example
     * // Count the number of Impressions
     * const count = await prisma.impression.count({
     *   where: {
     *     // ... the filter for the Impressions we want to count
     *   }
     * })
    **/
    count<T extends ImpressionCountArgs>(
      args?: Subset<T, ImpressionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImpressionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Impression.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImpressionAggregateArgs>(args: Subset<T, ImpressionAggregateArgs>): Prisma.PrismaPromise<GetImpressionAggregateType<T>>

    /**
     * Group by Impression.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImpressionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImpressionGroupByArgs['orderBy'] }
        : { orderBy?: ImpressionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImpressionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpressionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Impression model
   */
  readonly fields: ImpressionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Impression.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImpressionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Impression model
   */
  interface ImpressionFieldRefs {
    readonly id: FieldRef<"Impression", 'String'>
    readonly profileId: FieldRef<"Impression", 'String'>
    readonly type: FieldRef<"Impression", 'String'>
    readonly context: FieldRef<"Impression", 'Json'>
    readonly createdAt: FieldRef<"Impression", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Impression findUnique
   */
  export type ImpressionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impression to fetch.
     */
    where: ImpressionWhereUniqueInput
  }

  /**
   * Impression findUniqueOrThrow
   */
  export type ImpressionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impression to fetch.
     */
    where: ImpressionWhereUniqueInput
  }

  /**
   * Impression findFirst
   */
  export type ImpressionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impression to fetch.
     */
    where?: ImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impressions to fetch.
     */
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Impressions.
     */
    cursor?: ImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Impressions.
     */
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Impression findFirstOrThrow
   */
  export type ImpressionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impression to fetch.
     */
    where?: ImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impressions to fetch.
     */
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Impressions.
     */
    cursor?: ImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Impressions.
     */
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Impression findMany
   */
  export type ImpressionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impressions to fetch.
     */
    where?: ImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impressions to fetch.
     */
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Impressions.
     */
    cursor?: ImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impressions.
     */
    skip?: number
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Impression create
   */
  export type ImpressionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * The data needed to create a Impression.
     */
    data: XOR<ImpressionCreateInput, ImpressionUncheckedCreateInput>
  }

  /**
   * Impression createMany
   */
  export type ImpressionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Impressions.
     */
    data: ImpressionCreateManyInput | ImpressionCreateManyInput[]
  }

  /**
   * Impression update
   */
  export type ImpressionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * The data needed to update a Impression.
     */
    data: XOR<ImpressionUpdateInput, ImpressionUncheckedUpdateInput>
    /**
     * Choose, which Impression to update.
     */
    where: ImpressionWhereUniqueInput
  }

  /**
   * Impression updateMany
   */
  export type ImpressionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Impressions.
     */
    data: XOR<ImpressionUpdateManyMutationInput, ImpressionUncheckedUpdateManyInput>
    /**
     * Filter which Impressions to update
     */
    where?: ImpressionWhereInput
    /**
     * Limit how many Impressions to update.
     */
    limit?: number
  }

  /**
   * Impression upsert
   */
  export type ImpressionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * The filter to search for the Impression to update in case it exists.
     */
    where: ImpressionWhereUniqueInput
    /**
     * In case the Impression found by the `where` argument doesn't exist, create a new Impression with this data.
     */
    create: XOR<ImpressionCreateInput, ImpressionUncheckedCreateInput>
    /**
     * In case the Impression was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImpressionUpdateInput, ImpressionUncheckedUpdateInput>
  }

  /**
   * Impression delete
   */
  export type ImpressionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter which Impression to delete.
     */
    where: ImpressionWhereUniqueInput
  }

  /**
   * Impression deleteMany
   */
  export type ImpressionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Impressions to delete
     */
    where?: ImpressionWhereInput
    /**
     * Limit how many Impressions to delete.
     */
    limit?: number
  }

  /**
   * Impression findRaw
   */
  export type ImpressionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Impression aggregateRaw
   */
  export type ImpressionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Impression without action
   */
  export type ImpressionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
  }


  /**
   * Model SocialProfile
   */

  export type AggregateSocialProfile = {
    _count: SocialProfileCountAggregateOutputType | null
    _min: SocialProfileMinAggregateOutputType | null
    _max: SocialProfileMaxAggregateOutputType | null
  }

  export type SocialProfileMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    platform: string | null
    username: string | null
    url: string | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialProfileMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    platform: string | null
    username: string | null
    url: string | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialProfileCountAggregateOutputType = {
    id: number
    profileId: number
    platform: number
    username: number
    url: number
    verified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialProfileMinAggregateInputType = {
    id?: true
    profileId?: true
    platform?: true
    username?: true
    url?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialProfileMaxAggregateInputType = {
    id?: true
    profileId?: true
    platform?: true
    username?: true
    url?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialProfileCountAggregateInputType = {
    id?: true
    profileId?: true
    platform?: true
    username?: true
    url?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialProfile to aggregate.
     */
    where?: SocialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProfiles to fetch.
     */
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialProfiles
    **/
    _count?: true | SocialProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialProfileMaxAggregateInputType
  }

  export type GetSocialProfileAggregateType<T extends SocialProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialProfile[P]>
      : GetScalarType<T[P], AggregateSocialProfile[P]>
  }




  export type SocialProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialProfileWhereInput
    orderBy?: SocialProfileOrderByWithAggregationInput | SocialProfileOrderByWithAggregationInput[]
    by: SocialProfileScalarFieldEnum[] | SocialProfileScalarFieldEnum
    having?: SocialProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialProfileCountAggregateInputType | true
    _min?: SocialProfileMinAggregateInputType
    _max?: SocialProfileMaxAggregateInputType
  }

  export type SocialProfileGroupByOutputType = {
    id: string
    profileId: string
    platform: string
    username: string
    url: string | null
    verified: boolean
    createdAt: Date
    updatedAt: Date
    _count: SocialProfileCountAggregateOutputType | null
    _min: SocialProfileMinAggregateOutputType | null
    _max: SocialProfileMaxAggregateOutputType | null
  }

  type GetSocialProfileGroupByPayload<T extends SocialProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialProfileGroupByOutputType[P]>
            : GetScalarType<T[P], SocialProfileGroupByOutputType[P]>
        }
      >
    >


  export type SocialProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    platform?: boolean
    username?: boolean
    url?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialProfile"]>



  export type SocialProfileSelectScalar = {
    id?: boolean
    profileId?: boolean
    platform?: boolean
    username?: boolean
    url?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "platform" | "username" | "url" | "verified" | "createdAt" | "updatedAt", ExtArgs["result"]["socialProfile"]>
  export type SocialProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $SocialProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialProfile"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      platform: string
      username: string
      url: string | null
      verified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialProfile"]>
    composites: {}
  }

  type SocialProfileGetPayload<S extends boolean | null | undefined | SocialProfileDefaultArgs> = $Result.GetResult<Prisma.$SocialProfilePayload, S>

  type SocialProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialProfileCountAggregateInputType | true
    }

  export interface SocialProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialProfile'], meta: { name: 'SocialProfile' } }
    /**
     * Find zero or one SocialProfile that matches the filter.
     * @param {SocialProfileFindUniqueArgs} args - Arguments to find a SocialProfile
     * @example
     * // Get one SocialProfile
     * const socialProfile = await prisma.socialProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialProfileFindUniqueArgs>(args: SelectSubset<T, SocialProfileFindUniqueArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialProfileFindUniqueOrThrowArgs} args - Arguments to find a SocialProfile
     * @example
     * // Get one SocialProfile
     * const socialProfile = await prisma.socialProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileFindFirstArgs} args - Arguments to find a SocialProfile
     * @example
     * // Get one SocialProfile
     * const socialProfile = await prisma.socialProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialProfileFindFirstArgs>(args?: SelectSubset<T, SocialProfileFindFirstArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileFindFirstOrThrowArgs} args - Arguments to find a SocialProfile
     * @example
     * // Get one SocialProfile
     * const socialProfile = await prisma.socialProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialProfiles
     * const socialProfiles = await prisma.socialProfile.findMany()
     * 
     * // Get first 10 SocialProfiles
     * const socialProfiles = await prisma.socialProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialProfileWithIdOnly = await prisma.socialProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialProfileFindManyArgs>(args?: SelectSubset<T, SocialProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialProfile.
     * @param {SocialProfileCreateArgs} args - Arguments to create a SocialProfile.
     * @example
     * // Create one SocialProfile
     * const SocialProfile = await prisma.socialProfile.create({
     *   data: {
     *     // ... data to create a SocialProfile
     *   }
     * })
     * 
     */
    create<T extends SocialProfileCreateArgs>(args: SelectSubset<T, SocialProfileCreateArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialProfiles.
     * @param {SocialProfileCreateManyArgs} args - Arguments to create many SocialProfiles.
     * @example
     * // Create many SocialProfiles
     * const socialProfile = await prisma.socialProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialProfileCreateManyArgs>(args?: SelectSubset<T, SocialProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialProfile.
     * @param {SocialProfileDeleteArgs} args - Arguments to delete one SocialProfile.
     * @example
     * // Delete one SocialProfile
     * const SocialProfile = await prisma.socialProfile.delete({
     *   where: {
     *     // ... filter to delete one SocialProfile
     *   }
     * })
     * 
     */
    delete<T extends SocialProfileDeleteArgs>(args: SelectSubset<T, SocialProfileDeleteArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialProfile.
     * @param {SocialProfileUpdateArgs} args - Arguments to update one SocialProfile.
     * @example
     * // Update one SocialProfile
     * const socialProfile = await prisma.socialProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialProfileUpdateArgs>(args: SelectSubset<T, SocialProfileUpdateArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialProfiles.
     * @param {SocialProfileDeleteManyArgs} args - Arguments to filter SocialProfiles to delete.
     * @example
     * // Delete a few SocialProfiles
     * const { count } = await prisma.socialProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialProfileDeleteManyArgs>(args?: SelectSubset<T, SocialProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialProfiles
     * const socialProfile = await prisma.socialProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialProfileUpdateManyArgs>(args: SelectSubset<T, SocialProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialProfile.
     * @param {SocialProfileUpsertArgs} args - Arguments to update or create a SocialProfile.
     * @example
     * // Update or create a SocialProfile
     * const socialProfile = await prisma.socialProfile.upsert({
     *   create: {
     *     // ... data to create a SocialProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialProfile we want to update
     *   }
     * })
     */
    upsert<T extends SocialProfileUpsertArgs>(args: SelectSubset<T, SocialProfileUpsertArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialProfiles that matches the filter.
     * @param {SocialProfileFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const socialProfile = await prisma.socialProfile.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SocialProfileFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SocialProfile.
     * @param {SocialProfileAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const socialProfile = await prisma.socialProfile.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SocialProfileAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SocialProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileCountArgs} args - Arguments to filter SocialProfiles to count.
     * @example
     * // Count the number of SocialProfiles
     * const count = await prisma.socialProfile.count({
     *   where: {
     *     // ... the filter for the SocialProfiles we want to count
     *   }
     * })
    **/
    count<T extends SocialProfileCountArgs>(
      args?: Subset<T, SocialProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialProfileAggregateArgs>(args: Subset<T, SocialProfileAggregateArgs>): Prisma.PrismaPromise<GetSocialProfileAggregateType<T>>

    /**
     * Group by SocialProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialProfileGroupByArgs['orderBy'] }
        : { orderBy?: SocialProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialProfile model
   */
  readonly fields: SocialProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialProfile model
   */
  interface SocialProfileFieldRefs {
    readonly id: FieldRef<"SocialProfile", 'String'>
    readonly profileId: FieldRef<"SocialProfile", 'String'>
    readonly platform: FieldRef<"SocialProfile", 'String'>
    readonly username: FieldRef<"SocialProfile", 'String'>
    readonly url: FieldRef<"SocialProfile", 'String'>
    readonly verified: FieldRef<"SocialProfile", 'Boolean'>
    readonly createdAt: FieldRef<"SocialProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialProfile findUnique
   */
  export type SocialProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * Filter, which SocialProfile to fetch.
     */
    where: SocialProfileWhereUniqueInput
  }

  /**
   * SocialProfile findUniqueOrThrow
   */
  export type SocialProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * Filter, which SocialProfile to fetch.
     */
    where: SocialProfileWhereUniqueInput
  }

  /**
   * SocialProfile findFirst
   */
  export type SocialProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * Filter, which SocialProfile to fetch.
     */
    where?: SocialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProfiles to fetch.
     */
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialProfiles.
     */
    cursor?: SocialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialProfiles.
     */
    distinct?: SocialProfileScalarFieldEnum | SocialProfileScalarFieldEnum[]
  }

  /**
   * SocialProfile findFirstOrThrow
   */
  export type SocialProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * Filter, which SocialProfile to fetch.
     */
    where?: SocialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProfiles to fetch.
     */
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialProfiles.
     */
    cursor?: SocialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialProfiles.
     */
    distinct?: SocialProfileScalarFieldEnum | SocialProfileScalarFieldEnum[]
  }

  /**
   * SocialProfile findMany
   */
  export type SocialProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * Filter, which SocialProfiles to fetch.
     */
    where?: SocialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProfiles to fetch.
     */
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialProfiles.
     */
    cursor?: SocialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProfiles.
     */
    skip?: number
    distinct?: SocialProfileScalarFieldEnum | SocialProfileScalarFieldEnum[]
  }

  /**
   * SocialProfile create
   */
  export type SocialProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialProfile.
     */
    data: XOR<SocialProfileCreateInput, SocialProfileUncheckedCreateInput>
  }

  /**
   * SocialProfile createMany
   */
  export type SocialProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialProfiles.
     */
    data: SocialProfileCreateManyInput | SocialProfileCreateManyInput[]
  }

  /**
   * SocialProfile update
   */
  export type SocialProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialProfile.
     */
    data: XOR<SocialProfileUpdateInput, SocialProfileUncheckedUpdateInput>
    /**
     * Choose, which SocialProfile to update.
     */
    where: SocialProfileWhereUniqueInput
  }

  /**
   * SocialProfile updateMany
   */
  export type SocialProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialProfiles.
     */
    data: XOR<SocialProfileUpdateManyMutationInput, SocialProfileUncheckedUpdateManyInput>
    /**
     * Filter which SocialProfiles to update
     */
    where?: SocialProfileWhereInput
    /**
     * Limit how many SocialProfiles to update.
     */
    limit?: number
  }

  /**
   * SocialProfile upsert
   */
  export type SocialProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialProfile to update in case it exists.
     */
    where: SocialProfileWhereUniqueInput
    /**
     * In case the SocialProfile found by the `where` argument doesn't exist, create a new SocialProfile with this data.
     */
    create: XOR<SocialProfileCreateInput, SocialProfileUncheckedCreateInput>
    /**
     * In case the SocialProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialProfileUpdateInput, SocialProfileUncheckedUpdateInput>
  }

  /**
   * SocialProfile delete
   */
  export type SocialProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
    /**
     * Filter which SocialProfile to delete.
     */
    where: SocialProfileWhereUniqueInput
  }

  /**
   * SocialProfile deleteMany
   */
  export type SocialProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialProfiles to delete
     */
    where?: SocialProfileWhereInput
    /**
     * Limit how many SocialProfiles to delete.
     */
    limit?: number
  }

  /**
   * SocialProfile findRaw
   */
  export type SocialProfileFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SocialProfile aggregateRaw
   */
  export type SocialProfileAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SocialProfile without action
   */
  export type SocialProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialProfile
     */
    omit?: SocialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialProfileInclude<ExtArgs> | null
  }


  /**
   * Model Knowledge
   */

  export type AggregateKnowledge = {
    _count: KnowledgeCountAggregateOutputType | null
    _min: KnowledgeMinAggregateOutputType | null
    _max: KnowledgeMaxAggregateOutputType | null
  }

  export type KnowledgeMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    title: string | null
    content: string | null
    type: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    title: string | null
    content: string | null
    type: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeCountAggregateOutputType = {
    id: number
    agentId: number
    title: number
    content: number
    type: number
    source: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeMinAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    content?: true
    type?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeMaxAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    content?: true
    type?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeCountAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    content?: true
    type?: true
    source?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Knowledge to aggregate.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Knowledges
    **/
    _count?: true | KnowledgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeMaxAggregateInputType
  }

  export type GetKnowledgeAggregateType<T extends KnowledgeAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledge[P]>
      : GetScalarType<T[P], AggregateKnowledge[P]>
  }




  export type KnowledgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeWhereInput
    orderBy?: KnowledgeOrderByWithAggregationInput | KnowledgeOrderByWithAggregationInput[]
    by: KnowledgeScalarFieldEnum[] | KnowledgeScalarFieldEnum
    having?: KnowledgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeCountAggregateInputType | true
    _min?: KnowledgeMinAggregateInputType
    _max?: KnowledgeMaxAggregateInputType
  }

  export type KnowledgeGroupByOutputType = {
    id: string
    agentId: string
    title: string
    content: string
    type: string
    source: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeCountAggregateOutputType | null
    _min: KnowledgeMinAggregateOutputType | null
    _max: KnowledgeMaxAggregateOutputType | null
  }

  type GetKnowledgeGroupByPayload<T extends KnowledgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledge"]>



  export type KnowledgeSelectScalar = {
    id?: boolean
    agentId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "title" | "content" | "type" | "source" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledge"]>
  export type KnowledgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $KnowledgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Knowledge"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      title: string
      content: string
      type: string
      source: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledge"]>
    composites: {}
  }

  type KnowledgeGetPayload<S extends boolean | null | undefined | KnowledgeDefaultArgs> = $Result.GetResult<Prisma.$KnowledgePayload, S>

  type KnowledgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeCountAggregateInputType | true
    }

  export interface KnowledgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Knowledge'], meta: { name: 'Knowledge' } }
    /**
     * Find zero or one Knowledge that matches the filter.
     * @param {KnowledgeFindUniqueArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeFindUniqueArgs>(args: SelectSubset<T, KnowledgeFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Knowledge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeFindUniqueOrThrowArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Knowledge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindFirstArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeFindFirstArgs>(args?: SelectSubset<T, KnowledgeFindFirstArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Knowledge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindFirstOrThrowArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Knowledges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Knowledges
     * const knowledges = await prisma.knowledge.findMany()
     * 
     * // Get first 10 Knowledges
     * const knowledges = await prisma.knowledge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeWithIdOnly = await prisma.knowledge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeFindManyArgs>(args?: SelectSubset<T, KnowledgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Knowledge.
     * @param {KnowledgeCreateArgs} args - Arguments to create a Knowledge.
     * @example
     * // Create one Knowledge
     * const Knowledge = await prisma.knowledge.create({
     *   data: {
     *     // ... data to create a Knowledge
     *   }
     * })
     * 
     */
    create<T extends KnowledgeCreateArgs>(args: SelectSubset<T, KnowledgeCreateArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Knowledges.
     * @param {KnowledgeCreateManyArgs} args - Arguments to create many Knowledges.
     * @example
     * // Create many Knowledges
     * const knowledge = await prisma.knowledge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeCreateManyArgs>(args?: SelectSubset<T, KnowledgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Knowledge.
     * @param {KnowledgeDeleteArgs} args - Arguments to delete one Knowledge.
     * @example
     * // Delete one Knowledge
     * const Knowledge = await prisma.knowledge.delete({
     *   where: {
     *     // ... filter to delete one Knowledge
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeDeleteArgs>(args: SelectSubset<T, KnowledgeDeleteArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Knowledge.
     * @param {KnowledgeUpdateArgs} args - Arguments to update one Knowledge.
     * @example
     * // Update one Knowledge
     * const knowledge = await prisma.knowledge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeUpdateArgs>(args: SelectSubset<T, KnowledgeUpdateArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Knowledges.
     * @param {KnowledgeDeleteManyArgs} args - Arguments to filter Knowledges to delete.
     * @example
     * // Delete a few Knowledges
     * const { count } = await prisma.knowledge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeDeleteManyArgs>(args?: SelectSubset<T, KnowledgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Knowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Knowledges
     * const knowledge = await prisma.knowledge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeUpdateManyArgs>(args: SelectSubset<T, KnowledgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Knowledge.
     * @param {KnowledgeUpsertArgs} args - Arguments to update or create a Knowledge.
     * @example
     * // Update or create a Knowledge
     * const knowledge = await prisma.knowledge.upsert({
     *   create: {
     *     // ... data to create a Knowledge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Knowledge we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeUpsertArgs>(args: SelectSubset<T, KnowledgeUpsertArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Knowledges that matches the filter.
     * @param {KnowledgeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const knowledge = await prisma.knowledge.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: KnowledgeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Knowledge.
     * @param {KnowledgeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const knowledge = await prisma.knowledge.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: KnowledgeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Knowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCountArgs} args - Arguments to filter Knowledges to count.
     * @example
     * // Count the number of Knowledges
     * const count = await prisma.knowledge.count({
     *   where: {
     *     // ... the filter for the Knowledges we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeCountArgs>(
      args?: Subset<T, KnowledgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Knowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeAggregateArgs>(args: Subset<T, KnowledgeAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeAggregateType<T>>

    /**
     * Group by Knowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Knowledge model
   */
  readonly fields: KnowledgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Knowledge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Knowledge model
   */
  interface KnowledgeFieldRefs {
    readonly id: FieldRef<"Knowledge", 'String'>
    readonly agentId: FieldRef<"Knowledge", 'String'>
    readonly title: FieldRef<"Knowledge", 'String'>
    readonly content: FieldRef<"Knowledge", 'String'>
    readonly type: FieldRef<"Knowledge", 'String'>
    readonly source: FieldRef<"Knowledge", 'String'>
    readonly metadata: FieldRef<"Knowledge", 'Json'>
    readonly createdAt: FieldRef<"Knowledge", 'DateTime'>
    readonly updatedAt: FieldRef<"Knowledge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Knowledge findUnique
   */
  export type KnowledgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge findUniqueOrThrow
   */
  export type KnowledgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge findFirst
   */
  export type KnowledgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Knowledges.
     */
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge findFirstOrThrow
   */
  export type KnowledgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Knowledges.
     */
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge findMany
   */
  export type KnowledgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledges to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge create
   */
  export type KnowledgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Knowledge.
     */
    data: XOR<KnowledgeCreateInput, KnowledgeUncheckedCreateInput>
  }

  /**
   * Knowledge createMany
   */
  export type KnowledgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Knowledges.
     */
    data: KnowledgeCreateManyInput | KnowledgeCreateManyInput[]
  }

  /**
   * Knowledge update
   */
  export type KnowledgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Knowledge.
     */
    data: XOR<KnowledgeUpdateInput, KnowledgeUncheckedUpdateInput>
    /**
     * Choose, which Knowledge to update.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge updateMany
   */
  export type KnowledgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Knowledges.
     */
    data: XOR<KnowledgeUpdateManyMutationInput, KnowledgeUncheckedUpdateManyInput>
    /**
     * Filter which Knowledges to update
     */
    where?: KnowledgeWhereInput
    /**
     * Limit how many Knowledges to update.
     */
    limit?: number
  }

  /**
   * Knowledge upsert
   */
  export type KnowledgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Knowledge to update in case it exists.
     */
    where: KnowledgeWhereUniqueInput
    /**
     * In case the Knowledge found by the `where` argument doesn't exist, create a new Knowledge with this data.
     */
    create: XOR<KnowledgeCreateInput, KnowledgeUncheckedCreateInput>
    /**
     * In case the Knowledge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeUpdateInput, KnowledgeUncheckedUpdateInput>
  }

  /**
   * Knowledge delete
   */
  export type KnowledgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter which Knowledge to delete.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge deleteMany
   */
  export type KnowledgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Knowledges to delete
     */
    where?: KnowledgeWhereInput
    /**
     * Limit how many Knowledges to delete.
     */
    limit?: number
  }

  /**
   * Knowledge findRaw
   */
  export type KnowledgeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Knowledge aggregateRaw
   */
  export type KnowledgeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Knowledge without action
   */
  export type KnowledgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
  }


  /**
   * Model Mission
   */

  export type AggregateMission = {
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  export type MissionAvgAggregateOutputType = {
    priority: number | null
  }

  export type MissionSumAggregateOutputType = {
    priority: number | null
  }

  export type MissionMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    title: string | null
    description: string | null
    status: $Enums.MissionStatus | null
    priority: number | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MissionMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    title: string | null
    description: string | null
    status: $Enums.MissionStatus | null
    priority: number | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MissionCountAggregateOutputType = {
    id: number
    agentId: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    completedAt: number
    result: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MissionAvgAggregateInputType = {
    priority?: true
  }

  export type MissionSumAggregateInputType = {
    priority?: true
  }

  export type MissionMinAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MissionMaxAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MissionCountAggregateInputType = {
    id?: true
    agentId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mission to aggregate.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Missions
    **/
    _count?: true | MissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionMaxAggregateInputType
  }

  export type GetMissionAggregateType<T extends MissionAggregateArgs> = {
        [P in keyof T & keyof AggregateMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMission[P]>
      : GetScalarType<T[P], AggregateMission[P]>
  }




  export type MissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithAggregationInput | MissionOrderByWithAggregationInput[]
    by: MissionScalarFieldEnum[] | MissionScalarFieldEnum
    having?: MissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionCountAggregateInputType | true
    _avg?: MissionAvgAggregateInputType
    _sum?: MissionSumAggregateInputType
    _min?: MissionMinAggregateInputType
    _max?: MissionMaxAggregateInputType
  }

  export type MissionGroupByOutputType = {
    id: string
    agentId: string
    title: string
    description: string
    status: $Enums.MissionStatus
    priority: number
    dueDate: Date | null
    completedAt: Date | null
    result: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  type GetMissionGroupByPayload<T extends MissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionGroupByOutputType[P]>
            : GetScalarType<T[P], MissionGroupByOutputType[P]>
        }
      >
    >


  export type MissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mission"]>



  export type MissionSelectScalar = {
    id?: boolean
    agentId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "title" | "description" | "status" | "priority" | "dueDate" | "completedAt" | "result" | "createdAt" | "updatedAt", ExtArgs["result"]["mission"]>
  export type MissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $MissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mission"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      title: string
      description: string
      status: $Enums.MissionStatus
      priority: number
      dueDate: Date | null
      completedAt: Date | null
      result: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mission"]>
    composites: {}
  }

  type MissionGetPayload<S extends boolean | null | undefined | MissionDefaultArgs> = $Result.GetResult<Prisma.$MissionPayload, S>

  type MissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MissionCountAggregateInputType | true
    }

  export interface MissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mission'], meta: { name: 'Mission' } }
    /**
     * Find zero or one Mission that matches the filter.
     * @param {MissionFindUniqueArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionFindUniqueArgs>(args: SelectSubset<T, MissionFindUniqueArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MissionFindUniqueOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionFindFirstArgs>(args?: SelectSubset<T, MissionFindFirstArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Missions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Missions
     * const missions = await prisma.mission.findMany()
     * 
     * // Get first 10 Missions
     * const missions = await prisma.mission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionWithIdOnly = await prisma.mission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionFindManyArgs>(args?: SelectSubset<T, MissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mission.
     * @param {MissionCreateArgs} args - Arguments to create a Mission.
     * @example
     * // Create one Mission
     * const Mission = await prisma.mission.create({
     *   data: {
     *     // ... data to create a Mission
     *   }
     * })
     * 
     */
    create<T extends MissionCreateArgs>(args: SelectSubset<T, MissionCreateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Missions.
     * @param {MissionCreateManyArgs} args - Arguments to create many Missions.
     * @example
     * // Create many Missions
     * const mission = await prisma.mission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionCreateManyArgs>(args?: SelectSubset<T, MissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mission.
     * @param {MissionDeleteArgs} args - Arguments to delete one Mission.
     * @example
     * // Delete one Mission
     * const Mission = await prisma.mission.delete({
     *   where: {
     *     // ... filter to delete one Mission
     *   }
     * })
     * 
     */
    delete<T extends MissionDeleteArgs>(args: SelectSubset<T, MissionDeleteArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mission.
     * @param {MissionUpdateArgs} args - Arguments to update one Mission.
     * @example
     * // Update one Mission
     * const mission = await prisma.mission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionUpdateArgs>(args: SelectSubset<T, MissionUpdateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Missions.
     * @param {MissionDeleteManyArgs} args - Arguments to filter Missions to delete.
     * @example
     * // Delete a few Missions
     * const { count } = await prisma.mission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionDeleteManyArgs>(args?: SelectSubset<T, MissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Missions
     * const mission = await prisma.mission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionUpdateManyArgs>(args: SelectSubset<T, MissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mission.
     * @param {MissionUpsertArgs} args - Arguments to update or create a Mission.
     * @example
     * // Update or create a Mission
     * const mission = await prisma.mission.upsert({
     *   create: {
     *     // ... data to create a Mission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mission we want to update
     *   }
     * })
     */
    upsert<T extends MissionUpsertArgs>(args: SelectSubset<T, MissionUpsertArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Missions that matches the filter.
     * @param {MissionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mission = await prisma.mission.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MissionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Mission.
     * @param {MissionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mission = await prisma.mission.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MissionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionCountArgs} args - Arguments to filter Missions to count.
     * @example
     * // Count the number of Missions
     * const count = await prisma.mission.count({
     *   where: {
     *     // ... the filter for the Missions we want to count
     *   }
     * })
    **/
    count<T extends MissionCountArgs>(
      args?: Subset<T, MissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionAggregateArgs>(args: Subset<T, MissionAggregateArgs>): Prisma.PrismaPromise<GetMissionAggregateType<T>>

    /**
     * Group by Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionGroupByArgs['orderBy'] }
        : { orderBy?: MissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mission model
   */
  readonly fields: MissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mission model
   */
  interface MissionFieldRefs {
    readonly id: FieldRef<"Mission", 'String'>
    readonly agentId: FieldRef<"Mission", 'String'>
    readonly title: FieldRef<"Mission", 'String'>
    readonly description: FieldRef<"Mission", 'String'>
    readonly status: FieldRef<"Mission", 'MissionStatus'>
    readonly priority: FieldRef<"Mission", 'Int'>
    readonly dueDate: FieldRef<"Mission", 'DateTime'>
    readonly completedAt: FieldRef<"Mission", 'DateTime'>
    readonly result: FieldRef<"Mission", 'Json'>
    readonly createdAt: FieldRef<"Mission", 'DateTime'>
    readonly updatedAt: FieldRef<"Mission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mission findUnique
   */
  export type MissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findUniqueOrThrow
   */
  export type MissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findFirst
   */
  export type MissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findFirstOrThrow
   */
  export type MissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findMany
   */
  export type MissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Missions to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission create
   */
  export type MissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Mission.
     */
    data: XOR<MissionCreateInput, MissionUncheckedCreateInput>
  }

  /**
   * Mission createMany
   */
  export type MissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Missions.
     */
    data: MissionCreateManyInput | MissionCreateManyInput[]
  }

  /**
   * Mission update
   */
  export type MissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Mission.
     */
    data: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
    /**
     * Choose, which Mission to update.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission updateMany
   */
  export type MissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Missions.
     */
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyInput>
    /**
     * Filter which Missions to update
     */
    where?: MissionWhereInput
    /**
     * Limit how many Missions to update.
     */
    limit?: number
  }

  /**
   * Mission upsert
   */
  export type MissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Mission to update in case it exists.
     */
    where: MissionWhereUniqueInput
    /**
     * In case the Mission found by the `where` argument doesn't exist, create a new Mission with this data.
     */
    create: XOR<MissionCreateInput, MissionUncheckedCreateInput>
    /**
     * In case the Mission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
  }

  /**
   * Mission delete
   */
  export type MissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter which Mission to delete.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission deleteMany
   */
  export type MissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Missions to delete
     */
    where?: MissionWhereInput
    /**
     * Limit how many Missions to delete.
     */
    limit?: number
  }

  /**
   * Mission findRaw
   */
  export type MissionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Mission aggregateRaw
   */
  export type MissionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Mission without action
   */
  export type MissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
  }


  /**
   * Model Proxim8User
   */

  export type AggregateProxim8User = {
    _count: Proxim8UserCountAggregateOutputType | null
    _min: Proxim8UserMinAggregateOutputType | null
    _max: Proxim8UserMaxAggregateOutputType | null
  }

  export type Proxim8UserMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    username: string | null
    email: string | null
    bio: string | null
    avatar: string | null
    isPublic: boolean | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Proxim8UserMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    username: string | null
    email: string | null
    bio: string | null
    avatar: string | null
    isPublic: boolean | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Proxim8UserCountAggregateOutputType = {
    id: number
    accountId: number
    username: number
    email: number
    bio: number
    avatar: number
    isPublic: number
    isAdmin: number
    socialLinks: number
    preferences: number
    stats: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Proxim8UserMinAggregateInputType = {
    id?: true
    accountId?: true
    username?: true
    email?: true
    bio?: true
    avatar?: true
    isPublic?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Proxim8UserMaxAggregateInputType = {
    id?: true
    accountId?: true
    username?: true
    email?: true
    bio?: true
    avatar?: true
    isPublic?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Proxim8UserCountAggregateInputType = {
    id?: true
    accountId?: true
    username?: true
    email?: true
    bio?: true
    avatar?: true
    isPublic?: true
    isAdmin?: true
    socialLinks?: true
    preferences?: true
    stats?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Proxim8UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proxim8User to aggregate.
     */
    where?: Proxim8UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxim8Users to fetch.
     */
    orderBy?: Proxim8UserOrderByWithRelationInput | Proxim8UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Proxim8UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxim8Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxim8Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proxim8Users
    **/
    _count?: true | Proxim8UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Proxim8UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Proxim8UserMaxAggregateInputType
  }

  export type GetProxim8UserAggregateType<T extends Proxim8UserAggregateArgs> = {
        [P in keyof T & keyof AggregateProxim8User]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxim8User[P]>
      : GetScalarType<T[P], AggregateProxim8User[P]>
  }




  export type Proxim8UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Proxim8UserWhereInput
    orderBy?: Proxim8UserOrderByWithAggregationInput | Proxim8UserOrderByWithAggregationInput[]
    by: Proxim8UserScalarFieldEnum[] | Proxim8UserScalarFieldEnum
    having?: Proxim8UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Proxim8UserCountAggregateInputType | true
    _min?: Proxim8UserMinAggregateInputType
    _max?: Proxim8UserMaxAggregateInputType
  }

  export type Proxim8UserGroupByOutputType = {
    id: string
    accountId: string
    username: string
    email: string | null
    bio: string | null
    avatar: string | null
    isPublic: boolean
    isAdmin: boolean
    socialLinks: JsonValue | null
    preferences: JsonValue | null
    stats: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: Proxim8UserCountAggregateOutputType | null
    _min: Proxim8UserMinAggregateOutputType | null
    _max: Proxim8UserMaxAggregateOutputType | null
  }

  type GetProxim8UserGroupByPayload<T extends Proxim8UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Proxim8UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Proxim8UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Proxim8UserGroupByOutputType[P]>
            : GetScalarType<T[P], Proxim8UserGroupByOutputType[P]>
        }
      >
    >


  export type Proxim8UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    username?: boolean
    email?: boolean
    bio?: boolean
    avatar?: boolean
    isPublic?: boolean
    isAdmin?: boolean
    socialLinks?: boolean
    preferences?: boolean
    stats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxim8User"]>



  export type Proxim8UserSelectScalar = {
    id?: boolean
    accountId?: boolean
    username?: boolean
    email?: boolean
    bio?: boolean
    avatar?: boolean
    isPublic?: boolean
    isAdmin?: boolean
    socialLinks?: boolean
    preferences?: boolean
    stats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Proxim8UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "username" | "email" | "bio" | "avatar" | "isPublic" | "isAdmin" | "socialLinks" | "preferences" | "stats" | "createdAt" | "updatedAt", ExtArgs["result"]["proxim8User"]>
  export type Proxim8UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $Proxim8UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proxim8User"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      username: string
      email: string | null
      bio: string | null
      avatar: string | null
      isPublic: boolean
      isAdmin: boolean
      socialLinks: Prisma.JsonValue | null
      preferences: Prisma.JsonValue | null
      stats: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proxim8User"]>
    composites: {}
  }

  type Proxim8UserGetPayload<S extends boolean | null | undefined | Proxim8UserDefaultArgs> = $Result.GetResult<Prisma.$Proxim8UserPayload, S>

  type Proxim8UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Proxim8UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Proxim8UserCountAggregateInputType | true
    }

  export interface Proxim8UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proxim8User'], meta: { name: 'Proxim8User' } }
    /**
     * Find zero or one Proxim8User that matches the filter.
     * @param {Proxim8UserFindUniqueArgs} args - Arguments to find a Proxim8User
     * @example
     * // Get one Proxim8User
     * const proxim8User = await prisma.proxim8User.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Proxim8UserFindUniqueArgs>(args: SelectSubset<T, Proxim8UserFindUniqueArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proxim8User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Proxim8UserFindUniqueOrThrowArgs} args - Arguments to find a Proxim8User
     * @example
     * // Get one Proxim8User
     * const proxim8User = await prisma.proxim8User.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Proxim8UserFindUniqueOrThrowArgs>(args: SelectSubset<T, Proxim8UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proxim8User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Proxim8UserFindFirstArgs} args - Arguments to find a Proxim8User
     * @example
     * // Get one Proxim8User
     * const proxim8User = await prisma.proxim8User.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Proxim8UserFindFirstArgs>(args?: SelectSubset<T, Proxim8UserFindFirstArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proxim8User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Proxim8UserFindFirstOrThrowArgs} args - Arguments to find a Proxim8User
     * @example
     * // Get one Proxim8User
     * const proxim8User = await prisma.proxim8User.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Proxim8UserFindFirstOrThrowArgs>(args?: SelectSubset<T, Proxim8UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proxim8Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Proxim8UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proxim8Users
     * const proxim8Users = await prisma.proxim8User.findMany()
     * 
     * // Get first 10 Proxim8Users
     * const proxim8Users = await prisma.proxim8User.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxim8UserWithIdOnly = await prisma.proxim8User.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Proxim8UserFindManyArgs>(args?: SelectSubset<T, Proxim8UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proxim8User.
     * @param {Proxim8UserCreateArgs} args - Arguments to create a Proxim8User.
     * @example
     * // Create one Proxim8User
     * const Proxim8User = await prisma.proxim8User.create({
     *   data: {
     *     // ... data to create a Proxim8User
     *   }
     * })
     * 
     */
    create<T extends Proxim8UserCreateArgs>(args: SelectSubset<T, Proxim8UserCreateArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proxim8Users.
     * @param {Proxim8UserCreateManyArgs} args - Arguments to create many Proxim8Users.
     * @example
     * // Create many Proxim8Users
     * const proxim8User = await prisma.proxim8User.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Proxim8UserCreateManyArgs>(args?: SelectSubset<T, Proxim8UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proxim8User.
     * @param {Proxim8UserDeleteArgs} args - Arguments to delete one Proxim8User.
     * @example
     * // Delete one Proxim8User
     * const Proxim8User = await prisma.proxim8User.delete({
     *   where: {
     *     // ... filter to delete one Proxim8User
     *   }
     * })
     * 
     */
    delete<T extends Proxim8UserDeleteArgs>(args: SelectSubset<T, Proxim8UserDeleteArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proxim8User.
     * @param {Proxim8UserUpdateArgs} args - Arguments to update one Proxim8User.
     * @example
     * // Update one Proxim8User
     * const proxim8User = await prisma.proxim8User.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Proxim8UserUpdateArgs>(args: SelectSubset<T, Proxim8UserUpdateArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proxim8Users.
     * @param {Proxim8UserDeleteManyArgs} args - Arguments to filter Proxim8Users to delete.
     * @example
     * // Delete a few Proxim8Users
     * const { count } = await prisma.proxim8User.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Proxim8UserDeleteManyArgs>(args?: SelectSubset<T, Proxim8UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proxim8Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Proxim8UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proxim8Users
     * const proxim8User = await prisma.proxim8User.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Proxim8UserUpdateManyArgs>(args: SelectSubset<T, Proxim8UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proxim8User.
     * @param {Proxim8UserUpsertArgs} args - Arguments to update or create a Proxim8User.
     * @example
     * // Update or create a Proxim8User
     * const proxim8User = await prisma.proxim8User.upsert({
     *   create: {
     *     // ... data to create a Proxim8User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proxim8User we want to update
     *   }
     * })
     */
    upsert<T extends Proxim8UserUpsertArgs>(args: SelectSubset<T, Proxim8UserUpsertArgs<ExtArgs>>): Prisma__Proxim8UserClient<$Result.GetResult<Prisma.$Proxim8UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proxim8Users that matches the filter.
     * @param {Proxim8UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const proxim8User = await prisma.proxim8User.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: Proxim8UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Proxim8User.
     * @param {Proxim8UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const proxim8User = await prisma.proxim8User.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Proxim8UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Proxim8Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Proxim8UserCountArgs} args - Arguments to filter Proxim8Users to count.
     * @example
     * // Count the number of Proxim8Users
     * const count = await prisma.proxim8User.count({
     *   where: {
     *     // ... the filter for the Proxim8Users we want to count
     *   }
     * })
    **/
    count<T extends Proxim8UserCountArgs>(
      args?: Subset<T, Proxim8UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Proxim8UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proxim8User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Proxim8UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Proxim8UserAggregateArgs>(args: Subset<T, Proxim8UserAggregateArgs>): Prisma.PrismaPromise<GetProxim8UserAggregateType<T>>

    /**
     * Group by Proxim8User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Proxim8UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Proxim8UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Proxim8UserGroupByArgs['orderBy'] }
        : { orderBy?: Proxim8UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Proxim8UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxim8UserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proxim8User model
   */
  readonly fields: Proxim8UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proxim8User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Proxim8UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proxim8User model
   */
  interface Proxim8UserFieldRefs {
    readonly id: FieldRef<"Proxim8User", 'String'>
    readonly accountId: FieldRef<"Proxim8User", 'String'>
    readonly username: FieldRef<"Proxim8User", 'String'>
    readonly email: FieldRef<"Proxim8User", 'String'>
    readonly bio: FieldRef<"Proxim8User", 'String'>
    readonly avatar: FieldRef<"Proxim8User", 'String'>
    readonly isPublic: FieldRef<"Proxim8User", 'Boolean'>
    readonly isAdmin: FieldRef<"Proxim8User", 'Boolean'>
    readonly socialLinks: FieldRef<"Proxim8User", 'Json'>
    readonly preferences: FieldRef<"Proxim8User", 'Json'>
    readonly stats: FieldRef<"Proxim8User", 'Json'>
    readonly createdAt: FieldRef<"Proxim8User", 'DateTime'>
    readonly updatedAt: FieldRef<"Proxim8User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proxim8User findUnique
   */
  export type Proxim8UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * Filter, which Proxim8User to fetch.
     */
    where: Proxim8UserWhereUniqueInput
  }

  /**
   * Proxim8User findUniqueOrThrow
   */
  export type Proxim8UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * Filter, which Proxim8User to fetch.
     */
    where: Proxim8UserWhereUniqueInput
  }

  /**
   * Proxim8User findFirst
   */
  export type Proxim8UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * Filter, which Proxim8User to fetch.
     */
    where?: Proxim8UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxim8Users to fetch.
     */
    orderBy?: Proxim8UserOrderByWithRelationInput | Proxim8UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proxim8Users.
     */
    cursor?: Proxim8UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxim8Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxim8Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proxim8Users.
     */
    distinct?: Proxim8UserScalarFieldEnum | Proxim8UserScalarFieldEnum[]
  }

  /**
   * Proxim8User findFirstOrThrow
   */
  export type Proxim8UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * Filter, which Proxim8User to fetch.
     */
    where?: Proxim8UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxim8Users to fetch.
     */
    orderBy?: Proxim8UserOrderByWithRelationInput | Proxim8UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proxim8Users.
     */
    cursor?: Proxim8UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxim8Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxim8Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proxim8Users.
     */
    distinct?: Proxim8UserScalarFieldEnum | Proxim8UserScalarFieldEnum[]
  }

  /**
   * Proxim8User findMany
   */
  export type Proxim8UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * Filter, which Proxim8Users to fetch.
     */
    where?: Proxim8UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxim8Users to fetch.
     */
    orderBy?: Proxim8UserOrderByWithRelationInput | Proxim8UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proxim8Users.
     */
    cursor?: Proxim8UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxim8Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxim8Users.
     */
    skip?: number
    distinct?: Proxim8UserScalarFieldEnum | Proxim8UserScalarFieldEnum[]
  }

  /**
   * Proxim8User create
   */
  export type Proxim8UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * The data needed to create a Proxim8User.
     */
    data: XOR<Proxim8UserCreateInput, Proxim8UserUncheckedCreateInput>
  }

  /**
   * Proxim8User createMany
   */
  export type Proxim8UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proxim8Users.
     */
    data: Proxim8UserCreateManyInput | Proxim8UserCreateManyInput[]
  }

  /**
   * Proxim8User update
   */
  export type Proxim8UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * The data needed to update a Proxim8User.
     */
    data: XOR<Proxim8UserUpdateInput, Proxim8UserUncheckedUpdateInput>
    /**
     * Choose, which Proxim8User to update.
     */
    where: Proxim8UserWhereUniqueInput
  }

  /**
   * Proxim8User updateMany
   */
  export type Proxim8UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proxim8Users.
     */
    data: XOR<Proxim8UserUpdateManyMutationInput, Proxim8UserUncheckedUpdateManyInput>
    /**
     * Filter which Proxim8Users to update
     */
    where?: Proxim8UserWhereInput
    /**
     * Limit how many Proxim8Users to update.
     */
    limit?: number
  }

  /**
   * Proxim8User upsert
   */
  export type Proxim8UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * The filter to search for the Proxim8User to update in case it exists.
     */
    where: Proxim8UserWhereUniqueInput
    /**
     * In case the Proxim8User found by the `where` argument doesn't exist, create a new Proxim8User with this data.
     */
    create: XOR<Proxim8UserCreateInput, Proxim8UserUncheckedCreateInput>
    /**
     * In case the Proxim8User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Proxim8UserUpdateInput, Proxim8UserUncheckedUpdateInput>
  }

  /**
   * Proxim8User delete
   */
  export type Proxim8UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
    /**
     * Filter which Proxim8User to delete.
     */
    where: Proxim8UserWhereUniqueInput
  }

  /**
   * Proxim8User deleteMany
   */
  export type Proxim8UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proxim8Users to delete
     */
    where?: Proxim8UserWhereInput
    /**
     * Limit how many Proxim8Users to delete.
     */
    limit?: number
  }

  /**
   * Proxim8User findRaw
   */
  export type Proxim8UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Proxim8User aggregateRaw
   */
  export type Proxim8UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Proxim8User without action
   */
  export type Proxim8UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxim8User
     */
    select?: Proxim8UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxim8User
     */
    omit?: Proxim8UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Proxim8UserInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    duration: number | null
    fileSize: number | null
  }

  export type VideoSumAggregateOutputType = {
    duration: number | null
    fileSize: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    nftId: string | null
    jobId: string | null
    status: $Enums.VideoStatus | null
    title: string | null
    description: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    resolution: string | null
    isPublic: boolean | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    nftId: string | null
    jobId: string | null
    status: $Enums.VideoStatus | null
    title: string | null
    description: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    resolution: string | null
    isPublic: boolean | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    accountId: number
    nftId: number
    jobId: number
    status: number
    title: number
    description: number
    videoUrl: number
    thumbnailUrl: number
    duration: number
    fileSize: number
    resolution: number
    isPublic: number
    metadata: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    duration?: true
    fileSize?: true
  }

  export type VideoSumAggregateInputType = {
    duration?: true
    fileSize?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    accountId?: true
    nftId?: true
    jobId?: true
    status?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    resolution?: true
    isPublic?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    accountId?: true
    nftId?: true
    jobId?: true
    status?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    resolution?: true
    isPublic?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    accountId?: true
    nftId?: true
    jobId?: true
    status?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    resolution?: true
    isPublic?: true
    metadata?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: string
    accountId: string
    nftId: string
    jobId: string
    status: $Enums.VideoStatus
    title: string | null
    description: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: number | null
    resolution: string | null
    isPublic: boolean
    metadata: JsonValue | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    nftId?: boolean
    jobId?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    resolution?: boolean
    isPublic?: boolean
    metadata?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>



  export type VideoSelectScalar = {
    id?: boolean
    accountId?: boolean
    nftId?: boolean
    jobId?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    resolution?: boolean
    isPublic?: boolean
    metadata?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "nftId" | "jobId" | "status" | "title" | "description" | "videoUrl" | "thumbnailUrl" | "duration" | "fileSize" | "resolution" | "isPublic" | "metadata" | "errorMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["video"]>
  export type VideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      nftId: string
      jobId: string
      status: $Enums.VideoStatus
      title: string | null
      description: string | null
      videoUrl: string | null
      thumbnailUrl: string | null
      duration: number | null
      fileSize: number | null
      resolution: string | null
      isPublic: boolean
      metadata: Prisma.JsonValue | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * @param {VideoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const video = await prisma.video.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VideoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Video.
     * @param {VideoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const video = await prisma.video.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VideoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'String'>
    readonly accountId: FieldRef<"Video", 'String'>
    readonly nftId: FieldRef<"Video", 'String'>
    readonly jobId: FieldRef<"Video", 'String'>
    readonly status: FieldRef<"Video", 'VideoStatus'>
    readonly title: FieldRef<"Video", 'String'>
    readonly description: FieldRef<"Video", 'String'>
    readonly videoUrl: FieldRef<"Video", 'String'>
    readonly thumbnailUrl: FieldRef<"Video", 'String'>
    readonly duration: FieldRef<"Video", 'Int'>
    readonly fileSize: FieldRef<"Video", 'Int'>
    readonly resolution: FieldRef<"Video", 'String'>
    readonly isPublic: FieldRef<"Video", 'Boolean'>
    readonly metadata: FieldRef<"Video", 'Json'>
    readonly errorMessage: FieldRef<"Video", 'String'>
    readonly createdAt: FieldRef<"Video", 'DateTime'>
    readonly updatedAt: FieldRef<"Video", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to delete.
     */
    limit?: number
  }

  /**
   * Video findRaw
   */
  export type VideoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Video aggregateRaw
   */
  export type VideoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    accountId: number
    type: number
    title: number
    message: number
    data: number
    isRead: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    accountId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    accountId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    accountId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    accountId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data: JsonValue | null
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    accountId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "type" | "title" | "message" | "data" | "isRead" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      type: $Enums.NotificationType
      title: string
      message: string
      data: Prisma.JsonValue | null
      isRead: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly accountId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NFTOwnership
   */

  export type AggregateNFTOwnership = {
    _count: NFTOwnershipCountAggregateOutputType | null
    _min: NFTOwnershipMinAggregateOutputType | null
    _max: NFTOwnershipMaxAggregateOutputType | null
  }

  export type NFTOwnershipMinAggregateOutputType = {
    id: string | null
    nftId: string | null
    accountId: string | null
    walletAddress: string | null
    contractAddress: string | null
    tokenId: string | null
    blockchain: string | null
    verified: boolean | null
    lastVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NFTOwnershipMaxAggregateOutputType = {
    id: string | null
    nftId: string | null
    accountId: string | null
    walletAddress: string | null
    contractAddress: string | null
    tokenId: string | null
    blockchain: string | null
    verified: boolean | null
    lastVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NFTOwnershipCountAggregateOutputType = {
    id: number
    nftId: number
    accountId: number
    walletAddress: number
    contractAddress: number
    tokenId: number
    blockchain: number
    verified: number
    lastVerified: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NFTOwnershipMinAggregateInputType = {
    id?: true
    nftId?: true
    accountId?: true
    walletAddress?: true
    contractAddress?: true
    tokenId?: true
    blockchain?: true
    verified?: true
    lastVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NFTOwnershipMaxAggregateInputType = {
    id?: true
    nftId?: true
    accountId?: true
    walletAddress?: true
    contractAddress?: true
    tokenId?: true
    blockchain?: true
    verified?: true
    lastVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NFTOwnershipCountAggregateInputType = {
    id?: true
    nftId?: true
    accountId?: true
    walletAddress?: true
    contractAddress?: true
    tokenId?: true
    blockchain?: true
    verified?: true
    lastVerified?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NFTOwnershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTOwnership to aggregate.
     */
    where?: NFTOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTOwnerships to fetch.
     */
    orderBy?: NFTOwnershipOrderByWithRelationInput | NFTOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NFTOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NFTOwnerships
    **/
    _count?: true | NFTOwnershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NFTOwnershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NFTOwnershipMaxAggregateInputType
  }

  export type GetNFTOwnershipAggregateType<T extends NFTOwnershipAggregateArgs> = {
        [P in keyof T & keyof AggregateNFTOwnership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNFTOwnership[P]>
      : GetScalarType<T[P], AggregateNFTOwnership[P]>
  }




  export type NFTOwnershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTOwnershipWhereInput
    orderBy?: NFTOwnershipOrderByWithAggregationInput | NFTOwnershipOrderByWithAggregationInput[]
    by: NFTOwnershipScalarFieldEnum[] | NFTOwnershipScalarFieldEnum
    having?: NFTOwnershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NFTOwnershipCountAggregateInputType | true
    _min?: NFTOwnershipMinAggregateInputType
    _max?: NFTOwnershipMaxAggregateInputType
  }

  export type NFTOwnershipGroupByOutputType = {
    id: string
    nftId: string
    accountId: string
    walletAddress: string
    contractAddress: string
    tokenId: string
    blockchain: string
    verified: boolean
    lastVerified: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NFTOwnershipCountAggregateOutputType | null
    _min: NFTOwnershipMinAggregateOutputType | null
    _max: NFTOwnershipMaxAggregateOutputType | null
  }

  type GetNFTOwnershipGroupByPayload<T extends NFTOwnershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NFTOwnershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NFTOwnershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NFTOwnershipGroupByOutputType[P]>
            : GetScalarType<T[P], NFTOwnershipGroupByOutputType[P]>
        }
      >
    >


  export type NFTOwnershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    accountId?: boolean
    walletAddress?: boolean
    contractAddress?: boolean
    tokenId?: boolean
    blockchain?: boolean
    verified?: boolean
    lastVerified?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nFTOwnership"]>



  export type NFTOwnershipSelectScalar = {
    id?: boolean
    nftId?: boolean
    accountId?: boolean
    walletAddress?: boolean
    contractAddress?: boolean
    tokenId?: boolean
    blockchain?: boolean
    verified?: boolean
    lastVerified?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NFTOwnershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nftId" | "accountId" | "walletAddress" | "contractAddress" | "tokenId" | "blockchain" | "verified" | "lastVerified" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["nFTOwnership"]>
  export type NFTOwnershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $NFTOwnershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NFTOwnership"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nftId: string
      accountId: string
      walletAddress: string
      contractAddress: string
      tokenId: string
      blockchain: string
      verified: boolean
      lastVerified: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nFTOwnership"]>
    composites: {}
  }

  type NFTOwnershipGetPayload<S extends boolean | null | undefined | NFTOwnershipDefaultArgs> = $Result.GetResult<Prisma.$NFTOwnershipPayload, S>

  type NFTOwnershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NFTOwnershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NFTOwnershipCountAggregateInputType | true
    }

  export interface NFTOwnershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NFTOwnership'], meta: { name: 'NFTOwnership' } }
    /**
     * Find zero or one NFTOwnership that matches the filter.
     * @param {NFTOwnershipFindUniqueArgs} args - Arguments to find a NFTOwnership
     * @example
     * // Get one NFTOwnership
     * const nFTOwnership = await prisma.nFTOwnership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NFTOwnershipFindUniqueArgs>(args: SelectSubset<T, NFTOwnershipFindUniqueArgs<ExtArgs>>): Prisma__NFTOwnershipClient<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NFTOwnership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NFTOwnershipFindUniqueOrThrowArgs} args - Arguments to find a NFTOwnership
     * @example
     * // Get one NFTOwnership
     * const nFTOwnership = await prisma.nFTOwnership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NFTOwnershipFindUniqueOrThrowArgs>(args: SelectSubset<T, NFTOwnershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NFTOwnershipClient<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFTOwnership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTOwnershipFindFirstArgs} args - Arguments to find a NFTOwnership
     * @example
     * // Get one NFTOwnership
     * const nFTOwnership = await prisma.nFTOwnership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NFTOwnershipFindFirstArgs>(args?: SelectSubset<T, NFTOwnershipFindFirstArgs<ExtArgs>>): Prisma__NFTOwnershipClient<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFTOwnership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTOwnershipFindFirstOrThrowArgs} args - Arguments to find a NFTOwnership
     * @example
     * // Get one NFTOwnership
     * const nFTOwnership = await prisma.nFTOwnership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NFTOwnershipFindFirstOrThrowArgs>(args?: SelectSubset<T, NFTOwnershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__NFTOwnershipClient<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NFTOwnerships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTOwnershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NFTOwnerships
     * const nFTOwnerships = await prisma.nFTOwnership.findMany()
     * 
     * // Get first 10 NFTOwnerships
     * const nFTOwnerships = await prisma.nFTOwnership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nFTOwnershipWithIdOnly = await prisma.nFTOwnership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NFTOwnershipFindManyArgs>(args?: SelectSubset<T, NFTOwnershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NFTOwnership.
     * @param {NFTOwnershipCreateArgs} args - Arguments to create a NFTOwnership.
     * @example
     * // Create one NFTOwnership
     * const NFTOwnership = await prisma.nFTOwnership.create({
     *   data: {
     *     // ... data to create a NFTOwnership
     *   }
     * })
     * 
     */
    create<T extends NFTOwnershipCreateArgs>(args: SelectSubset<T, NFTOwnershipCreateArgs<ExtArgs>>): Prisma__NFTOwnershipClient<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NFTOwnerships.
     * @param {NFTOwnershipCreateManyArgs} args - Arguments to create many NFTOwnerships.
     * @example
     * // Create many NFTOwnerships
     * const nFTOwnership = await prisma.nFTOwnership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NFTOwnershipCreateManyArgs>(args?: SelectSubset<T, NFTOwnershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NFTOwnership.
     * @param {NFTOwnershipDeleteArgs} args - Arguments to delete one NFTOwnership.
     * @example
     * // Delete one NFTOwnership
     * const NFTOwnership = await prisma.nFTOwnership.delete({
     *   where: {
     *     // ... filter to delete one NFTOwnership
     *   }
     * })
     * 
     */
    delete<T extends NFTOwnershipDeleteArgs>(args: SelectSubset<T, NFTOwnershipDeleteArgs<ExtArgs>>): Prisma__NFTOwnershipClient<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NFTOwnership.
     * @param {NFTOwnershipUpdateArgs} args - Arguments to update one NFTOwnership.
     * @example
     * // Update one NFTOwnership
     * const nFTOwnership = await prisma.nFTOwnership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NFTOwnershipUpdateArgs>(args: SelectSubset<T, NFTOwnershipUpdateArgs<ExtArgs>>): Prisma__NFTOwnershipClient<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NFTOwnerships.
     * @param {NFTOwnershipDeleteManyArgs} args - Arguments to filter NFTOwnerships to delete.
     * @example
     * // Delete a few NFTOwnerships
     * const { count } = await prisma.nFTOwnership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NFTOwnershipDeleteManyArgs>(args?: SelectSubset<T, NFTOwnershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTOwnerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTOwnershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NFTOwnerships
     * const nFTOwnership = await prisma.nFTOwnership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NFTOwnershipUpdateManyArgs>(args: SelectSubset<T, NFTOwnershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NFTOwnership.
     * @param {NFTOwnershipUpsertArgs} args - Arguments to update or create a NFTOwnership.
     * @example
     * // Update or create a NFTOwnership
     * const nFTOwnership = await prisma.nFTOwnership.upsert({
     *   create: {
     *     // ... data to create a NFTOwnership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NFTOwnership we want to update
     *   }
     * })
     */
    upsert<T extends NFTOwnershipUpsertArgs>(args: SelectSubset<T, NFTOwnershipUpsertArgs<ExtArgs>>): Prisma__NFTOwnershipClient<$Result.GetResult<Prisma.$NFTOwnershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NFTOwnerships that matches the filter.
     * @param {NFTOwnershipFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const nFTOwnership = await prisma.nFTOwnership.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NFTOwnershipFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a NFTOwnership.
     * @param {NFTOwnershipAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const nFTOwnership = await prisma.nFTOwnership.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NFTOwnershipAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of NFTOwnerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTOwnershipCountArgs} args - Arguments to filter NFTOwnerships to count.
     * @example
     * // Count the number of NFTOwnerships
     * const count = await prisma.nFTOwnership.count({
     *   where: {
     *     // ... the filter for the NFTOwnerships we want to count
     *   }
     * })
    **/
    count<T extends NFTOwnershipCountArgs>(
      args?: Subset<T, NFTOwnershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NFTOwnershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NFTOwnership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTOwnershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NFTOwnershipAggregateArgs>(args: Subset<T, NFTOwnershipAggregateArgs>): Prisma.PrismaPromise<GetNFTOwnershipAggregateType<T>>

    /**
     * Group by NFTOwnership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTOwnershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NFTOwnershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NFTOwnershipGroupByArgs['orderBy'] }
        : { orderBy?: NFTOwnershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NFTOwnershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNFTOwnershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NFTOwnership model
   */
  readonly fields: NFTOwnershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NFTOwnership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NFTOwnershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NFTOwnership model
   */
  interface NFTOwnershipFieldRefs {
    readonly id: FieldRef<"NFTOwnership", 'String'>
    readonly nftId: FieldRef<"NFTOwnership", 'String'>
    readonly accountId: FieldRef<"NFTOwnership", 'String'>
    readonly walletAddress: FieldRef<"NFTOwnership", 'String'>
    readonly contractAddress: FieldRef<"NFTOwnership", 'String'>
    readonly tokenId: FieldRef<"NFTOwnership", 'String'>
    readonly blockchain: FieldRef<"NFTOwnership", 'String'>
    readonly verified: FieldRef<"NFTOwnership", 'Boolean'>
    readonly lastVerified: FieldRef<"NFTOwnership", 'DateTime'>
    readonly metadata: FieldRef<"NFTOwnership", 'Json'>
    readonly createdAt: FieldRef<"NFTOwnership", 'DateTime'>
    readonly updatedAt: FieldRef<"NFTOwnership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NFTOwnership findUnique
   */
  export type NFTOwnershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which NFTOwnership to fetch.
     */
    where: NFTOwnershipWhereUniqueInput
  }

  /**
   * NFTOwnership findUniqueOrThrow
   */
  export type NFTOwnershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which NFTOwnership to fetch.
     */
    where: NFTOwnershipWhereUniqueInput
  }

  /**
   * NFTOwnership findFirst
   */
  export type NFTOwnershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which NFTOwnership to fetch.
     */
    where?: NFTOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTOwnerships to fetch.
     */
    orderBy?: NFTOwnershipOrderByWithRelationInput | NFTOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTOwnerships.
     */
    cursor?: NFTOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTOwnerships.
     */
    distinct?: NFTOwnershipScalarFieldEnum | NFTOwnershipScalarFieldEnum[]
  }

  /**
   * NFTOwnership findFirstOrThrow
   */
  export type NFTOwnershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which NFTOwnership to fetch.
     */
    where?: NFTOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTOwnerships to fetch.
     */
    orderBy?: NFTOwnershipOrderByWithRelationInput | NFTOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTOwnerships.
     */
    cursor?: NFTOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTOwnerships.
     */
    distinct?: NFTOwnershipScalarFieldEnum | NFTOwnershipScalarFieldEnum[]
  }

  /**
   * NFTOwnership findMany
   */
  export type NFTOwnershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which NFTOwnerships to fetch.
     */
    where?: NFTOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTOwnerships to fetch.
     */
    orderBy?: NFTOwnershipOrderByWithRelationInput | NFTOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NFTOwnerships.
     */
    cursor?: NFTOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTOwnerships.
     */
    skip?: number
    distinct?: NFTOwnershipScalarFieldEnum | NFTOwnershipScalarFieldEnum[]
  }

  /**
   * NFTOwnership create
   */
  export type NFTOwnershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * The data needed to create a NFTOwnership.
     */
    data: XOR<NFTOwnershipCreateInput, NFTOwnershipUncheckedCreateInput>
  }

  /**
   * NFTOwnership createMany
   */
  export type NFTOwnershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NFTOwnerships.
     */
    data: NFTOwnershipCreateManyInput | NFTOwnershipCreateManyInput[]
  }

  /**
   * NFTOwnership update
   */
  export type NFTOwnershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * The data needed to update a NFTOwnership.
     */
    data: XOR<NFTOwnershipUpdateInput, NFTOwnershipUncheckedUpdateInput>
    /**
     * Choose, which NFTOwnership to update.
     */
    where: NFTOwnershipWhereUniqueInput
  }

  /**
   * NFTOwnership updateMany
   */
  export type NFTOwnershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NFTOwnerships.
     */
    data: XOR<NFTOwnershipUpdateManyMutationInput, NFTOwnershipUncheckedUpdateManyInput>
    /**
     * Filter which NFTOwnerships to update
     */
    where?: NFTOwnershipWhereInput
    /**
     * Limit how many NFTOwnerships to update.
     */
    limit?: number
  }

  /**
   * NFTOwnership upsert
   */
  export type NFTOwnershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * The filter to search for the NFTOwnership to update in case it exists.
     */
    where: NFTOwnershipWhereUniqueInput
    /**
     * In case the NFTOwnership found by the `where` argument doesn't exist, create a new NFTOwnership with this data.
     */
    create: XOR<NFTOwnershipCreateInput, NFTOwnershipUncheckedCreateInput>
    /**
     * In case the NFTOwnership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NFTOwnershipUpdateInput, NFTOwnershipUncheckedUpdateInput>
  }

  /**
   * NFTOwnership delete
   */
  export type NFTOwnershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
    /**
     * Filter which NFTOwnership to delete.
     */
    where: NFTOwnershipWhereUniqueInput
  }

  /**
   * NFTOwnership deleteMany
   */
  export type NFTOwnershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTOwnerships to delete
     */
    where?: NFTOwnershipWhereInput
    /**
     * Limit how many NFTOwnerships to delete.
     */
    limit?: number
  }

  /**
   * NFTOwnership findRaw
   */
  export type NFTOwnershipFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * NFTOwnership aggregateRaw
   */
  export type NFTOwnershipAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * NFTOwnership without action
   */
  export type NFTOwnershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTOwnership
     */
    select?: NFTOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTOwnership
     */
    omit?: NFTOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTOwnershipInclude<ExtArgs> | null
  }


  /**
   * Model Lore
   */

  export type AggregateLore = {
    _count: LoreCountAggregateOutputType | null
    _min: LoreMinAggregateOutputType | null
    _max: LoreMaxAggregateOutputType | null
  }

  export type LoreMinAggregateOutputType = {
    id: string | null
    nftId: string | null
    title: string | null
    content: string | null
    background: string | null
    claimed: boolean | null
    claimedBy: string | null
    claimedAt: Date | null
    category: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoreMaxAggregateOutputType = {
    id: string | null
    nftId: string | null
    title: string | null
    content: string | null
    background: string | null
    claimed: boolean | null
    claimedBy: string | null
    claimedAt: Date | null
    category: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoreCountAggregateOutputType = {
    id: number
    nftId: number
    title: number
    content: number
    background: number
    traits: number
    claimed: number
    claimedBy: number
    claimedAt: number
    category: number
    tags: number
    isPublic: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoreMinAggregateInputType = {
    id?: true
    nftId?: true
    title?: true
    content?: true
    background?: true
    claimed?: true
    claimedBy?: true
    claimedAt?: true
    category?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoreMaxAggregateInputType = {
    id?: true
    nftId?: true
    title?: true
    content?: true
    background?: true
    claimed?: true
    claimedBy?: true
    claimedAt?: true
    category?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoreCountAggregateInputType = {
    id?: true
    nftId?: true
    title?: true
    content?: true
    background?: true
    traits?: true
    claimed?: true
    claimedBy?: true
    claimedAt?: true
    category?: true
    tags?: true
    isPublic?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lore to aggregate.
     */
    where?: LoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lores to fetch.
     */
    orderBy?: LoreOrderByWithRelationInput | LoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lores
    **/
    _count?: true | LoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoreMaxAggregateInputType
  }

  export type GetLoreAggregateType<T extends LoreAggregateArgs> = {
        [P in keyof T & keyof AggregateLore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLore[P]>
      : GetScalarType<T[P], AggregateLore[P]>
  }




  export type LoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoreWhereInput
    orderBy?: LoreOrderByWithAggregationInput | LoreOrderByWithAggregationInput[]
    by: LoreScalarFieldEnum[] | LoreScalarFieldEnum
    having?: LoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoreCountAggregateInputType | true
    _min?: LoreMinAggregateInputType
    _max?: LoreMaxAggregateInputType
  }

  export type LoreGroupByOutputType = {
    id: string
    nftId: string
    title: string
    content: string
    background: string
    traits: JsonValue | null
    claimed: boolean
    claimedBy: string | null
    claimedAt: Date | null
    category: string | null
    tags: string[]
    isPublic: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LoreCountAggregateOutputType | null
    _min: LoreMinAggregateOutputType | null
    _max: LoreMaxAggregateOutputType | null
  }

  type GetLoreGroupByPayload<T extends LoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoreGroupByOutputType[P]>
            : GetScalarType<T[P], LoreGroupByOutputType[P]>
        }
      >
    >


  export type LoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    title?: boolean
    content?: boolean
    background?: boolean
    traits?: boolean
    claimed?: boolean
    claimedBy?: boolean
    claimedAt?: boolean
    category?: boolean
    tags?: boolean
    isPublic?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lore"]>



  export type LoreSelectScalar = {
    id?: boolean
    nftId?: boolean
    title?: boolean
    content?: boolean
    background?: boolean
    traits?: boolean
    claimed?: boolean
    claimedBy?: boolean
    claimedAt?: boolean
    category?: boolean
    tags?: boolean
    isPublic?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nftId" | "title" | "content" | "background" | "traits" | "claimed" | "claimedBy" | "claimedAt" | "category" | "tags" | "isPublic" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["lore"]>

  export type $LorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lore"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nftId: string
      title: string
      content: string
      background: string
      traits: Prisma.JsonValue | null
      claimed: boolean
      claimedBy: string | null
      claimedAt: Date | null
      category: string | null
      tags: string[]
      isPublic: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lore"]>
    composites: {}
  }

  type LoreGetPayload<S extends boolean | null | undefined | LoreDefaultArgs> = $Result.GetResult<Prisma.$LorePayload, S>

  type LoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoreCountAggregateInputType | true
    }

  export interface LoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lore'], meta: { name: 'Lore' } }
    /**
     * Find zero or one Lore that matches the filter.
     * @param {LoreFindUniqueArgs} args - Arguments to find a Lore
     * @example
     * // Get one Lore
     * const lore = await prisma.lore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoreFindUniqueArgs>(args: SelectSubset<T, LoreFindUniqueArgs<ExtArgs>>): Prisma__LoreClient<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoreFindUniqueOrThrowArgs} args - Arguments to find a Lore
     * @example
     * // Get one Lore
     * const lore = await prisma.lore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoreFindUniqueOrThrowArgs>(args: SelectSubset<T, LoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoreClient<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoreFindFirstArgs} args - Arguments to find a Lore
     * @example
     * // Get one Lore
     * const lore = await prisma.lore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoreFindFirstArgs>(args?: SelectSubset<T, LoreFindFirstArgs<ExtArgs>>): Prisma__LoreClient<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoreFindFirstOrThrowArgs} args - Arguments to find a Lore
     * @example
     * // Get one Lore
     * const lore = await prisma.lore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoreFindFirstOrThrowArgs>(args?: SelectSubset<T, LoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoreClient<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lores
     * const lores = await prisma.lore.findMany()
     * 
     * // Get first 10 Lores
     * const lores = await prisma.lore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loreWithIdOnly = await prisma.lore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoreFindManyArgs>(args?: SelectSubset<T, LoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lore.
     * @param {LoreCreateArgs} args - Arguments to create a Lore.
     * @example
     * // Create one Lore
     * const Lore = await prisma.lore.create({
     *   data: {
     *     // ... data to create a Lore
     *   }
     * })
     * 
     */
    create<T extends LoreCreateArgs>(args: SelectSubset<T, LoreCreateArgs<ExtArgs>>): Prisma__LoreClient<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lores.
     * @param {LoreCreateManyArgs} args - Arguments to create many Lores.
     * @example
     * // Create many Lores
     * const lore = await prisma.lore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoreCreateManyArgs>(args?: SelectSubset<T, LoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lore.
     * @param {LoreDeleteArgs} args - Arguments to delete one Lore.
     * @example
     * // Delete one Lore
     * const Lore = await prisma.lore.delete({
     *   where: {
     *     // ... filter to delete one Lore
     *   }
     * })
     * 
     */
    delete<T extends LoreDeleteArgs>(args: SelectSubset<T, LoreDeleteArgs<ExtArgs>>): Prisma__LoreClient<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lore.
     * @param {LoreUpdateArgs} args - Arguments to update one Lore.
     * @example
     * // Update one Lore
     * const lore = await prisma.lore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoreUpdateArgs>(args: SelectSubset<T, LoreUpdateArgs<ExtArgs>>): Prisma__LoreClient<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lores.
     * @param {LoreDeleteManyArgs} args - Arguments to filter Lores to delete.
     * @example
     * // Delete a few Lores
     * const { count } = await prisma.lore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoreDeleteManyArgs>(args?: SelectSubset<T, LoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lores
     * const lore = await prisma.lore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoreUpdateManyArgs>(args: SelectSubset<T, LoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lore.
     * @param {LoreUpsertArgs} args - Arguments to update or create a Lore.
     * @example
     * // Update or create a Lore
     * const lore = await prisma.lore.upsert({
     *   create: {
     *     // ... data to create a Lore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lore we want to update
     *   }
     * })
     */
    upsert<T extends LoreUpsertArgs>(args: SelectSubset<T, LoreUpsertArgs<ExtArgs>>): Prisma__LoreClient<$Result.GetResult<Prisma.$LorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lores that matches the filter.
     * @param {LoreFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const lore = await prisma.lore.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LoreFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Lore.
     * @param {LoreAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const lore = await prisma.lore.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LoreAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Lores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoreCountArgs} args - Arguments to filter Lores to count.
     * @example
     * // Count the number of Lores
     * const count = await prisma.lore.count({
     *   where: {
     *     // ... the filter for the Lores we want to count
     *   }
     * })
    **/
    count<T extends LoreCountArgs>(
      args?: Subset<T, LoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoreAggregateArgs>(args: Subset<T, LoreAggregateArgs>): Prisma.PrismaPromise<GetLoreAggregateType<T>>

    /**
     * Group by Lore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoreGroupByArgs['orderBy'] }
        : { orderBy?: LoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lore model
   */
  readonly fields: LoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lore model
   */
  interface LoreFieldRefs {
    readonly id: FieldRef<"Lore", 'String'>
    readonly nftId: FieldRef<"Lore", 'String'>
    readonly title: FieldRef<"Lore", 'String'>
    readonly content: FieldRef<"Lore", 'String'>
    readonly background: FieldRef<"Lore", 'String'>
    readonly traits: FieldRef<"Lore", 'Json'>
    readonly claimed: FieldRef<"Lore", 'Boolean'>
    readonly claimedBy: FieldRef<"Lore", 'String'>
    readonly claimedAt: FieldRef<"Lore", 'DateTime'>
    readonly category: FieldRef<"Lore", 'String'>
    readonly tags: FieldRef<"Lore", 'String[]'>
    readonly isPublic: FieldRef<"Lore", 'Boolean'>
    readonly metadata: FieldRef<"Lore", 'Json'>
    readonly createdAt: FieldRef<"Lore", 'DateTime'>
    readonly updatedAt: FieldRef<"Lore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lore findUnique
   */
  export type LoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * Filter, which Lore to fetch.
     */
    where: LoreWhereUniqueInput
  }

  /**
   * Lore findUniqueOrThrow
   */
  export type LoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * Filter, which Lore to fetch.
     */
    where: LoreWhereUniqueInput
  }

  /**
   * Lore findFirst
   */
  export type LoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * Filter, which Lore to fetch.
     */
    where?: LoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lores to fetch.
     */
    orderBy?: LoreOrderByWithRelationInput | LoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lores.
     */
    cursor?: LoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lores.
     */
    distinct?: LoreScalarFieldEnum | LoreScalarFieldEnum[]
  }

  /**
   * Lore findFirstOrThrow
   */
  export type LoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * Filter, which Lore to fetch.
     */
    where?: LoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lores to fetch.
     */
    orderBy?: LoreOrderByWithRelationInput | LoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lores.
     */
    cursor?: LoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lores.
     */
    distinct?: LoreScalarFieldEnum | LoreScalarFieldEnum[]
  }

  /**
   * Lore findMany
   */
  export type LoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * Filter, which Lores to fetch.
     */
    where?: LoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lores to fetch.
     */
    orderBy?: LoreOrderByWithRelationInput | LoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lores.
     */
    cursor?: LoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lores.
     */
    skip?: number
    distinct?: LoreScalarFieldEnum | LoreScalarFieldEnum[]
  }

  /**
   * Lore create
   */
  export type LoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * The data needed to create a Lore.
     */
    data: XOR<LoreCreateInput, LoreUncheckedCreateInput>
  }

  /**
   * Lore createMany
   */
  export type LoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lores.
     */
    data: LoreCreateManyInput | LoreCreateManyInput[]
  }

  /**
   * Lore update
   */
  export type LoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * The data needed to update a Lore.
     */
    data: XOR<LoreUpdateInput, LoreUncheckedUpdateInput>
    /**
     * Choose, which Lore to update.
     */
    where: LoreWhereUniqueInput
  }

  /**
   * Lore updateMany
   */
  export type LoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lores.
     */
    data: XOR<LoreUpdateManyMutationInput, LoreUncheckedUpdateManyInput>
    /**
     * Filter which Lores to update
     */
    where?: LoreWhereInput
    /**
     * Limit how many Lores to update.
     */
    limit?: number
  }

  /**
   * Lore upsert
   */
  export type LoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * The filter to search for the Lore to update in case it exists.
     */
    where: LoreWhereUniqueInput
    /**
     * In case the Lore found by the `where` argument doesn't exist, create a new Lore with this data.
     */
    create: XOR<LoreCreateInput, LoreUncheckedCreateInput>
    /**
     * In case the Lore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoreUpdateInput, LoreUncheckedUpdateInput>
  }

  /**
   * Lore delete
   */
  export type LoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
    /**
     * Filter which Lore to delete.
     */
    where: LoreWhereUniqueInput
  }

  /**
   * Lore deleteMany
   */
  export type LoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lores to delete
     */
    where?: LoreWhereInput
    /**
     * Limit how many Lores to delete.
     */
    limit?: number
  }

  /**
   * Lore findRaw
   */
  export type LoreFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Lore aggregateRaw
   */
  export type LoreAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Lore without action
   */
  export type LoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lore
     */
    select?: LoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lore
     */
    omit?: LoreOmit<ExtArgs> | null
  }


  /**
   * Model Pipeline
   */

  export type AggregatePipeline = {
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  export type PipelineMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.PipelineType | null
    status: $Enums.PipelineStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.PipelineType | null
    status: $Enums.PipelineStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    status: number
    config: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PipelineMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    config?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PipelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipeline to aggregate.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pipelines
    **/
    _count?: true | PipelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineMaxAggregateInputType
  }

  export type GetPipelineAggregateType<T extends PipelineAggregateArgs> = {
        [P in keyof T & keyof AggregatePipeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipeline[P]>
      : GetScalarType<T[P], AggregatePipeline[P]>
  }




  export type PipelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithAggregationInput | PipelineOrderByWithAggregationInput[]
    by: PipelineScalarFieldEnum[] | PipelineScalarFieldEnum
    having?: PipelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineCountAggregateInputType | true
    _min?: PipelineMinAggregateInputType
    _max?: PipelineMaxAggregateInputType
  }

  export type PipelineGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.PipelineType
    status: $Enums.PipelineStatus
    config: JsonValue
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  type GetPipelineGroupByPayload<T extends PipelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineGroupByOutputType[P]>
        }
      >
    >


  export type PipelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    config?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pipeline"]>



  export type PipelineSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    config?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PipelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "status" | "config" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["pipeline"]>

  export type $PipelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pipeline"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.PipelineType
      status: $Enums.PipelineStatus
      config: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pipeline"]>
    composites: {}
  }

  type PipelineGetPayload<S extends boolean | null | undefined | PipelineDefaultArgs> = $Result.GetResult<Prisma.$PipelinePayload, S>

  type PipelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PipelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PipelineCountAggregateInputType | true
    }

  export interface PipelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pipeline'], meta: { name: 'Pipeline' } }
    /**
     * Find zero or one Pipeline that matches the filter.
     * @param {PipelineFindUniqueArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineFindUniqueArgs>(args: SelectSubset<T, PipelineFindUniqueArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pipeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PipelineFindUniqueOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineFindFirstArgs>(args?: SelectSubset<T, PipelineFindFirstArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pipelines
     * const pipelines = await prisma.pipeline.findMany()
     * 
     * // Get first 10 Pipelines
     * const pipelines = await prisma.pipeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineFindManyArgs>(args?: SelectSubset<T, PipelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pipeline.
     * @param {PipelineCreateArgs} args - Arguments to create a Pipeline.
     * @example
     * // Create one Pipeline
     * const Pipeline = await prisma.pipeline.create({
     *   data: {
     *     // ... data to create a Pipeline
     *   }
     * })
     * 
     */
    create<T extends PipelineCreateArgs>(args: SelectSubset<T, PipelineCreateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pipelines.
     * @param {PipelineCreateManyArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineCreateManyArgs>(args?: SelectSubset<T, PipelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pipeline.
     * @param {PipelineDeleteArgs} args - Arguments to delete one Pipeline.
     * @example
     * // Delete one Pipeline
     * const Pipeline = await prisma.pipeline.delete({
     *   where: {
     *     // ... filter to delete one Pipeline
     *   }
     * })
     * 
     */
    delete<T extends PipelineDeleteArgs>(args: SelectSubset<T, PipelineDeleteArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pipeline.
     * @param {PipelineUpdateArgs} args - Arguments to update one Pipeline.
     * @example
     * // Update one Pipeline
     * const pipeline = await prisma.pipeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineUpdateArgs>(args: SelectSubset<T, PipelineUpdateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pipelines.
     * @param {PipelineDeleteManyArgs} args - Arguments to filter Pipelines to delete.
     * @example
     * // Delete a few Pipelines
     * const { count } = await prisma.pipeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineDeleteManyArgs>(args?: SelectSubset<T, PipelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineUpdateManyArgs>(args: SelectSubset<T, PipelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pipeline.
     * @param {PipelineUpsertArgs} args - Arguments to update or create a Pipeline.
     * @example
     * // Update or create a Pipeline
     * const pipeline = await prisma.pipeline.upsert({
     *   create: {
     *     // ... data to create a Pipeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pipeline we want to update
     *   }
     * })
     */
    upsert<T extends PipelineUpsertArgs>(args: SelectSubset<T, PipelineUpsertArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pipelines that matches the filter.
     * @param {PipelineFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pipeline = await prisma.pipeline.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PipelineFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Pipeline.
     * @param {PipelineAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pipeline = await prisma.pipeline.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PipelineAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineCountArgs} args - Arguments to filter Pipelines to count.
     * @example
     * // Count the number of Pipelines
     * const count = await prisma.pipeline.count({
     *   where: {
     *     // ... the filter for the Pipelines we want to count
     *   }
     * })
    **/
    count<T extends PipelineCountArgs>(
      args?: Subset<T, PipelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineAggregateArgs>(args: Subset<T, PipelineAggregateArgs>): Prisma.PrismaPromise<GetPipelineAggregateType<T>>

    /**
     * Group by Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineGroupByArgs['orderBy'] }
        : { orderBy?: PipelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pipeline model
   */
  readonly fields: PipelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pipeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pipeline model
   */
  interface PipelineFieldRefs {
    readonly id: FieldRef<"Pipeline", 'String'>
    readonly name: FieldRef<"Pipeline", 'String'>
    readonly description: FieldRef<"Pipeline", 'String'>
    readonly type: FieldRef<"Pipeline", 'PipelineType'>
    readonly status: FieldRef<"Pipeline", 'PipelineStatus'>
    readonly config: FieldRef<"Pipeline", 'Json'>
    readonly metadata: FieldRef<"Pipeline", 'Json'>
    readonly createdAt: FieldRef<"Pipeline", 'DateTime'>
    readonly updatedAt: FieldRef<"Pipeline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pipeline findUnique
   */
  export type PipelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findUniqueOrThrow
   */
  export type PipelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findFirst
   */
  export type PipelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findFirstOrThrow
   */
  export type PipelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findMany
   */
  export type PipelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline create
   */
  export type PipelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The data needed to create a Pipeline.
     */
    data: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
  }

  /**
   * Pipeline createMany
   */
  export type PipelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
  }

  /**
   * Pipeline update
   */
  export type PipelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The data needed to update a Pipeline.
     */
    data: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
    /**
     * Choose, which Pipeline to update.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline updateMany
   */
  export type PipelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
  }

  /**
   * Pipeline upsert
   */
  export type PipelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The filter to search for the Pipeline to update in case it exists.
     */
    where: PipelineWhereUniqueInput
    /**
     * In case the Pipeline found by the `where` argument doesn't exist, create a new Pipeline with this data.
     */
    create: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
    /**
     * In case the Pipeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
  }

  /**
   * Pipeline delete
   */
  export type PipelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Filter which Pipeline to delete.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline deleteMany
   */
  export type PipelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to delete
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to delete.
     */
    limit?: number
  }

  /**
   * Pipeline findRaw
   */
  export type PipelineFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Pipeline aggregateRaw
   */
  export type PipelineAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Pipeline without action
   */
  export type PipelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
  }


  /**
   * Model PublicVideo
   */

  export type AggregatePublicVideo = {
    _count: PublicVideoCountAggregateOutputType | null
    _avg: PublicVideoAvgAggregateOutputType | null
    _sum: PublicVideoSumAggregateOutputType | null
    _min: PublicVideoMinAggregateOutputType | null
    _max: PublicVideoMaxAggregateOutputType | null
  }

  export type PublicVideoAvgAggregateOutputType = {
    views: number | null
    likes: number | null
  }

  export type PublicVideoSumAggregateOutputType = {
    views: number | null
    likes: number | null
  }

  export type PublicVideoMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    title: string | null
    description: string | null
    thumbnailUrl: string | null
    videoUrl: string | null
    nftId: string | null
    walletAddress: string | null
    views: number | null
    likes: number | null
    featured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicVideoMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    title: string | null
    description: string | null
    thumbnailUrl: string | null
    videoUrl: string | null
    nftId: string | null
    walletAddress: string | null
    views: number | null
    likes: number | null
    featured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicVideoCountAggregateOutputType = {
    id: number
    videoId: number
    title: number
    description: number
    thumbnailUrl: number
    videoUrl: number
    nftId: number
    walletAddress: number
    views: number
    likes: number
    featured: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PublicVideoAvgAggregateInputType = {
    views?: true
    likes?: true
  }

  export type PublicVideoSumAggregateInputType = {
    views?: true
    likes?: true
  }

  export type PublicVideoMinAggregateInputType = {
    id?: true
    videoId?: true
    title?: true
    description?: true
    thumbnailUrl?: true
    videoUrl?: true
    nftId?: true
    walletAddress?: true
    views?: true
    likes?: true
    featured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicVideoMaxAggregateInputType = {
    id?: true
    videoId?: true
    title?: true
    description?: true
    thumbnailUrl?: true
    videoUrl?: true
    nftId?: true
    walletAddress?: true
    views?: true
    likes?: true
    featured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicVideoCountAggregateInputType = {
    id?: true
    videoId?: true
    title?: true
    description?: true
    thumbnailUrl?: true
    videoUrl?: true
    nftId?: true
    walletAddress?: true
    views?: true
    likes?: true
    featured?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PublicVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicVideo to aggregate.
     */
    where?: PublicVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicVideos to fetch.
     */
    orderBy?: PublicVideoOrderByWithRelationInput | PublicVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PublicVideos
    **/
    _count?: true | PublicVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicVideoMaxAggregateInputType
  }

  export type GetPublicVideoAggregateType<T extends PublicVideoAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicVideo[P]>
      : GetScalarType<T[P], AggregatePublicVideo[P]>
  }




  export type PublicVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicVideoWhereInput
    orderBy?: PublicVideoOrderByWithAggregationInput | PublicVideoOrderByWithAggregationInput[]
    by: PublicVideoScalarFieldEnum[] | PublicVideoScalarFieldEnum
    having?: PublicVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicVideoCountAggregateInputType | true
    _avg?: PublicVideoAvgAggregateInputType
    _sum?: PublicVideoSumAggregateInputType
    _min?: PublicVideoMinAggregateInputType
    _max?: PublicVideoMaxAggregateInputType
  }

  export type PublicVideoGroupByOutputType = {
    id: string
    videoId: string
    title: string
    description: string | null
    thumbnailUrl: string | null
    videoUrl: string
    nftId: string
    walletAddress: string
    views: number
    likes: number
    featured: boolean
    tags: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PublicVideoCountAggregateOutputType | null
    _avg: PublicVideoAvgAggregateOutputType | null
    _sum: PublicVideoSumAggregateOutputType | null
    _min: PublicVideoMinAggregateOutputType | null
    _max: PublicVideoMaxAggregateOutputType | null
  }

  type GetPublicVideoGroupByPayload<T extends PublicVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicVideoGroupByOutputType[P]>
            : GetScalarType<T[P], PublicVideoGroupByOutputType[P]>
        }
      >
    >


  export type PublicVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    title?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    videoUrl?: boolean
    nftId?: boolean
    walletAddress?: boolean
    views?: boolean
    likes?: boolean
    featured?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["publicVideo"]>



  export type PublicVideoSelectScalar = {
    id?: boolean
    videoId?: boolean
    title?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    videoUrl?: boolean
    nftId?: boolean
    walletAddress?: boolean
    views?: boolean
    likes?: boolean
    featured?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PublicVideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "videoId" | "title" | "description" | "thumbnailUrl" | "videoUrl" | "nftId" | "walletAddress" | "views" | "likes" | "featured" | "tags" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["publicVideo"]>

  export type $PublicVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PublicVideo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      title: string
      description: string | null
      thumbnailUrl: string | null
      videoUrl: string
      nftId: string
      walletAddress: string
      views: number
      likes: number
      featured: boolean
      tags: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["publicVideo"]>
    composites: {}
  }

  type PublicVideoGetPayload<S extends boolean | null | undefined | PublicVideoDefaultArgs> = $Result.GetResult<Prisma.$PublicVideoPayload, S>

  type PublicVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PublicVideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublicVideoCountAggregateInputType | true
    }

  export interface PublicVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublicVideo'], meta: { name: 'PublicVideo' } }
    /**
     * Find zero or one PublicVideo that matches the filter.
     * @param {PublicVideoFindUniqueArgs} args - Arguments to find a PublicVideo
     * @example
     * // Get one PublicVideo
     * const publicVideo = await prisma.publicVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicVideoFindUniqueArgs>(args: SelectSubset<T, PublicVideoFindUniqueArgs<ExtArgs>>): Prisma__PublicVideoClient<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PublicVideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublicVideoFindUniqueOrThrowArgs} args - Arguments to find a PublicVideo
     * @example
     * // Get one PublicVideo
     * const publicVideo = await prisma.publicVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicVideoClient<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublicVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicVideoFindFirstArgs} args - Arguments to find a PublicVideo
     * @example
     * // Get one PublicVideo
     * const publicVideo = await prisma.publicVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicVideoFindFirstArgs>(args?: SelectSubset<T, PublicVideoFindFirstArgs<ExtArgs>>): Prisma__PublicVideoClient<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublicVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicVideoFindFirstOrThrowArgs} args - Arguments to find a PublicVideo
     * @example
     * // Get one PublicVideo
     * const publicVideo = await prisma.publicVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicVideoClient<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PublicVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublicVideos
     * const publicVideos = await prisma.publicVideo.findMany()
     * 
     * // Get first 10 PublicVideos
     * const publicVideos = await prisma.publicVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicVideoWithIdOnly = await prisma.publicVideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicVideoFindManyArgs>(args?: SelectSubset<T, PublicVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PublicVideo.
     * @param {PublicVideoCreateArgs} args - Arguments to create a PublicVideo.
     * @example
     * // Create one PublicVideo
     * const PublicVideo = await prisma.publicVideo.create({
     *   data: {
     *     // ... data to create a PublicVideo
     *   }
     * })
     * 
     */
    create<T extends PublicVideoCreateArgs>(args: SelectSubset<T, PublicVideoCreateArgs<ExtArgs>>): Prisma__PublicVideoClient<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PublicVideos.
     * @param {PublicVideoCreateManyArgs} args - Arguments to create many PublicVideos.
     * @example
     * // Create many PublicVideos
     * const publicVideo = await prisma.publicVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicVideoCreateManyArgs>(args?: SelectSubset<T, PublicVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PublicVideo.
     * @param {PublicVideoDeleteArgs} args - Arguments to delete one PublicVideo.
     * @example
     * // Delete one PublicVideo
     * const PublicVideo = await prisma.publicVideo.delete({
     *   where: {
     *     // ... filter to delete one PublicVideo
     *   }
     * })
     * 
     */
    delete<T extends PublicVideoDeleteArgs>(args: SelectSubset<T, PublicVideoDeleteArgs<ExtArgs>>): Prisma__PublicVideoClient<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PublicVideo.
     * @param {PublicVideoUpdateArgs} args - Arguments to update one PublicVideo.
     * @example
     * // Update one PublicVideo
     * const publicVideo = await prisma.publicVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicVideoUpdateArgs>(args: SelectSubset<T, PublicVideoUpdateArgs<ExtArgs>>): Prisma__PublicVideoClient<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PublicVideos.
     * @param {PublicVideoDeleteManyArgs} args - Arguments to filter PublicVideos to delete.
     * @example
     * // Delete a few PublicVideos
     * const { count } = await prisma.publicVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicVideoDeleteManyArgs>(args?: SelectSubset<T, PublicVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublicVideos
     * const publicVideo = await prisma.publicVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicVideoUpdateManyArgs>(args: SelectSubset<T, PublicVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PublicVideo.
     * @param {PublicVideoUpsertArgs} args - Arguments to update or create a PublicVideo.
     * @example
     * // Update or create a PublicVideo
     * const publicVideo = await prisma.publicVideo.upsert({
     *   create: {
     *     // ... data to create a PublicVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublicVideo we want to update
     *   }
     * })
     */
    upsert<T extends PublicVideoUpsertArgs>(args: SelectSubset<T, PublicVideoUpsertArgs<ExtArgs>>): Prisma__PublicVideoClient<$Result.GetResult<Prisma.$PublicVideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PublicVideos that matches the filter.
     * @param {PublicVideoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const publicVideo = await prisma.publicVideo.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PublicVideoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PublicVideo.
     * @param {PublicVideoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const publicVideo = await prisma.publicVideo.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PublicVideoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PublicVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicVideoCountArgs} args - Arguments to filter PublicVideos to count.
     * @example
     * // Count the number of PublicVideos
     * const count = await prisma.publicVideo.count({
     *   where: {
     *     // ... the filter for the PublicVideos we want to count
     *   }
     * })
    **/
    count<T extends PublicVideoCountArgs>(
      args?: Subset<T, PublicVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublicVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicVideoAggregateArgs>(args: Subset<T, PublicVideoAggregateArgs>): Prisma.PrismaPromise<GetPublicVideoAggregateType<T>>

    /**
     * Group by PublicVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicVideoGroupByArgs['orderBy'] }
        : { orderBy?: PublicVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PublicVideo model
   */
  readonly fields: PublicVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PublicVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PublicVideo model
   */
  interface PublicVideoFieldRefs {
    readonly id: FieldRef<"PublicVideo", 'String'>
    readonly videoId: FieldRef<"PublicVideo", 'String'>
    readonly title: FieldRef<"PublicVideo", 'String'>
    readonly description: FieldRef<"PublicVideo", 'String'>
    readonly thumbnailUrl: FieldRef<"PublicVideo", 'String'>
    readonly videoUrl: FieldRef<"PublicVideo", 'String'>
    readonly nftId: FieldRef<"PublicVideo", 'String'>
    readonly walletAddress: FieldRef<"PublicVideo", 'String'>
    readonly views: FieldRef<"PublicVideo", 'Int'>
    readonly likes: FieldRef<"PublicVideo", 'Int'>
    readonly featured: FieldRef<"PublicVideo", 'Boolean'>
    readonly tags: FieldRef<"PublicVideo", 'String[]'>
    readonly metadata: FieldRef<"PublicVideo", 'Json'>
    readonly createdAt: FieldRef<"PublicVideo", 'DateTime'>
    readonly updatedAt: FieldRef<"PublicVideo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PublicVideo findUnique
   */
  export type PublicVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * Filter, which PublicVideo to fetch.
     */
    where: PublicVideoWhereUniqueInput
  }

  /**
   * PublicVideo findUniqueOrThrow
   */
  export type PublicVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * Filter, which PublicVideo to fetch.
     */
    where: PublicVideoWhereUniqueInput
  }

  /**
   * PublicVideo findFirst
   */
  export type PublicVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * Filter, which PublicVideo to fetch.
     */
    where?: PublicVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicVideos to fetch.
     */
    orderBy?: PublicVideoOrderByWithRelationInput | PublicVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicVideos.
     */
    cursor?: PublicVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicVideos.
     */
    distinct?: PublicVideoScalarFieldEnum | PublicVideoScalarFieldEnum[]
  }

  /**
   * PublicVideo findFirstOrThrow
   */
  export type PublicVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * Filter, which PublicVideo to fetch.
     */
    where?: PublicVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicVideos to fetch.
     */
    orderBy?: PublicVideoOrderByWithRelationInput | PublicVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicVideos.
     */
    cursor?: PublicVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicVideos.
     */
    distinct?: PublicVideoScalarFieldEnum | PublicVideoScalarFieldEnum[]
  }

  /**
   * PublicVideo findMany
   */
  export type PublicVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * Filter, which PublicVideos to fetch.
     */
    where?: PublicVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicVideos to fetch.
     */
    orderBy?: PublicVideoOrderByWithRelationInput | PublicVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PublicVideos.
     */
    cursor?: PublicVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicVideos.
     */
    skip?: number
    distinct?: PublicVideoScalarFieldEnum | PublicVideoScalarFieldEnum[]
  }

  /**
   * PublicVideo create
   */
  export type PublicVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * The data needed to create a PublicVideo.
     */
    data: XOR<PublicVideoCreateInput, PublicVideoUncheckedCreateInput>
  }

  /**
   * PublicVideo createMany
   */
  export type PublicVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublicVideos.
     */
    data: PublicVideoCreateManyInput | PublicVideoCreateManyInput[]
  }

  /**
   * PublicVideo update
   */
  export type PublicVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * The data needed to update a PublicVideo.
     */
    data: XOR<PublicVideoUpdateInput, PublicVideoUncheckedUpdateInput>
    /**
     * Choose, which PublicVideo to update.
     */
    where: PublicVideoWhereUniqueInput
  }

  /**
   * PublicVideo updateMany
   */
  export type PublicVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublicVideos.
     */
    data: XOR<PublicVideoUpdateManyMutationInput, PublicVideoUncheckedUpdateManyInput>
    /**
     * Filter which PublicVideos to update
     */
    where?: PublicVideoWhereInput
    /**
     * Limit how many PublicVideos to update.
     */
    limit?: number
  }

  /**
   * PublicVideo upsert
   */
  export type PublicVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * The filter to search for the PublicVideo to update in case it exists.
     */
    where: PublicVideoWhereUniqueInput
    /**
     * In case the PublicVideo found by the `where` argument doesn't exist, create a new PublicVideo with this data.
     */
    create: XOR<PublicVideoCreateInput, PublicVideoUncheckedCreateInput>
    /**
     * In case the PublicVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicVideoUpdateInput, PublicVideoUncheckedUpdateInput>
  }

  /**
   * PublicVideo delete
   */
  export type PublicVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
    /**
     * Filter which PublicVideo to delete.
     */
    where: PublicVideoWhereUniqueInput
  }

  /**
   * PublicVideo deleteMany
   */
  export type PublicVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicVideos to delete
     */
    where?: PublicVideoWhereInput
    /**
     * Limit how many PublicVideos to delete.
     */
    limit?: number
  }

  /**
   * PublicVideo findRaw
   */
  export type PublicVideoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PublicVideo aggregateRaw
   */
  export type PublicVideoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PublicVideo without action
   */
  export type PublicVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicVideo
     */
    select?: PublicVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicVideo
     */
    omit?: PublicVideoOmit<ExtArgs> | null
  }


  /**
   * Model GameAgent
   */

  export type AggregateGameAgent = {
    _count: GameAgentCountAggregateOutputType | null
    _avg: GameAgentAvgAggregateOutputType | null
    _sum: GameAgentSumAggregateOutputType | null
    _min: GameAgentMinAggregateOutputType | null
    _max: GameAgentMaxAggregateOutputType | null
  }

  export type GameAgentAvgAggregateOutputType = {
    timelinePoints: number | null
  }

  export type GameAgentSumAggregateOutputType = {
    timelinePoints: number | null
  }

  export type GameAgentMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    codename: string | null
    rank: $Enums.AgentRank | null
    timelinePoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameAgentMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    codename: string | null
    rank: $Enums.AgentRank | null
    timelinePoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameAgentCountAggregateOutputType = {
    id: number
    accountId: number
    codename: number
    rank: number
    timelinePoints: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAgentAvgAggregateInputType = {
    timelinePoints?: true
  }

  export type GameAgentSumAggregateInputType = {
    timelinePoints?: true
  }

  export type GameAgentMinAggregateInputType = {
    id?: true
    accountId?: true
    codename?: true
    rank?: true
    timelinePoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameAgentMaxAggregateInputType = {
    id?: true
    accountId?: true
    codename?: true
    rank?: true
    timelinePoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameAgentCountAggregateInputType = {
    id?: true
    accountId?: true
    codename?: true
    rank?: true
    timelinePoints?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameAgent to aggregate.
     */
    where?: GameAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAgents to fetch.
     */
    orderBy?: GameAgentOrderByWithRelationInput | GameAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameAgents
    **/
    _count?: true | GameAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameAgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameAgentMaxAggregateInputType
  }

  export type GetGameAgentAggregateType<T extends GameAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateGameAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameAgent[P]>
      : GetScalarType<T[P], AggregateGameAgent[P]>
  }




  export type GameAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameAgentWhereInput
    orderBy?: GameAgentOrderByWithAggregationInput | GameAgentOrderByWithAggregationInput[]
    by: GameAgentScalarFieldEnum[] | GameAgentScalarFieldEnum
    having?: GameAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameAgentCountAggregateInputType | true
    _avg?: GameAgentAvgAggregateInputType
    _sum?: GameAgentSumAggregateInputType
    _min?: GameAgentMinAggregateInputType
    _max?: GameAgentMaxAggregateInputType
  }

  export type GameAgentGroupByOutputType = {
    id: string
    accountId: string
    codename: string | null
    rank: $Enums.AgentRank
    timelinePoints: number
    createdAt: Date
    updatedAt: Date
    _count: GameAgentCountAggregateOutputType | null
    _avg: GameAgentAvgAggregateOutputType | null
    _sum: GameAgentSumAggregateOutputType | null
    _min: GameAgentMinAggregateOutputType | null
    _max: GameAgentMaxAggregateOutputType | null
  }

  type GetGameAgentGroupByPayload<T extends GameAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameAgentGroupByOutputType[P]>
            : GetScalarType<T[P], GameAgentGroupByOutputType[P]>
        }
      >
    >


  export type GameAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    codename?: boolean
    rank?: boolean
    timelinePoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    proxim8s?: boolean | GameAgent$proxim8sArgs<ExtArgs>
    missionDeployments?: boolean | GameAgent$missionDeploymentsArgs<ExtArgs>
    _count?: boolean | GameAgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameAgent"]>



  export type GameAgentSelectScalar = {
    id?: boolean
    accountId?: boolean
    codename?: boolean
    rank?: boolean
    timelinePoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameAgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "codename" | "rank" | "timelinePoints" | "createdAt" | "updatedAt", ExtArgs["result"]["gameAgent"]>
  export type GameAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    proxim8s?: boolean | GameAgent$proxim8sArgs<ExtArgs>
    missionDeployments?: boolean | GameAgent$missionDeploymentsArgs<ExtArgs>
    _count?: boolean | GameAgentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GameAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameAgent"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      proxim8s: Prisma.$GameProxim8Payload<ExtArgs>[]
      missionDeployments: Prisma.$TrainingMissionDeploymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      codename: string | null
      rank: $Enums.AgentRank
      timelinePoints: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameAgent"]>
    composites: {}
  }

  type GameAgentGetPayload<S extends boolean | null | undefined | GameAgentDefaultArgs> = $Result.GetResult<Prisma.$GameAgentPayload, S>

  type GameAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameAgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameAgentCountAggregateInputType | true
    }

  export interface GameAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameAgent'], meta: { name: 'GameAgent' } }
    /**
     * Find zero or one GameAgent that matches the filter.
     * @param {GameAgentFindUniqueArgs} args - Arguments to find a GameAgent
     * @example
     * // Get one GameAgent
     * const gameAgent = await prisma.gameAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameAgentFindUniqueArgs>(args: SelectSubset<T, GameAgentFindUniqueArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameAgent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameAgentFindUniqueOrThrowArgs} args - Arguments to find a GameAgent
     * @example
     * // Get one GameAgent
     * const gameAgent = await prisma.gameAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameAgentFindUniqueOrThrowArgs>(args: SelectSubset<T, GameAgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAgentFindFirstArgs} args - Arguments to find a GameAgent
     * @example
     * // Get one GameAgent
     * const gameAgent = await prisma.gameAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameAgentFindFirstArgs>(args?: SelectSubset<T, GameAgentFindFirstArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAgentFindFirstOrThrowArgs} args - Arguments to find a GameAgent
     * @example
     * // Get one GameAgent
     * const gameAgent = await prisma.gameAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameAgentFindFirstOrThrowArgs>(args?: SelectSubset<T, GameAgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameAgents
     * const gameAgents = await prisma.gameAgent.findMany()
     * 
     * // Get first 10 GameAgents
     * const gameAgents = await prisma.gameAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameAgentWithIdOnly = await prisma.gameAgent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameAgentFindManyArgs>(args?: SelectSubset<T, GameAgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameAgent.
     * @param {GameAgentCreateArgs} args - Arguments to create a GameAgent.
     * @example
     * // Create one GameAgent
     * const GameAgent = await prisma.gameAgent.create({
     *   data: {
     *     // ... data to create a GameAgent
     *   }
     * })
     * 
     */
    create<T extends GameAgentCreateArgs>(args: SelectSubset<T, GameAgentCreateArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameAgents.
     * @param {GameAgentCreateManyArgs} args - Arguments to create many GameAgents.
     * @example
     * // Create many GameAgents
     * const gameAgent = await prisma.gameAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameAgentCreateManyArgs>(args?: SelectSubset<T, GameAgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GameAgent.
     * @param {GameAgentDeleteArgs} args - Arguments to delete one GameAgent.
     * @example
     * // Delete one GameAgent
     * const GameAgent = await prisma.gameAgent.delete({
     *   where: {
     *     // ... filter to delete one GameAgent
     *   }
     * })
     * 
     */
    delete<T extends GameAgentDeleteArgs>(args: SelectSubset<T, GameAgentDeleteArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameAgent.
     * @param {GameAgentUpdateArgs} args - Arguments to update one GameAgent.
     * @example
     * // Update one GameAgent
     * const gameAgent = await prisma.gameAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameAgentUpdateArgs>(args: SelectSubset<T, GameAgentUpdateArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameAgents.
     * @param {GameAgentDeleteManyArgs} args - Arguments to filter GameAgents to delete.
     * @example
     * // Delete a few GameAgents
     * const { count } = await prisma.gameAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameAgentDeleteManyArgs>(args?: SelectSubset<T, GameAgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameAgents
     * const gameAgent = await prisma.gameAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameAgentUpdateManyArgs>(args: SelectSubset<T, GameAgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameAgent.
     * @param {GameAgentUpsertArgs} args - Arguments to update or create a GameAgent.
     * @example
     * // Update or create a GameAgent
     * const gameAgent = await prisma.gameAgent.upsert({
     *   create: {
     *     // ... data to create a GameAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameAgent we want to update
     *   }
     * })
     */
    upsert<T extends GameAgentUpsertArgs>(args: SelectSubset<T, GameAgentUpsertArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameAgents that matches the filter.
     * @param {GameAgentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const gameAgent = await prisma.gameAgent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GameAgentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GameAgent.
     * @param {GameAgentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const gameAgent = await prisma.gameAgent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GameAgentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GameAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAgentCountArgs} args - Arguments to filter GameAgents to count.
     * @example
     * // Count the number of GameAgents
     * const count = await prisma.gameAgent.count({
     *   where: {
     *     // ... the filter for the GameAgents we want to count
     *   }
     * })
    **/
    count<T extends GameAgentCountArgs>(
      args?: Subset<T, GameAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAgentAggregateArgs>(args: Subset<T, GameAgentAggregateArgs>): Prisma.PrismaPromise<GetGameAgentAggregateType<T>>

    /**
     * Group by GameAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameAgentGroupByArgs['orderBy'] }
        : { orderBy?: GameAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameAgent model
   */
  readonly fields: GameAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proxim8s<T extends GameAgent$proxim8sArgs<ExtArgs> = {}>(args?: Subset<T, GameAgent$proxim8sArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    missionDeployments<T extends GameAgent$missionDeploymentsArgs<ExtArgs> = {}>(args?: Subset<T, GameAgent$missionDeploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameAgent model
   */
  interface GameAgentFieldRefs {
    readonly id: FieldRef<"GameAgent", 'String'>
    readonly accountId: FieldRef<"GameAgent", 'String'>
    readonly codename: FieldRef<"GameAgent", 'String'>
    readonly rank: FieldRef<"GameAgent", 'AgentRank'>
    readonly timelinePoints: FieldRef<"GameAgent", 'Int'>
    readonly createdAt: FieldRef<"GameAgent", 'DateTime'>
    readonly updatedAt: FieldRef<"GameAgent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameAgent findUnique
   */
  export type GameAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * Filter, which GameAgent to fetch.
     */
    where: GameAgentWhereUniqueInput
  }

  /**
   * GameAgent findUniqueOrThrow
   */
  export type GameAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * Filter, which GameAgent to fetch.
     */
    where: GameAgentWhereUniqueInput
  }

  /**
   * GameAgent findFirst
   */
  export type GameAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * Filter, which GameAgent to fetch.
     */
    where?: GameAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAgents to fetch.
     */
    orderBy?: GameAgentOrderByWithRelationInput | GameAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameAgents.
     */
    cursor?: GameAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameAgents.
     */
    distinct?: GameAgentScalarFieldEnum | GameAgentScalarFieldEnum[]
  }

  /**
   * GameAgent findFirstOrThrow
   */
  export type GameAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * Filter, which GameAgent to fetch.
     */
    where?: GameAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAgents to fetch.
     */
    orderBy?: GameAgentOrderByWithRelationInput | GameAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameAgents.
     */
    cursor?: GameAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameAgents.
     */
    distinct?: GameAgentScalarFieldEnum | GameAgentScalarFieldEnum[]
  }

  /**
   * GameAgent findMany
   */
  export type GameAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * Filter, which GameAgents to fetch.
     */
    where?: GameAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAgents to fetch.
     */
    orderBy?: GameAgentOrderByWithRelationInput | GameAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameAgents.
     */
    cursor?: GameAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAgents.
     */
    skip?: number
    distinct?: GameAgentScalarFieldEnum | GameAgentScalarFieldEnum[]
  }

  /**
   * GameAgent create
   */
  export type GameAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a GameAgent.
     */
    data: XOR<GameAgentCreateInput, GameAgentUncheckedCreateInput>
  }

  /**
   * GameAgent createMany
   */
  export type GameAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameAgents.
     */
    data: GameAgentCreateManyInput | GameAgentCreateManyInput[]
  }

  /**
   * GameAgent update
   */
  export type GameAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a GameAgent.
     */
    data: XOR<GameAgentUpdateInput, GameAgentUncheckedUpdateInput>
    /**
     * Choose, which GameAgent to update.
     */
    where: GameAgentWhereUniqueInput
  }

  /**
   * GameAgent updateMany
   */
  export type GameAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameAgents.
     */
    data: XOR<GameAgentUpdateManyMutationInput, GameAgentUncheckedUpdateManyInput>
    /**
     * Filter which GameAgents to update
     */
    where?: GameAgentWhereInput
    /**
     * Limit how many GameAgents to update.
     */
    limit?: number
  }

  /**
   * GameAgent upsert
   */
  export type GameAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the GameAgent to update in case it exists.
     */
    where: GameAgentWhereUniqueInput
    /**
     * In case the GameAgent found by the `where` argument doesn't exist, create a new GameAgent with this data.
     */
    create: XOR<GameAgentCreateInput, GameAgentUncheckedCreateInput>
    /**
     * In case the GameAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameAgentUpdateInput, GameAgentUncheckedUpdateInput>
  }

  /**
   * GameAgent delete
   */
  export type GameAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
    /**
     * Filter which GameAgent to delete.
     */
    where: GameAgentWhereUniqueInput
  }

  /**
   * GameAgent deleteMany
   */
  export type GameAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameAgents to delete
     */
    where?: GameAgentWhereInput
    /**
     * Limit how many GameAgents to delete.
     */
    limit?: number
  }

  /**
   * GameAgent findRaw
   */
  export type GameAgentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GameAgent aggregateRaw
   */
  export type GameAgentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GameAgent.proxim8s
   */
  export type GameAgent$proxim8sArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    where?: GameProxim8WhereInput
    orderBy?: GameProxim8OrderByWithRelationInput | GameProxim8OrderByWithRelationInput[]
    cursor?: GameProxim8WhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameProxim8ScalarFieldEnum | GameProxim8ScalarFieldEnum[]
  }

  /**
   * GameAgent.missionDeployments
   */
  export type GameAgent$missionDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    where?: TrainingMissionDeploymentWhereInput
    orderBy?: TrainingMissionDeploymentOrderByWithRelationInput | TrainingMissionDeploymentOrderByWithRelationInput[]
    cursor?: TrainingMissionDeploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingMissionDeploymentScalarFieldEnum | TrainingMissionDeploymentScalarFieldEnum[]
  }

  /**
   * GameAgent without action
   */
  export type GameAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAgent
     */
    select?: GameAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAgent
     */
    omit?: GameAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAgentInclude<ExtArgs> | null
  }


  /**
   * Model GameProxim8
   */

  export type AggregateGameProxim8 = {
    _count: GameProxim8CountAggregateOutputType | null
    _avg: GameProxim8AvgAggregateOutputType | null
    _sum: GameProxim8SumAggregateOutputType | null
    _min: GameProxim8MinAggregateOutputType | null
    _max: GameProxim8MaxAggregateOutputType | null
  }

  export type GameProxim8AvgAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type GameProxim8SumAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type GameProxim8MinAggregateOutputType = {
    id: string | null
    gameAgentId: string | null
    nftId: string | null
    name: string | null
    personality: $Enums.Proxim8Personality | null
    level: number | null
    experience: number | null
    isDeployed: boolean | null
    lastMissionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameProxim8MaxAggregateOutputType = {
    id: string | null
    gameAgentId: string | null
    nftId: string | null
    name: string | null
    personality: $Enums.Proxim8Personality | null
    level: number | null
    experience: number | null
    isDeployed: boolean | null
    lastMissionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameProxim8CountAggregateOutputType = {
    id: number
    gameAgentId: number
    nftId: number
    name: number
    personality: number
    level: number
    experience: number
    isDeployed: number
    lastMissionAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameProxim8AvgAggregateInputType = {
    level?: true
    experience?: true
  }

  export type GameProxim8SumAggregateInputType = {
    level?: true
    experience?: true
  }

  export type GameProxim8MinAggregateInputType = {
    id?: true
    gameAgentId?: true
    nftId?: true
    name?: true
    personality?: true
    level?: true
    experience?: true
    isDeployed?: true
    lastMissionAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameProxim8MaxAggregateInputType = {
    id?: true
    gameAgentId?: true
    nftId?: true
    name?: true
    personality?: true
    level?: true
    experience?: true
    isDeployed?: true
    lastMissionAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameProxim8CountAggregateInputType = {
    id?: true
    gameAgentId?: true
    nftId?: true
    name?: true
    personality?: true
    level?: true
    experience?: true
    isDeployed?: true
    lastMissionAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameProxim8AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameProxim8 to aggregate.
     */
    where?: GameProxim8WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameProxim8s to fetch.
     */
    orderBy?: GameProxim8OrderByWithRelationInput | GameProxim8OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameProxim8WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameProxim8s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameProxim8s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameProxim8s
    **/
    _count?: true | GameProxim8CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameProxim8AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameProxim8SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameProxim8MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameProxim8MaxAggregateInputType
  }

  export type GetGameProxim8AggregateType<T extends GameProxim8AggregateArgs> = {
        [P in keyof T & keyof AggregateGameProxim8]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameProxim8[P]>
      : GetScalarType<T[P], AggregateGameProxim8[P]>
  }




  export type GameProxim8GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameProxim8WhereInput
    orderBy?: GameProxim8OrderByWithAggregationInput | GameProxim8OrderByWithAggregationInput[]
    by: GameProxim8ScalarFieldEnum[] | GameProxim8ScalarFieldEnum
    having?: GameProxim8ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameProxim8CountAggregateInputType | true
    _avg?: GameProxim8AvgAggregateInputType
    _sum?: GameProxim8SumAggregateInputType
    _min?: GameProxim8MinAggregateInputType
    _max?: GameProxim8MaxAggregateInputType
  }

  export type GameProxim8GroupByOutputType = {
    id: string
    gameAgentId: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level: number
    experience: number
    isDeployed: boolean
    lastMissionAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: GameProxim8CountAggregateOutputType | null
    _avg: GameProxim8AvgAggregateOutputType | null
    _sum: GameProxim8SumAggregateOutputType | null
    _min: GameProxim8MinAggregateOutputType | null
    _max: GameProxim8MaxAggregateOutputType | null
  }

  type GetGameProxim8GroupByPayload<T extends GameProxim8GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameProxim8GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameProxim8GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameProxim8GroupByOutputType[P]>
            : GetScalarType<T[P], GameProxim8GroupByOutputType[P]>
        }
      >
    >


  export type GameProxim8Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameAgentId?: boolean
    nftId?: boolean
    name?: boolean
    personality?: boolean
    level?: boolean
    experience?: boolean
    isDeployed?: boolean
    lastMissionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameAgent?: boolean | GameAgentDefaultArgs<ExtArgs>
    missionDeployments?: boolean | GameProxim8$missionDeploymentsArgs<ExtArgs>
    _count?: boolean | GameProxim8CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameProxim8"]>



  export type GameProxim8SelectScalar = {
    id?: boolean
    gameAgentId?: boolean
    nftId?: boolean
    name?: boolean
    personality?: boolean
    level?: boolean
    experience?: boolean
    isDeployed?: boolean
    lastMissionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameProxim8Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameAgentId" | "nftId" | "name" | "personality" | "level" | "experience" | "isDeployed" | "lastMissionAt" | "createdAt" | "updatedAt", ExtArgs["result"]["gameProxim8"]>
  export type GameProxim8Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameAgent?: boolean | GameAgentDefaultArgs<ExtArgs>
    missionDeployments?: boolean | GameProxim8$missionDeploymentsArgs<ExtArgs>
    _count?: boolean | GameProxim8CountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GameProxim8Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameProxim8"
    objects: {
      gameAgent: Prisma.$GameAgentPayload<ExtArgs>
      missionDeployments: Prisma.$TrainingMissionDeploymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameAgentId: string
      nftId: string
      name: string
      personality: $Enums.Proxim8Personality
      level: number
      experience: number
      isDeployed: boolean
      lastMissionAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameProxim8"]>
    composites: {}
  }

  type GameProxim8GetPayload<S extends boolean | null | undefined | GameProxim8DefaultArgs> = $Result.GetResult<Prisma.$GameProxim8Payload, S>

  type GameProxim8CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameProxim8FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameProxim8CountAggregateInputType | true
    }

  export interface GameProxim8Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameProxim8'], meta: { name: 'GameProxim8' } }
    /**
     * Find zero or one GameProxim8 that matches the filter.
     * @param {GameProxim8FindUniqueArgs} args - Arguments to find a GameProxim8
     * @example
     * // Get one GameProxim8
     * const gameProxim8 = await prisma.gameProxim8.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameProxim8FindUniqueArgs>(args: SelectSubset<T, GameProxim8FindUniqueArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameProxim8 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameProxim8FindUniqueOrThrowArgs} args - Arguments to find a GameProxim8
     * @example
     * // Get one GameProxim8
     * const gameProxim8 = await prisma.gameProxim8.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameProxim8FindUniqueOrThrowArgs>(args: SelectSubset<T, GameProxim8FindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameProxim8 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameProxim8FindFirstArgs} args - Arguments to find a GameProxim8
     * @example
     * // Get one GameProxim8
     * const gameProxim8 = await prisma.gameProxim8.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameProxim8FindFirstArgs>(args?: SelectSubset<T, GameProxim8FindFirstArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameProxim8 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameProxim8FindFirstOrThrowArgs} args - Arguments to find a GameProxim8
     * @example
     * // Get one GameProxim8
     * const gameProxim8 = await prisma.gameProxim8.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameProxim8FindFirstOrThrowArgs>(args?: SelectSubset<T, GameProxim8FindFirstOrThrowArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameProxim8s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameProxim8FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameProxim8s
     * const gameProxim8s = await prisma.gameProxim8.findMany()
     * 
     * // Get first 10 GameProxim8s
     * const gameProxim8s = await prisma.gameProxim8.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameProxim8WithIdOnly = await prisma.gameProxim8.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameProxim8FindManyArgs>(args?: SelectSubset<T, GameProxim8FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameProxim8.
     * @param {GameProxim8CreateArgs} args - Arguments to create a GameProxim8.
     * @example
     * // Create one GameProxim8
     * const GameProxim8 = await prisma.gameProxim8.create({
     *   data: {
     *     // ... data to create a GameProxim8
     *   }
     * })
     * 
     */
    create<T extends GameProxim8CreateArgs>(args: SelectSubset<T, GameProxim8CreateArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameProxim8s.
     * @param {GameProxim8CreateManyArgs} args - Arguments to create many GameProxim8s.
     * @example
     * // Create many GameProxim8s
     * const gameProxim8 = await prisma.gameProxim8.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameProxim8CreateManyArgs>(args?: SelectSubset<T, GameProxim8CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GameProxim8.
     * @param {GameProxim8DeleteArgs} args - Arguments to delete one GameProxim8.
     * @example
     * // Delete one GameProxim8
     * const GameProxim8 = await prisma.gameProxim8.delete({
     *   where: {
     *     // ... filter to delete one GameProxim8
     *   }
     * })
     * 
     */
    delete<T extends GameProxim8DeleteArgs>(args: SelectSubset<T, GameProxim8DeleteArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameProxim8.
     * @param {GameProxim8UpdateArgs} args - Arguments to update one GameProxim8.
     * @example
     * // Update one GameProxim8
     * const gameProxim8 = await prisma.gameProxim8.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameProxim8UpdateArgs>(args: SelectSubset<T, GameProxim8UpdateArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameProxim8s.
     * @param {GameProxim8DeleteManyArgs} args - Arguments to filter GameProxim8s to delete.
     * @example
     * // Delete a few GameProxim8s
     * const { count } = await prisma.gameProxim8.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameProxim8DeleteManyArgs>(args?: SelectSubset<T, GameProxim8DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameProxim8s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameProxim8UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameProxim8s
     * const gameProxim8 = await prisma.gameProxim8.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameProxim8UpdateManyArgs>(args: SelectSubset<T, GameProxim8UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameProxim8.
     * @param {GameProxim8UpsertArgs} args - Arguments to update or create a GameProxim8.
     * @example
     * // Update or create a GameProxim8
     * const gameProxim8 = await prisma.gameProxim8.upsert({
     *   create: {
     *     // ... data to create a GameProxim8
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameProxim8 we want to update
     *   }
     * })
     */
    upsert<T extends GameProxim8UpsertArgs>(args: SelectSubset<T, GameProxim8UpsertArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameProxim8s that matches the filter.
     * @param {GameProxim8FindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const gameProxim8 = await prisma.gameProxim8.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GameProxim8FindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GameProxim8.
     * @param {GameProxim8AggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const gameProxim8 = await prisma.gameProxim8.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GameProxim8AggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GameProxim8s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameProxim8CountArgs} args - Arguments to filter GameProxim8s to count.
     * @example
     * // Count the number of GameProxim8s
     * const count = await prisma.gameProxim8.count({
     *   where: {
     *     // ... the filter for the GameProxim8s we want to count
     *   }
     * })
    **/
    count<T extends GameProxim8CountArgs>(
      args?: Subset<T, GameProxim8CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameProxim8CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameProxim8.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameProxim8AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameProxim8AggregateArgs>(args: Subset<T, GameProxim8AggregateArgs>): Prisma.PrismaPromise<GetGameProxim8AggregateType<T>>

    /**
     * Group by GameProxim8.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameProxim8GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameProxim8GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameProxim8GroupByArgs['orderBy'] }
        : { orderBy?: GameProxim8GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameProxim8GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameProxim8GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameProxim8 model
   */
  readonly fields: GameProxim8FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameProxim8.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameProxim8Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameAgent<T extends GameAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameAgentDefaultArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    missionDeployments<T extends GameProxim8$missionDeploymentsArgs<ExtArgs> = {}>(args?: Subset<T, GameProxim8$missionDeploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameProxim8 model
   */
  interface GameProxim8FieldRefs {
    readonly id: FieldRef<"GameProxim8", 'String'>
    readonly gameAgentId: FieldRef<"GameProxim8", 'String'>
    readonly nftId: FieldRef<"GameProxim8", 'String'>
    readonly name: FieldRef<"GameProxim8", 'String'>
    readonly personality: FieldRef<"GameProxim8", 'Proxim8Personality'>
    readonly level: FieldRef<"GameProxim8", 'Int'>
    readonly experience: FieldRef<"GameProxim8", 'Int'>
    readonly isDeployed: FieldRef<"GameProxim8", 'Boolean'>
    readonly lastMissionAt: FieldRef<"GameProxim8", 'DateTime'>
    readonly createdAt: FieldRef<"GameProxim8", 'DateTime'>
    readonly updatedAt: FieldRef<"GameProxim8", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameProxim8 findUnique
   */
  export type GameProxim8FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * Filter, which GameProxim8 to fetch.
     */
    where: GameProxim8WhereUniqueInput
  }

  /**
   * GameProxim8 findUniqueOrThrow
   */
  export type GameProxim8FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * Filter, which GameProxim8 to fetch.
     */
    where: GameProxim8WhereUniqueInput
  }

  /**
   * GameProxim8 findFirst
   */
  export type GameProxim8FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * Filter, which GameProxim8 to fetch.
     */
    where?: GameProxim8WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameProxim8s to fetch.
     */
    orderBy?: GameProxim8OrderByWithRelationInput | GameProxim8OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameProxim8s.
     */
    cursor?: GameProxim8WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameProxim8s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameProxim8s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameProxim8s.
     */
    distinct?: GameProxim8ScalarFieldEnum | GameProxim8ScalarFieldEnum[]
  }

  /**
   * GameProxim8 findFirstOrThrow
   */
  export type GameProxim8FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * Filter, which GameProxim8 to fetch.
     */
    where?: GameProxim8WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameProxim8s to fetch.
     */
    orderBy?: GameProxim8OrderByWithRelationInput | GameProxim8OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameProxim8s.
     */
    cursor?: GameProxim8WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameProxim8s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameProxim8s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameProxim8s.
     */
    distinct?: GameProxim8ScalarFieldEnum | GameProxim8ScalarFieldEnum[]
  }

  /**
   * GameProxim8 findMany
   */
  export type GameProxim8FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * Filter, which GameProxim8s to fetch.
     */
    where?: GameProxim8WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameProxim8s to fetch.
     */
    orderBy?: GameProxim8OrderByWithRelationInput | GameProxim8OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameProxim8s.
     */
    cursor?: GameProxim8WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameProxim8s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameProxim8s.
     */
    skip?: number
    distinct?: GameProxim8ScalarFieldEnum | GameProxim8ScalarFieldEnum[]
  }

  /**
   * GameProxim8 create
   */
  export type GameProxim8CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * The data needed to create a GameProxim8.
     */
    data: XOR<GameProxim8CreateInput, GameProxim8UncheckedCreateInput>
  }

  /**
   * GameProxim8 createMany
   */
  export type GameProxim8CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameProxim8s.
     */
    data: GameProxim8CreateManyInput | GameProxim8CreateManyInput[]
  }

  /**
   * GameProxim8 update
   */
  export type GameProxim8UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * The data needed to update a GameProxim8.
     */
    data: XOR<GameProxim8UpdateInput, GameProxim8UncheckedUpdateInput>
    /**
     * Choose, which GameProxim8 to update.
     */
    where: GameProxim8WhereUniqueInput
  }

  /**
   * GameProxim8 updateMany
   */
  export type GameProxim8UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameProxim8s.
     */
    data: XOR<GameProxim8UpdateManyMutationInput, GameProxim8UncheckedUpdateManyInput>
    /**
     * Filter which GameProxim8s to update
     */
    where?: GameProxim8WhereInput
    /**
     * Limit how many GameProxim8s to update.
     */
    limit?: number
  }

  /**
   * GameProxim8 upsert
   */
  export type GameProxim8UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * The filter to search for the GameProxim8 to update in case it exists.
     */
    where: GameProxim8WhereUniqueInput
    /**
     * In case the GameProxim8 found by the `where` argument doesn't exist, create a new GameProxim8 with this data.
     */
    create: XOR<GameProxim8CreateInput, GameProxim8UncheckedCreateInput>
    /**
     * In case the GameProxim8 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameProxim8UpdateInput, GameProxim8UncheckedUpdateInput>
  }

  /**
   * GameProxim8 delete
   */
  export type GameProxim8DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
    /**
     * Filter which GameProxim8 to delete.
     */
    where: GameProxim8WhereUniqueInput
  }

  /**
   * GameProxim8 deleteMany
   */
  export type GameProxim8DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameProxim8s to delete
     */
    where?: GameProxim8WhereInput
    /**
     * Limit how many GameProxim8s to delete.
     */
    limit?: number
  }

  /**
   * GameProxim8 findRaw
   */
  export type GameProxim8FindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GameProxim8 aggregateRaw
   */
  export type GameProxim8AggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GameProxim8.missionDeployments
   */
  export type GameProxim8$missionDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    where?: TrainingMissionDeploymentWhereInput
    orderBy?: TrainingMissionDeploymentOrderByWithRelationInput | TrainingMissionDeploymentOrderByWithRelationInput[]
    cursor?: TrainingMissionDeploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingMissionDeploymentScalarFieldEnum | TrainingMissionDeploymentScalarFieldEnum[]
  }

  /**
   * GameProxim8 without action
   */
  export type GameProxim8DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameProxim8
     */
    select?: GameProxim8Select<ExtArgs> | null
    /**
     * Omit specific fields from the GameProxim8
     */
    omit?: GameProxim8Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameProxim8Include<ExtArgs> | null
  }


  /**
   * Model TrainingMissionDeployment
   */

  export type AggregateTrainingMissionDeployment = {
    _count: TrainingMissionDeploymentCountAggregateOutputType | null
    _avg: TrainingMissionDeploymentAvgAggregateOutputType | null
    _sum: TrainingMissionDeploymentSumAggregateOutputType | null
    _min: TrainingMissionDeploymentMinAggregateOutputType | null
    _max: TrainingMissionDeploymentMaxAggregateOutputType | null
  }

  export type TrainingMissionDeploymentAvgAggregateOutputType = {
    duration: number | null
    currentPhase: number | null
    finalSuccessRate: number | null
  }

  export type TrainingMissionDeploymentSumAggregateOutputType = {
    duration: number | null
    currentPhase: number | null
    finalSuccessRate: number | null
  }

  export type TrainingMissionDeploymentMinAggregateOutputType = {
    id: string | null
    deploymentId: string | null
    missionId: string | null
    gameAgentId: string | null
    gameProxim8Id: string | null
    approach: $Enums.MissionApproach | null
    deployedAt: Date | null
    completesAt: Date | null
    duration: number | null
    status: $Enums.DeploymentStatus | null
    currentPhase: number | null
    finalSuccessRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingMissionDeploymentMaxAggregateOutputType = {
    id: string | null
    deploymentId: string | null
    missionId: string | null
    gameAgentId: string | null
    gameProxim8Id: string | null
    approach: $Enums.MissionApproach | null
    deployedAt: Date | null
    completesAt: Date | null
    duration: number | null
    status: $Enums.DeploymentStatus | null
    currentPhase: number | null
    finalSuccessRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingMissionDeploymentCountAggregateOutputType = {
    id: number
    deploymentId: number
    missionId: number
    gameAgentId: number
    gameProxim8Id: number
    approach: number
    deployedAt: number
    completesAt: number
    duration: number
    status: number
    currentPhase: number
    finalSuccessRate: number
    phaseOutcomes: number
    result: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingMissionDeploymentAvgAggregateInputType = {
    duration?: true
    currentPhase?: true
    finalSuccessRate?: true
  }

  export type TrainingMissionDeploymentSumAggregateInputType = {
    duration?: true
    currentPhase?: true
    finalSuccessRate?: true
  }

  export type TrainingMissionDeploymentMinAggregateInputType = {
    id?: true
    deploymentId?: true
    missionId?: true
    gameAgentId?: true
    gameProxim8Id?: true
    approach?: true
    deployedAt?: true
    completesAt?: true
    duration?: true
    status?: true
    currentPhase?: true
    finalSuccessRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingMissionDeploymentMaxAggregateInputType = {
    id?: true
    deploymentId?: true
    missionId?: true
    gameAgentId?: true
    gameProxim8Id?: true
    approach?: true
    deployedAt?: true
    completesAt?: true
    duration?: true
    status?: true
    currentPhase?: true
    finalSuccessRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingMissionDeploymentCountAggregateInputType = {
    id?: true
    deploymentId?: true
    missionId?: true
    gameAgentId?: true
    gameProxim8Id?: true
    approach?: true
    deployedAt?: true
    completesAt?: true
    duration?: true
    status?: true
    currentPhase?: true
    finalSuccessRate?: true
    phaseOutcomes?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingMissionDeploymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingMissionDeployment to aggregate.
     */
    where?: TrainingMissionDeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingMissionDeployments to fetch.
     */
    orderBy?: TrainingMissionDeploymentOrderByWithRelationInput | TrainingMissionDeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingMissionDeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingMissionDeployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingMissionDeployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingMissionDeployments
    **/
    _count?: true | TrainingMissionDeploymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingMissionDeploymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingMissionDeploymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingMissionDeploymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingMissionDeploymentMaxAggregateInputType
  }

  export type GetTrainingMissionDeploymentAggregateType<T extends TrainingMissionDeploymentAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingMissionDeployment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingMissionDeployment[P]>
      : GetScalarType<T[P], AggregateTrainingMissionDeployment[P]>
  }




  export type TrainingMissionDeploymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingMissionDeploymentWhereInput
    orderBy?: TrainingMissionDeploymentOrderByWithAggregationInput | TrainingMissionDeploymentOrderByWithAggregationInput[]
    by: TrainingMissionDeploymentScalarFieldEnum[] | TrainingMissionDeploymentScalarFieldEnum
    having?: TrainingMissionDeploymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingMissionDeploymentCountAggregateInputType | true
    _avg?: TrainingMissionDeploymentAvgAggregateInputType
    _sum?: TrainingMissionDeploymentSumAggregateInputType
    _min?: TrainingMissionDeploymentMinAggregateInputType
    _max?: TrainingMissionDeploymentMaxAggregateInputType
  }

  export type TrainingMissionDeploymentGroupByOutputType = {
    id: string
    deploymentId: string
    missionId: string
    gameAgentId: string
    gameProxim8Id: string
    approach: $Enums.MissionApproach
    deployedAt: Date
    completesAt: Date
    duration: number
    status: $Enums.DeploymentStatus
    currentPhase: number
    finalSuccessRate: number
    phaseOutcomes: JsonValue
    result: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingMissionDeploymentCountAggregateOutputType | null
    _avg: TrainingMissionDeploymentAvgAggregateOutputType | null
    _sum: TrainingMissionDeploymentSumAggregateOutputType | null
    _min: TrainingMissionDeploymentMinAggregateOutputType | null
    _max: TrainingMissionDeploymentMaxAggregateOutputType | null
  }

  type GetTrainingMissionDeploymentGroupByPayload<T extends TrainingMissionDeploymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingMissionDeploymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingMissionDeploymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingMissionDeploymentGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingMissionDeploymentGroupByOutputType[P]>
        }
      >
    >


  export type TrainingMissionDeploymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deploymentId?: boolean
    missionId?: boolean
    gameAgentId?: boolean
    gameProxim8Id?: boolean
    approach?: boolean
    deployedAt?: boolean
    completesAt?: boolean
    duration?: boolean
    status?: boolean
    currentPhase?: boolean
    finalSuccessRate?: boolean
    phaseOutcomes?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameAgent?: boolean | GameAgentDefaultArgs<ExtArgs>
    gameProxim8?: boolean | GameProxim8DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingMissionDeployment"]>



  export type TrainingMissionDeploymentSelectScalar = {
    id?: boolean
    deploymentId?: boolean
    missionId?: boolean
    gameAgentId?: boolean
    gameProxim8Id?: boolean
    approach?: boolean
    deployedAt?: boolean
    completesAt?: boolean
    duration?: boolean
    status?: boolean
    currentPhase?: boolean
    finalSuccessRate?: boolean
    phaseOutcomes?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingMissionDeploymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deploymentId" | "missionId" | "gameAgentId" | "gameProxim8Id" | "approach" | "deployedAt" | "completesAt" | "duration" | "status" | "currentPhase" | "finalSuccessRate" | "phaseOutcomes" | "result" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingMissionDeployment"]>
  export type TrainingMissionDeploymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameAgent?: boolean | GameAgentDefaultArgs<ExtArgs>
    gameProxim8?: boolean | GameProxim8DefaultArgs<ExtArgs>
  }

  export type $TrainingMissionDeploymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingMissionDeployment"
    objects: {
      gameAgent: Prisma.$GameAgentPayload<ExtArgs>
      gameProxim8: Prisma.$GameProxim8Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deploymentId: string
      missionId: string
      gameAgentId: string
      gameProxim8Id: string
      approach: $Enums.MissionApproach
      deployedAt: Date
      completesAt: Date
      duration: number
      status: $Enums.DeploymentStatus
      currentPhase: number
      finalSuccessRate: number
      phaseOutcomes: Prisma.JsonValue
      result: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingMissionDeployment"]>
    composites: {}
  }

  type TrainingMissionDeploymentGetPayload<S extends boolean | null | undefined | TrainingMissionDeploymentDefaultArgs> = $Result.GetResult<Prisma.$TrainingMissionDeploymentPayload, S>

  type TrainingMissionDeploymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingMissionDeploymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingMissionDeploymentCountAggregateInputType | true
    }

  export interface TrainingMissionDeploymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingMissionDeployment'], meta: { name: 'TrainingMissionDeployment' } }
    /**
     * Find zero or one TrainingMissionDeployment that matches the filter.
     * @param {TrainingMissionDeploymentFindUniqueArgs} args - Arguments to find a TrainingMissionDeployment
     * @example
     * // Get one TrainingMissionDeployment
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingMissionDeploymentFindUniqueArgs>(args: SelectSubset<T, TrainingMissionDeploymentFindUniqueArgs<ExtArgs>>): Prisma__TrainingMissionDeploymentClient<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingMissionDeployment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingMissionDeploymentFindUniqueOrThrowArgs} args - Arguments to find a TrainingMissionDeployment
     * @example
     * // Get one TrainingMissionDeployment
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingMissionDeploymentFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingMissionDeploymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingMissionDeploymentClient<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingMissionDeployment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionDeploymentFindFirstArgs} args - Arguments to find a TrainingMissionDeployment
     * @example
     * // Get one TrainingMissionDeployment
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingMissionDeploymentFindFirstArgs>(args?: SelectSubset<T, TrainingMissionDeploymentFindFirstArgs<ExtArgs>>): Prisma__TrainingMissionDeploymentClient<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingMissionDeployment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionDeploymentFindFirstOrThrowArgs} args - Arguments to find a TrainingMissionDeployment
     * @example
     * // Get one TrainingMissionDeployment
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingMissionDeploymentFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingMissionDeploymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingMissionDeploymentClient<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingMissionDeployments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionDeploymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingMissionDeployments
     * const trainingMissionDeployments = await prisma.trainingMissionDeployment.findMany()
     * 
     * // Get first 10 TrainingMissionDeployments
     * const trainingMissionDeployments = await prisma.trainingMissionDeployment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingMissionDeploymentWithIdOnly = await prisma.trainingMissionDeployment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingMissionDeploymentFindManyArgs>(args?: SelectSubset<T, TrainingMissionDeploymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingMissionDeployment.
     * @param {TrainingMissionDeploymentCreateArgs} args - Arguments to create a TrainingMissionDeployment.
     * @example
     * // Create one TrainingMissionDeployment
     * const TrainingMissionDeployment = await prisma.trainingMissionDeployment.create({
     *   data: {
     *     // ... data to create a TrainingMissionDeployment
     *   }
     * })
     * 
     */
    create<T extends TrainingMissionDeploymentCreateArgs>(args: SelectSubset<T, TrainingMissionDeploymentCreateArgs<ExtArgs>>): Prisma__TrainingMissionDeploymentClient<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingMissionDeployments.
     * @param {TrainingMissionDeploymentCreateManyArgs} args - Arguments to create many TrainingMissionDeployments.
     * @example
     * // Create many TrainingMissionDeployments
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingMissionDeploymentCreateManyArgs>(args?: SelectSubset<T, TrainingMissionDeploymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingMissionDeployment.
     * @param {TrainingMissionDeploymentDeleteArgs} args - Arguments to delete one TrainingMissionDeployment.
     * @example
     * // Delete one TrainingMissionDeployment
     * const TrainingMissionDeployment = await prisma.trainingMissionDeployment.delete({
     *   where: {
     *     // ... filter to delete one TrainingMissionDeployment
     *   }
     * })
     * 
     */
    delete<T extends TrainingMissionDeploymentDeleteArgs>(args: SelectSubset<T, TrainingMissionDeploymentDeleteArgs<ExtArgs>>): Prisma__TrainingMissionDeploymentClient<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingMissionDeployment.
     * @param {TrainingMissionDeploymentUpdateArgs} args - Arguments to update one TrainingMissionDeployment.
     * @example
     * // Update one TrainingMissionDeployment
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingMissionDeploymentUpdateArgs>(args: SelectSubset<T, TrainingMissionDeploymentUpdateArgs<ExtArgs>>): Prisma__TrainingMissionDeploymentClient<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingMissionDeployments.
     * @param {TrainingMissionDeploymentDeleteManyArgs} args - Arguments to filter TrainingMissionDeployments to delete.
     * @example
     * // Delete a few TrainingMissionDeployments
     * const { count } = await prisma.trainingMissionDeployment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingMissionDeploymentDeleteManyArgs>(args?: SelectSubset<T, TrainingMissionDeploymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingMissionDeployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionDeploymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingMissionDeployments
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingMissionDeploymentUpdateManyArgs>(args: SelectSubset<T, TrainingMissionDeploymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingMissionDeployment.
     * @param {TrainingMissionDeploymentUpsertArgs} args - Arguments to update or create a TrainingMissionDeployment.
     * @example
     * // Update or create a TrainingMissionDeployment
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.upsert({
     *   create: {
     *     // ... data to create a TrainingMissionDeployment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingMissionDeployment we want to update
     *   }
     * })
     */
    upsert<T extends TrainingMissionDeploymentUpsertArgs>(args: SelectSubset<T, TrainingMissionDeploymentUpsertArgs<ExtArgs>>): Prisma__TrainingMissionDeploymentClient<$Result.GetResult<Prisma.$TrainingMissionDeploymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingMissionDeployments that matches the filter.
     * @param {TrainingMissionDeploymentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TrainingMissionDeploymentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TrainingMissionDeployment.
     * @param {TrainingMissionDeploymentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const trainingMissionDeployment = await prisma.trainingMissionDeployment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TrainingMissionDeploymentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TrainingMissionDeployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionDeploymentCountArgs} args - Arguments to filter TrainingMissionDeployments to count.
     * @example
     * // Count the number of TrainingMissionDeployments
     * const count = await prisma.trainingMissionDeployment.count({
     *   where: {
     *     // ... the filter for the TrainingMissionDeployments we want to count
     *   }
     * })
    **/
    count<T extends TrainingMissionDeploymentCountArgs>(
      args?: Subset<T, TrainingMissionDeploymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingMissionDeploymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingMissionDeployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionDeploymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingMissionDeploymentAggregateArgs>(args: Subset<T, TrainingMissionDeploymentAggregateArgs>): Prisma.PrismaPromise<GetTrainingMissionDeploymentAggregateType<T>>

    /**
     * Group by TrainingMissionDeployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionDeploymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingMissionDeploymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingMissionDeploymentGroupByArgs['orderBy'] }
        : { orderBy?: TrainingMissionDeploymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingMissionDeploymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingMissionDeploymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingMissionDeployment model
   */
  readonly fields: TrainingMissionDeploymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingMissionDeployment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingMissionDeploymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameAgent<T extends GameAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameAgentDefaultArgs<ExtArgs>>): Prisma__GameAgentClient<$Result.GetResult<Prisma.$GameAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gameProxim8<T extends GameProxim8DefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameProxim8DefaultArgs<ExtArgs>>): Prisma__GameProxim8Client<$Result.GetResult<Prisma.$GameProxim8Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingMissionDeployment model
   */
  interface TrainingMissionDeploymentFieldRefs {
    readonly id: FieldRef<"TrainingMissionDeployment", 'String'>
    readonly deploymentId: FieldRef<"TrainingMissionDeployment", 'String'>
    readonly missionId: FieldRef<"TrainingMissionDeployment", 'String'>
    readonly gameAgentId: FieldRef<"TrainingMissionDeployment", 'String'>
    readonly gameProxim8Id: FieldRef<"TrainingMissionDeployment", 'String'>
    readonly approach: FieldRef<"TrainingMissionDeployment", 'MissionApproach'>
    readonly deployedAt: FieldRef<"TrainingMissionDeployment", 'DateTime'>
    readonly completesAt: FieldRef<"TrainingMissionDeployment", 'DateTime'>
    readonly duration: FieldRef<"TrainingMissionDeployment", 'Int'>
    readonly status: FieldRef<"TrainingMissionDeployment", 'DeploymentStatus'>
    readonly currentPhase: FieldRef<"TrainingMissionDeployment", 'Int'>
    readonly finalSuccessRate: FieldRef<"TrainingMissionDeployment", 'Float'>
    readonly phaseOutcomes: FieldRef<"TrainingMissionDeployment", 'Json'>
    readonly result: FieldRef<"TrainingMissionDeployment", 'Json'>
    readonly createdAt: FieldRef<"TrainingMissionDeployment", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingMissionDeployment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingMissionDeployment findUnique
   */
  export type TrainingMissionDeploymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingMissionDeployment to fetch.
     */
    where: TrainingMissionDeploymentWhereUniqueInput
  }

  /**
   * TrainingMissionDeployment findUniqueOrThrow
   */
  export type TrainingMissionDeploymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingMissionDeployment to fetch.
     */
    where: TrainingMissionDeploymentWhereUniqueInput
  }

  /**
   * TrainingMissionDeployment findFirst
   */
  export type TrainingMissionDeploymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingMissionDeployment to fetch.
     */
    where?: TrainingMissionDeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingMissionDeployments to fetch.
     */
    orderBy?: TrainingMissionDeploymentOrderByWithRelationInput | TrainingMissionDeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingMissionDeployments.
     */
    cursor?: TrainingMissionDeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingMissionDeployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingMissionDeployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingMissionDeployments.
     */
    distinct?: TrainingMissionDeploymentScalarFieldEnum | TrainingMissionDeploymentScalarFieldEnum[]
  }

  /**
   * TrainingMissionDeployment findFirstOrThrow
   */
  export type TrainingMissionDeploymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingMissionDeployment to fetch.
     */
    where?: TrainingMissionDeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingMissionDeployments to fetch.
     */
    orderBy?: TrainingMissionDeploymentOrderByWithRelationInput | TrainingMissionDeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingMissionDeployments.
     */
    cursor?: TrainingMissionDeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingMissionDeployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingMissionDeployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingMissionDeployments.
     */
    distinct?: TrainingMissionDeploymentScalarFieldEnum | TrainingMissionDeploymentScalarFieldEnum[]
  }

  /**
   * TrainingMissionDeployment findMany
   */
  export type TrainingMissionDeploymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingMissionDeployments to fetch.
     */
    where?: TrainingMissionDeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingMissionDeployments to fetch.
     */
    orderBy?: TrainingMissionDeploymentOrderByWithRelationInput | TrainingMissionDeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingMissionDeployments.
     */
    cursor?: TrainingMissionDeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingMissionDeployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingMissionDeployments.
     */
    skip?: number
    distinct?: TrainingMissionDeploymentScalarFieldEnum | TrainingMissionDeploymentScalarFieldEnum[]
  }

  /**
   * TrainingMissionDeployment create
   */
  export type TrainingMissionDeploymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingMissionDeployment.
     */
    data: XOR<TrainingMissionDeploymentCreateInput, TrainingMissionDeploymentUncheckedCreateInput>
  }

  /**
   * TrainingMissionDeployment createMany
   */
  export type TrainingMissionDeploymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingMissionDeployments.
     */
    data: TrainingMissionDeploymentCreateManyInput | TrainingMissionDeploymentCreateManyInput[]
  }

  /**
   * TrainingMissionDeployment update
   */
  export type TrainingMissionDeploymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingMissionDeployment.
     */
    data: XOR<TrainingMissionDeploymentUpdateInput, TrainingMissionDeploymentUncheckedUpdateInput>
    /**
     * Choose, which TrainingMissionDeployment to update.
     */
    where: TrainingMissionDeploymentWhereUniqueInput
  }

  /**
   * TrainingMissionDeployment updateMany
   */
  export type TrainingMissionDeploymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingMissionDeployments.
     */
    data: XOR<TrainingMissionDeploymentUpdateManyMutationInput, TrainingMissionDeploymentUncheckedUpdateManyInput>
    /**
     * Filter which TrainingMissionDeployments to update
     */
    where?: TrainingMissionDeploymentWhereInput
    /**
     * Limit how many TrainingMissionDeployments to update.
     */
    limit?: number
  }

  /**
   * TrainingMissionDeployment upsert
   */
  export type TrainingMissionDeploymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingMissionDeployment to update in case it exists.
     */
    where: TrainingMissionDeploymentWhereUniqueInput
    /**
     * In case the TrainingMissionDeployment found by the `where` argument doesn't exist, create a new TrainingMissionDeployment with this data.
     */
    create: XOR<TrainingMissionDeploymentCreateInput, TrainingMissionDeploymentUncheckedCreateInput>
    /**
     * In case the TrainingMissionDeployment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingMissionDeploymentUpdateInput, TrainingMissionDeploymentUncheckedUpdateInput>
  }

  /**
   * TrainingMissionDeployment delete
   */
  export type TrainingMissionDeploymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
    /**
     * Filter which TrainingMissionDeployment to delete.
     */
    where: TrainingMissionDeploymentWhereUniqueInput
  }

  /**
   * TrainingMissionDeployment deleteMany
   */
  export type TrainingMissionDeploymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingMissionDeployments to delete
     */
    where?: TrainingMissionDeploymentWhereInput
    /**
     * Limit how many TrainingMissionDeployments to delete.
     */
    limit?: number
  }

  /**
   * TrainingMissionDeployment findRaw
   */
  export type TrainingMissionDeploymentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TrainingMissionDeployment aggregateRaw
   */
  export type TrainingMissionDeploymentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TrainingMissionDeployment without action
   */
  export type TrainingMissionDeploymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMissionDeployment
     */
    select?: TrainingMissionDeploymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMissionDeployment
     */
    omit?: TrainingMissionDeploymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingMissionDeploymentInclude<ExtArgs> | null
  }


  /**
   * Model UserStats
   */

  export type AggregateUserStats = {
    _count: UserStatsCountAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  export type UserStatsMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStatsMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStatsCountAggregateOutputType = {
    id: number
    profileId: number
    stats: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserStatsMinAggregateInputType = {
    id?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStatsMaxAggregateInputType = {
    id?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStatsCountAggregateInputType = {
    id?: true
    profileId?: true
    stats?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to aggregate.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStats
    **/
    _count?: true | UserStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStatsMaxAggregateInputType
  }

  export type GetUserStatsAggregateType<T extends UserStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStats[P]>
      : GetScalarType<T[P], AggregateUserStats[P]>
  }




  export type UserStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatsWhereInput
    orderBy?: UserStatsOrderByWithAggregationInput | UserStatsOrderByWithAggregationInput[]
    by: UserStatsScalarFieldEnum[] | UserStatsScalarFieldEnum
    having?: UserStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStatsCountAggregateInputType | true
    _min?: UserStatsMinAggregateInputType
    _max?: UserStatsMaxAggregateInputType
  }

  export type UserStatsGroupByOutputType = {
    id: string
    profileId: string
    stats: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: UserStatsCountAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  type GetUserStatsGroupByPayload<T extends UserStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
            : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
        }
      >
    >


  export type UserStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    stats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userStats"]>



  export type UserStatsSelectScalar = {
    id?: boolean
    profileId?: boolean
    stats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "stats" | "createdAt" | "updatedAt", ExtArgs["result"]["userStats"]>

  export type $UserStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      stats: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userStats"]>
    composites: {}
  }

  type UserStatsGetPayload<S extends boolean | null | undefined | UserStatsDefaultArgs> = $Result.GetResult<Prisma.$UserStatsPayload, S>

  type UserStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStatsCountAggregateInputType | true
    }

  export interface UserStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStats'], meta: { name: 'UserStats' } }
    /**
     * Find zero or one UserStats that matches the filter.
     * @param {UserStatsFindUniqueArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStatsFindUniqueArgs>(args: SelectSubset<T, UserStatsFindUniqueArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStatsFindUniqueOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStatsFindFirstArgs>(args?: SelectSubset<T, UserStatsFindFirstArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStats
     * const userStats = await prisma.userStats.findMany()
     * 
     * // Get first 10 UserStats
     * const userStats = await prisma.userStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStatsWithIdOnly = await prisma.userStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserStatsFindManyArgs>(args?: SelectSubset<T, UserStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStats.
     * @param {UserStatsCreateArgs} args - Arguments to create a UserStats.
     * @example
     * // Create one UserStats
     * const UserStats = await prisma.userStats.create({
     *   data: {
     *     // ... data to create a UserStats
     *   }
     * })
     * 
     */
    create<T extends UserStatsCreateArgs>(args: SelectSubset<T, UserStatsCreateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStats.
     * @param {UserStatsCreateManyArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStatsCreateManyArgs>(args?: SelectSubset<T, UserStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserStats.
     * @param {UserStatsDeleteArgs} args - Arguments to delete one UserStats.
     * @example
     * // Delete one UserStats
     * const UserStats = await prisma.userStats.delete({
     *   where: {
     *     // ... filter to delete one UserStats
     *   }
     * })
     * 
     */
    delete<T extends UserStatsDeleteArgs>(args: SelectSubset<T, UserStatsDeleteArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStats.
     * @param {UserStatsUpdateArgs} args - Arguments to update one UserStats.
     * @example
     * // Update one UserStats
     * const userStats = await prisma.userStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStatsUpdateArgs>(args: SelectSubset<T, UserStatsUpdateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStats.
     * @param {UserStatsDeleteManyArgs} args - Arguments to filter UserStats to delete.
     * @example
     * // Delete a few UserStats
     * const { count } = await prisma.userStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStatsDeleteManyArgs>(args?: SelectSubset<T, UserStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStatsUpdateManyArgs>(args: SelectSubset<T, UserStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserStats.
     * @param {UserStatsUpsertArgs} args - Arguments to update or create a UserStats.
     * @example
     * // Update or create a UserStats
     * const userStats = await prisma.userStats.upsert({
     *   create: {
     *     // ... data to create a UserStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStats we want to update
     *   }
     * })
     */
    upsert<T extends UserStatsUpsertArgs>(args: SelectSubset<T, UserStatsUpsertArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStats that matches the filter.
     * @param {UserStatsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userStats = await prisma.userStats.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserStatsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserStats.
     * @param {UserStatsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userStats = await prisma.userStats.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserStatsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsCountArgs} args - Arguments to filter UserStats to count.
     * @example
     * // Count the number of UserStats
     * const count = await prisma.userStats.count({
     *   where: {
     *     // ... the filter for the UserStats we want to count
     *   }
     * })
    **/
    count<T extends UserStatsCountArgs>(
      args?: Subset<T, UserStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStatsAggregateArgs>(args: Subset<T, UserStatsAggregateArgs>): Prisma.PrismaPromise<GetUserStatsAggregateType<T>>

    /**
     * Group by UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStatsGroupByArgs['orderBy'] }
        : { orderBy?: UserStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStats model
   */
  readonly fields: UserStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStats model
   */
  interface UserStatsFieldRefs {
    readonly id: FieldRef<"UserStats", 'String'>
    readonly profileId: FieldRef<"UserStats", 'String'>
    readonly stats: FieldRef<"UserStats", 'Json'>
    readonly createdAt: FieldRef<"UserStats", 'DateTime'>
    readonly updatedAt: FieldRef<"UserStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserStats findUnique
   */
  export type UserStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findUniqueOrThrow
   */
  export type UserStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findFirst
   */
  export type UserStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findFirstOrThrow
   */
  export type UserStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findMany
   */
  export type UserStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats create
   */
  export type UserStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The data needed to create a UserStats.
     */
    data: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
  }

  /**
   * UserStats createMany
   */
  export type UserStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
  }

  /**
   * UserStats update
   */
  export type UserStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The data needed to update a UserStats.
     */
    data: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
    /**
     * Choose, which UserStats to update.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats updateMany
   */
  export type UserStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to update.
     */
    limit?: number
  }

  /**
   * UserStats upsert
   */
  export type UserStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The filter to search for the UserStats to update in case it exists.
     */
    where: UserStatsWhereUniqueInput
    /**
     * In case the UserStats found by the `where` argument doesn't exist, create a new UserStats with this data.
     */
    create: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
    /**
     * In case the UserStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
  }

  /**
   * UserStats delete
   */
  export type UserStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Filter which UserStats to delete.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats deleteMany
   */
  export type UserStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to delete
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to delete.
     */
    limit?: number
  }

  /**
   * UserStats findRaw
   */
  export type UserStatsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserStats aggregateRaw
   */
  export type UserStatsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserStats without action
   */
  export type UserStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
  }


  /**
   * Model NFT
   */

  export type AggregateNFT = {
    _count: NFTCountAggregateOutputType | null
    _min: NFTMinAggregateOutputType | null
    _max: NFTMaxAggregateOutputType | null
  }

  export type NFTMinAggregateOutputType = {
    id: string | null
    tokenId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NFTMaxAggregateOutputType = {
    id: string | null
    tokenId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NFTCountAggregateOutputType = {
    id: number
    tokenId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NFTMinAggregateInputType = {
    id?: true
    tokenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NFTMaxAggregateInputType = {
    id?: true
    tokenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NFTCountAggregateInputType = {
    id?: true
    tokenId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NFTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFT to aggregate.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NFTS
    **/
    _count?: true | NFTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NFTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NFTMaxAggregateInputType
  }

  export type GetNFTAggregateType<T extends NFTAggregateArgs> = {
        [P in keyof T & keyof AggregateNFT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNFT[P]>
      : GetScalarType<T[P], AggregateNFT[P]>
  }




  export type NFTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTWhereInput
    orderBy?: NFTOrderByWithAggregationInput | NFTOrderByWithAggregationInput[]
    by: NFTScalarFieldEnum[] | NFTScalarFieldEnum
    having?: NFTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NFTCountAggregateInputType | true
    _min?: NFTMinAggregateInputType
    _max?: NFTMaxAggregateInputType
  }

  export type NFTGroupByOutputType = {
    id: string
    tokenId: string
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: NFTCountAggregateOutputType | null
    _min: NFTMinAggregateOutputType | null
    _max: NFTMaxAggregateOutputType | null
  }

  type GetNFTGroupByPayload<T extends NFTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NFTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NFTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NFTGroupByOutputType[P]>
            : GetScalarType<T[P], NFTGroupByOutputType[P]>
        }
      >
    >


  export type NFTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nFT"]>



  export type NFTSelectScalar = {
    id?: boolean
    tokenId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NFTOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenId" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["nFT"]>

  export type $NFTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NFT"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tokenId: string
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nFT"]>
    composites: {}
  }

  type NFTGetPayload<S extends boolean | null | undefined | NFTDefaultArgs> = $Result.GetResult<Prisma.$NFTPayload, S>

  type NFTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NFTFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NFTCountAggregateInputType | true
    }

  export interface NFTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NFT'], meta: { name: 'NFT' } }
    /**
     * Find zero or one NFT that matches the filter.
     * @param {NFTFindUniqueArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NFTFindUniqueArgs>(args: SelectSubset<T, NFTFindUniqueArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NFT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NFTFindUniqueOrThrowArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NFTFindUniqueOrThrowArgs>(args: SelectSubset<T, NFTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindFirstArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NFTFindFirstArgs>(args?: SelectSubset<T, NFTFindFirstArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindFirstOrThrowArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NFTFindFirstOrThrowArgs>(args?: SelectSubset<T, NFTFindFirstOrThrowArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NFTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NFTS
     * const nFTS = await prisma.nFT.findMany()
     * 
     * // Get first 10 NFTS
     * const nFTS = await prisma.nFT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nFTWithIdOnly = await prisma.nFT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NFTFindManyArgs>(args?: SelectSubset<T, NFTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NFT.
     * @param {NFTCreateArgs} args - Arguments to create a NFT.
     * @example
     * // Create one NFT
     * const NFT = await prisma.nFT.create({
     *   data: {
     *     // ... data to create a NFT
     *   }
     * })
     * 
     */
    create<T extends NFTCreateArgs>(args: SelectSubset<T, NFTCreateArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NFTS.
     * @param {NFTCreateManyArgs} args - Arguments to create many NFTS.
     * @example
     * // Create many NFTS
     * const nFT = await prisma.nFT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NFTCreateManyArgs>(args?: SelectSubset<T, NFTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NFT.
     * @param {NFTDeleteArgs} args - Arguments to delete one NFT.
     * @example
     * // Delete one NFT
     * const NFT = await prisma.nFT.delete({
     *   where: {
     *     // ... filter to delete one NFT
     *   }
     * })
     * 
     */
    delete<T extends NFTDeleteArgs>(args: SelectSubset<T, NFTDeleteArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NFT.
     * @param {NFTUpdateArgs} args - Arguments to update one NFT.
     * @example
     * // Update one NFT
     * const nFT = await prisma.nFT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NFTUpdateArgs>(args: SelectSubset<T, NFTUpdateArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NFTS.
     * @param {NFTDeleteManyArgs} args - Arguments to filter NFTS to delete.
     * @example
     * // Delete a few NFTS
     * const { count } = await prisma.nFT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NFTDeleteManyArgs>(args?: SelectSubset<T, NFTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NFTS
     * const nFT = await prisma.nFT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NFTUpdateManyArgs>(args: SelectSubset<T, NFTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NFT.
     * @param {NFTUpsertArgs} args - Arguments to update or create a NFT.
     * @example
     * // Update or create a NFT
     * const nFT = await prisma.nFT.upsert({
     *   create: {
     *     // ... data to create a NFT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NFT we want to update
     *   }
     * })
     */
    upsert<T extends NFTUpsertArgs>(args: SelectSubset<T, NFTUpsertArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NFTS that matches the filter.
     * @param {NFTFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const nFT = await prisma.nFT.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NFTFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a NFT.
     * @param {NFTAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const nFT = await prisma.nFT.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NFTAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of NFTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTCountArgs} args - Arguments to filter NFTS to count.
     * @example
     * // Count the number of NFTS
     * const count = await prisma.nFT.count({
     *   where: {
     *     // ... the filter for the NFTS we want to count
     *   }
     * })
    **/
    count<T extends NFTCountArgs>(
      args?: Subset<T, NFTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NFTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NFT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NFTAggregateArgs>(args: Subset<T, NFTAggregateArgs>): Prisma.PrismaPromise<GetNFTAggregateType<T>>

    /**
     * Group by NFT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NFTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NFTGroupByArgs['orderBy'] }
        : { orderBy?: NFTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NFTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNFTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NFT model
   */
  readonly fields: NFTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NFT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NFTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NFT model
   */
  interface NFTFieldRefs {
    readonly id: FieldRef<"NFT", 'String'>
    readonly tokenId: FieldRef<"NFT", 'String'>
    readonly metadata: FieldRef<"NFT", 'Json'>
    readonly createdAt: FieldRef<"NFT", 'DateTime'>
    readonly updatedAt: FieldRef<"NFT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NFT findUnique
   */
  export type NFTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT findUniqueOrThrow
   */
  export type NFTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT findFirst
   */
  export type NFTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTS.
     */
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT findFirstOrThrow
   */
  export type NFTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTS.
     */
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT findMany
   */
  export type NFTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Filter, which NFTS to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT create
   */
  export type NFTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * The data needed to create a NFT.
     */
    data: XOR<NFTCreateInput, NFTUncheckedCreateInput>
  }

  /**
   * NFT createMany
   */
  export type NFTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NFTS.
     */
    data: NFTCreateManyInput | NFTCreateManyInput[]
  }

  /**
   * NFT update
   */
  export type NFTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * The data needed to update a NFT.
     */
    data: XOR<NFTUpdateInput, NFTUncheckedUpdateInput>
    /**
     * Choose, which NFT to update.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT updateMany
   */
  export type NFTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NFTS.
     */
    data: XOR<NFTUpdateManyMutationInput, NFTUncheckedUpdateManyInput>
    /**
     * Filter which NFTS to update
     */
    where?: NFTWhereInput
    /**
     * Limit how many NFTS to update.
     */
    limit?: number
  }

  /**
   * NFT upsert
   */
  export type NFTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * The filter to search for the NFT to update in case it exists.
     */
    where: NFTWhereUniqueInput
    /**
     * In case the NFT found by the `where` argument doesn't exist, create a new NFT with this data.
     */
    create: XOR<NFTCreateInput, NFTUncheckedCreateInput>
    /**
     * In case the NFT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NFTUpdateInput, NFTUncheckedUpdateInput>
  }

  /**
   * NFT delete
   */
  export type NFTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Filter which NFT to delete.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT deleteMany
   */
  export type NFTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTS to delete
     */
    where?: NFTWhereInput
    /**
     * Limit how many NFTS to delete.
     */
    limit?: number
  }

  /**
   * NFT findRaw
   */
  export type NFTFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * NFT aggregateRaw
   */
  export type NFTAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * NFT without action
   */
  export type NFTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
  }


  /**
   * Model TrainingMission
   */

  export type AggregateTrainingMission = {
    _count: TrainingMissionCountAggregateOutputType | null
    _min: TrainingMissionMinAggregateOutputType | null
    _max: TrainingMissionMaxAggregateOutputType | null
  }

  export type TrainingMissionMinAggregateOutputType = {
    id: string | null
    title: string | null
    status: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingMissionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    status: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingMissionCountAggregateOutputType = {
    id: number
    title: number
    status: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingMissionMinAggregateInputType = {
    id?: true
    title?: true
    status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingMissionMaxAggregateInputType = {
    id?: true
    title?: true
    status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingMissionCountAggregateInputType = {
    id?: true
    title?: true
    status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingMissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingMission to aggregate.
     */
    where?: TrainingMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingMissions to fetch.
     */
    orderBy?: TrainingMissionOrderByWithRelationInput | TrainingMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingMissions
    **/
    _count?: true | TrainingMissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingMissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingMissionMaxAggregateInputType
  }

  export type GetTrainingMissionAggregateType<T extends TrainingMissionAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingMission[P]>
      : GetScalarType<T[P], AggregateTrainingMission[P]>
  }




  export type TrainingMissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingMissionWhereInput
    orderBy?: TrainingMissionOrderByWithAggregationInput | TrainingMissionOrderByWithAggregationInput[]
    by: TrainingMissionScalarFieldEnum[] | TrainingMissionScalarFieldEnum
    having?: TrainingMissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingMissionCountAggregateInputType | true
    _min?: TrainingMissionMinAggregateInputType
    _max?: TrainingMissionMaxAggregateInputType
  }

  export type TrainingMissionGroupByOutputType = {
    id: string
    title: string
    status: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TrainingMissionCountAggregateOutputType | null
    _min: TrainingMissionMinAggregateOutputType | null
    _max: TrainingMissionMaxAggregateOutputType | null
  }

  type GetTrainingMissionGroupByPayload<T extends TrainingMissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingMissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingMissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingMissionGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingMissionGroupByOutputType[P]>
        }
      >
    >


  export type TrainingMissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingMission"]>



  export type TrainingMissionSelectScalar = {
    id?: boolean
    title?: boolean
    status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingMissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "status" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingMission"]>

  export type $TrainingMissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingMission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      status: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingMission"]>
    composites: {}
  }

  type TrainingMissionGetPayload<S extends boolean | null | undefined | TrainingMissionDefaultArgs> = $Result.GetResult<Prisma.$TrainingMissionPayload, S>

  type TrainingMissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingMissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingMissionCountAggregateInputType | true
    }

  export interface TrainingMissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingMission'], meta: { name: 'TrainingMission' } }
    /**
     * Find zero or one TrainingMission that matches the filter.
     * @param {TrainingMissionFindUniqueArgs} args - Arguments to find a TrainingMission
     * @example
     * // Get one TrainingMission
     * const trainingMission = await prisma.trainingMission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingMissionFindUniqueArgs>(args: SelectSubset<T, TrainingMissionFindUniqueArgs<ExtArgs>>): Prisma__TrainingMissionClient<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingMission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingMissionFindUniqueOrThrowArgs} args - Arguments to find a TrainingMission
     * @example
     * // Get one TrainingMission
     * const trainingMission = await prisma.trainingMission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingMissionFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingMissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingMissionClient<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingMission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionFindFirstArgs} args - Arguments to find a TrainingMission
     * @example
     * // Get one TrainingMission
     * const trainingMission = await prisma.trainingMission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingMissionFindFirstArgs>(args?: SelectSubset<T, TrainingMissionFindFirstArgs<ExtArgs>>): Prisma__TrainingMissionClient<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingMission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionFindFirstOrThrowArgs} args - Arguments to find a TrainingMission
     * @example
     * // Get one TrainingMission
     * const trainingMission = await prisma.trainingMission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingMissionFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingMissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingMissionClient<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingMissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingMissions
     * const trainingMissions = await prisma.trainingMission.findMany()
     * 
     * // Get first 10 TrainingMissions
     * const trainingMissions = await prisma.trainingMission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingMissionWithIdOnly = await prisma.trainingMission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingMissionFindManyArgs>(args?: SelectSubset<T, TrainingMissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingMission.
     * @param {TrainingMissionCreateArgs} args - Arguments to create a TrainingMission.
     * @example
     * // Create one TrainingMission
     * const TrainingMission = await prisma.trainingMission.create({
     *   data: {
     *     // ... data to create a TrainingMission
     *   }
     * })
     * 
     */
    create<T extends TrainingMissionCreateArgs>(args: SelectSubset<T, TrainingMissionCreateArgs<ExtArgs>>): Prisma__TrainingMissionClient<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingMissions.
     * @param {TrainingMissionCreateManyArgs} args - Arguments to create many TrainingMissions.
     * @example
     * // Create many TrainingMissions
     * const trainingMission = await prisma.trainingMission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingMissionCreateManyArgs>(args?: SelectSubset<T, TrainingMissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingMission.
     * @param {TrainingMissionDeleteArgs} args - Arguments to delete one TrainingMission.
     * @example
     * // Delete one TrainingMission
     * const TrainingMission = await prisma.trainingMission.delete({
     *   where: {
     *     // ... filter to delete one TrainingMission
     *   }
     * })
     * 
     */
    delete<T extends TrainingMissionDeleteArgs>(args: SelectSubset<T, TrainingMissionDeleteArgs<ExtArgs>>): Prisma__TrainingMissionClient<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingMission.
     * @param {TrainingMissionUpdateArgs} args - Arguments to update one TrainingMission.
     * @example
     * // Update one TrainingMission
     * const trainingMission = await prisma.trainingMission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingMissionUpdateArgs>(args: SelectSubset<T, TrainingMissionUpdateArgs<ExtArgs>>): Prisma__TrainingMissionClient<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingMissions.
     * @param {TrainingMissionDeleteManyArgs} args - Arguments to filter TrainingMissions to delete.
     * @example
     * // Delete a few TrainingMissions
     * const { count } = await prisma.trainingMission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingMissionDeleteManyArgs>(args?: SelectSubset<T, TrainingMissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingMissions
     * const trainingMission = await prisma.trainingMission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingMissionUpdateManyArgs>(args: SelectSubset<T, TrainingMissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingMission.
     * @param {TrainingMissionUpsertArgs} args - Arguments to update or create a TrainingMission.
     * @example
     * // Update or create a TrainingMission
     * const trainingMission = await prisma.trainingMission.upsert({
     *   create: {
     *     // ... data to create a TrainingMission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingMission we want to update
     *   }
     * })
     */
    upsert<T extends TrainingMissionUpsertArgs>(args: SelectSubset<T, TrainingMissionUpsertArgs<ExtArgs>>): Prisma__TrainingMissionClient<$Result.GetResult<Prisma.$TrainingMissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingMissions that matches the filter.
     * @param {TrainingMissionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const trainingMission = await prisma.trainingMission.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TrainingMissionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TrainingMission.
     * @param {TrainingMissionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const trainingMission = await prisma.trainingMission.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TrainingMissionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TrainingMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionCountArgs} args - Arguments to filter TrainingMissions to count.
     * @example
     * // Count the number of TrainingMissions
     * const count = await prisma.trainingMission.count({
     *   where: {
     *     // ... the filter for the TrainingMissions we want to count
     *   }
     * })
    **/
    count<T extends TrainingMissionCountArgs>(
      args?: Subset<T, TrainingMissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingMissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingMissionAggregateArgs>(args: Subset<T, TrainingMissionAggregateArgs>): Prisma.PrismaPromise<GetTrainingMissionAggregateType<T>>

    /**
     * Group by TrainingMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingMissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingMissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingMissionGroupByArgs['orderBy'] }
        : { orderBy?: TrainingMissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingMissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingMission model
   */
  readonly fields: TrainingMissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingMission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingMissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingMission model
   */
  interface TrainingMissionFieldRefs {
    readonly id: FieldRef<"TrainingMission", 'String'>
    readonly title: FieldRef<"TrainingMission", 'String'>
    readonly status: FieldRef<"TrainingMission", 'String'>
    readonly isActive: FieldRef<"TrainingMission", 'Boolean'>
    readonly createdAt: FieldRef<"TrainingMission", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingMission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingMission findUnique
   */
  export type TrainingMissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * Filter, which TrainingMission to fetch.
     */
    where: TrainingMissionWhereUniqueInput
  }

  /**
   * TrainingMission findUniqueOrThrow
   */
  export type TrainingMissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * Filter, which TrainingMission to fetch.
     */
    where: TrainingMissionWhereUniqueInput
  }

  /**
   * TrainingMission findFirst
   */
  export type TrainingMissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * Filter, which TrainingMission to fetch.
     */
    where?: TrainingMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingMissions to fetch.
     */
    orderBy?: TrainingMissionOrderByWithRelationInput | TrainingMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingMissions.
     */
    cursor?: TrainingMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingMissions.
     */
    distinct?: TrainingMissionScalarFieldEnum | TrainingMissionScalarFieldEnum[]
  }

  /**
   * TrainingMission findFirstOrThrow
   */
  export type TrainingMissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * Filter, which TrainingMission to fetch.
     */
    where?: TrainingMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingMissions to fetch.
     */
    orderBy?: TrainingMissionOrderByWithRelationInput | TrainingMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingMissions.
     */
    cursor?: TrainingMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingMissions.
     */
    distinct?: TrainingMissionScalarFieldEnum | TrainingMissionScalarFieldEnum[]
  }

  /**
   * TrainingMission findMany
   */
  export type TrainingMissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * Filter, which TrainingMissions to fetch.
     */
    where?: TrainingMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingMissions to fetch.
     */
    orderBy?: TrainingMissionOrderByWithRelationInput | TrainingMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingMissions.
     */
    cursor?: TrainingMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingMissions.
     */
    skip?: number
    distinct?: TrainingMissionScalarFieldEnum | TrainingMissionScalarFieldEnum[]
  }

  /**
   * TrainingMission create
   */
  export type TrainingMissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * The data needed to create a TrainingMission.
     */
    data: XOR<TrainingMissionCreateInput, TrainingMissionUncheckedCreateInput>
  }

  /**
   * TrainingMission createMany
   */
  export type TrainingMissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingMissions.
     */
    data: TrainingMissionCreateManyInput | TrainingMissionCreateManyInput[]
  }

  /**
   * TrainingMission update
   */
  export type TrainingMissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * The data needed to update a TrainingMission.
     */
    data: XOR<TrainingMissionUpdateInput, TrainingMissionUncheckedUpdateInput>
    /**
     * Choose, which TrainingMission to update.
     */
    where: TrainingMissionWhereUniqueInput
  }

  /**
   * TrainingMission updateMany
   */
  export type TrainingMissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingMissions.
     */
    data: XOR<TrainingMissionUpdateManyMutationInput, TrainingMissionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingMissions to update
     */
    where?: TrainingMissionWhereInput
    /**
     * Limit how many TrainingMissions to update.
     */
    limit?: number
  }

  /**
   * TrainingMission upsert
   */
  export type TrainingMissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * The filter to search for the TrainingMission to update in case it exists.
     */
    where: TrainingMissionWhereUniqueInput
    /**
     * In case the TrainingMission found by the `where` argument doesn't exist, create a new TrainingMission with this data.
     */
    create: XOR<TrainingMissionCreateInput, TrainingMissionUncheckedCreateInput>
    /**
     * In case the TrainingMission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingMissionUpdateInput, TrainingMissionUncheckedUpdateInput>
  }

  /**
   * TrainingMission delete
   */
  export type TrainingMissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
    /**
     * Filter which TrainingMission to delete.
     */
    where: TrainingMissionWhereUniqueInput
  }

  /**
   * TrainingMission deleteMany
   */
  export type TrainingMissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingMissions to delete
     */
    where?: TrainingMissionWhereInput
    /**
     * Limit how many TrainingMissions to delete.
     */
    limit?: number
  }

  /**
   * TrainingMission findRaw
   */
  export type TrainingMissionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TrainingMission aggregateRaw
   */
  export type TrainingMissionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TrainingMission without action
   */
  export type TrainingMissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingMission
     */
    select?: TrainingMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingMission
     */
    omit?: TrainingMissionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const AccountScalarFieldEnum: {
    id: 'id',
    walletAddress: 'walletAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    username: 'username',
    bio: 'bio',
    avatar: 'avatar',
    isPublic: 'isPublic',
    socialLinks: 'socialLinks',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const FingerprintScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    fingerprint: 'fingerprint',
    roles: 'roles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FingerprintScalarFieldEnum = (typeof FingerprintScalarFieldEnum)[keyof typeof FingerprintScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    name: 'name',
    description: 'description',
    avatar: 'avatar',
    isActive: 'isActive',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const VisitScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    fingerprintId: 'fingerprintId',
    path: 'path',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    referrer: 'referrer',
    duration: 'duration',
    createdAt: 'createdAt'
  };

  export type VisitScalarFieldEnum = (typeof VisitScalarFieldEnum)[keyof typeof VisitScalarFieldEnum]


  export const ImpressionScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    type: 'type',
    context: 'context',
    createdAt: 'createdAt'
  };

  export type ImpressionScalarFieldEnum = (typeof ImpressionScalarFieldEnum)[keyof typeof ImpressionScalarFieldEnum]


  export const SocialProfileScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    platform: 'platform',
    username: 'username',
    url: 'url',
    verified: 'verified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialProfileScalarFieldEnum = (typeof SocialProfileScalarFieldEnum)[keyof typeof SocialProfileScalarFieldEnum]


  export const KnowledgeScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    title: 'title',
    content: 'content',
    type: 'type',
    source: 'source',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeScalarFieldEnum = (typeof KnowledgeScalarFieldEnum)[keyof typeof KnowledgeScalarFieldEnum]


  export const MissionScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    result: 'result',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MissionScalarFieldEnum = (typeof MissionScalarFieldEnum)[keyof typeof MissionScalarFieldEnum]


  export const Proxim8UserScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    username: 'username',
    email: 'email',
    bio: 'bio',
    avatar: 'avatar',
    isPublic: 'isPublic',
    isAdmin: 'isAdmin',
    socialLinks: 'socialLinks',
    preferences: 'preferences',
    stats: 'stats',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Proxim8UserScalarFieldEnum = (typeof Proxim8UserScalarFieldEnum)[keyof typeof Proxim8UserScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    nftId: 'nftId',
    jobId: 'jobId',
    status: 'status',
    title: 'title',
    description: 'description',
    videoUrl: 'videoUrl',
    thumbnailUrl: 'thumbnailUrl',
    duration: 'duration',
    fileSize: 'fileSize',
    resolution: 'resolution',
    isPublic: 'isPublic',
    metadata: 'metadata',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NFTOwnershipScalarFieldEnum: {
    id: 'id',
    nftId: 'nftId',
    accountId: 'accountId',
    walletAddress: 'walletAddress',
    contractAddress: 'contractAddress',
    tokenId: 'tokenId',
    blockchain: 'blockchain',
    verified: 'verified',
    lastVerified: 'lastVerified',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NFTOwnershipScalarFieldEnum = (typeof NFTOwnershipScalarFieldEnum)[keyof typeof NFTOwnershipScalarFieldEnum]


  export const LoreScalarFieldEnum: {
    id: 'id',
    nftId: 'nftId',
    title: 'title',
    content: 'content',
    background: 'background',
    traits: 'traits',
    claimed: 'claimed',
    claimedBy: 'claimedBy',
    claimedAt: 'claimedAt',
    category: 'category',
    tags: 'tags',
    isPublic: 'isPublic',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoreScalarFieldEnum = (typeof LoreScalarFieldEnum)[keyof typeof LoreScalarFieldEnum]


  export const PipelineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    status: 'status',
    config: 'config',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PipelineScalarFieldEnum = (typeof PipelineScalarFieldEnum)[keyof typeof PipelineScalarFieldEnum]


  export const PublicVideoScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    title: 'title',
    description: 'description',
    thumbnailUrl: 'thumbnailUrl',
    videoUrl: 'videoUrl',
    nftId: 'nftId',
    walletAddress: 'walletAddress',
    views: 'views',
    likes: 'likes',
    featured: 'featured',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PublicVideoScalarFieldEnum = (typeof PublicVideoScalarFieldEnum)[keyof typeof PublicVideoScalarFieldEnum]


  export const GameAgentScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    codename: 'codename',
    rank: 'rank',
    timelinePoints: 'timelinePoints',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameAgentScalarFieldEnum = (typeof GameAgentScalarFieldEnum)[keyof typeof GameAgentScalarFieldEnum]


  export const GameProxim8ScalarFieldEnum: {
    id: 'id',
    gameAgentId: 'gameAgentId',
    nftId: 'nftId',
    name: 'name',
    personality: 'personality',
    level: 'level',
    experience: 'experience',
    isDeployed: 'isDeployed',
    lastMissionAt: 'lastMissionAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameProxim8ScalarFieldEnum = (typeof GameProxim8ScalarFieldEnum)[keyof typeof GameProxim8ScalarFieldEnum]


  export const TrainingMissionDeploymentScalarFieldEnum: {
    id: 'id',
    deploymentId: 'deploymentId',
    missionId: 'missionId',
    gameAgentId: 'gameAgentId',
    gameProxim8Id: 'gameProxim8Id',
    approach: 'approach',
    deployedAt: 'deployedAt',
    completesAt: 'completesAt',
    duration: 'duration',
    status: 'status',
    currentPhase: 'currentPhase',
    finalSuccessRate: 'finalSuccessRate',
    phaseOutcomes: 'phaseOutcomes',
    result: 'result',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingMissionDeploymentScalarFieldEnum = (typeof TrainingMissionDeploymentScalarFieldEnum)[keyof typeof TrainingMissionDeploymentScalarFieldEnum]


  export const UserStatsScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    stats: 'stats',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserStatsScalarFieldEnum = (typeof UserStatsScalarFieldEnum)[keyof typeof UserStatsScalarFieldEnum]


  export const NFTScalarFieldEnum: {
    id: 'id',
    tokenId: 'tokenId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NFTScalarFieldEnum = (typeof NFTScalarFieldEnum)[keyof typeof NFTScalarFieldEnum]


  export const TrainingMissionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    status: 'status',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingMissionScalarFieldEnum = (typeof TrainingMissionScalarFieldEnum)[keyof typeof TrainingMissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MissionStatus'
   */
  export type EnumMissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MissionStatus'>
    


  /**
   * Reference to a field of type 'MissionStatus[]'
   */
  export type ListEnumMissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MissionStatus[]'>
    


  /**
   * Reference to a field of type 'VideoStatus'
   */
  export type EnumVideoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoStatus'>
    


  /**
   * Reference to a field of type 'VideoStatus[]'
   */
  export type ListEnumVideoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'PipelineType'
   */
  export type EnumPipelineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PipelineType'>
    


  /**
   * Reference to a field of type 'PipelineType[]'
   */
  export type ListEnumPipelineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PipelineType[]'>
    


  /**
   * Reference to a field of type 'PipelineStatus'
   */
  export type EnumPipelineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PipelineStatus'>
    


  /**
   * Reference to a field of type 'PipelineStatus[]'
   */
  export type ListEnumPipelineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PipelineStatus[]'>
    


  /**
   * Reference to a field of type 'AgentRank'
   */
  export type EnumAgentRankFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentRank'>
    


  /**
   * Reference to a field of type 'AgentRank[]'
   */
  export type ListEnumAgentRankFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentRank[]'>
    


  /**
   * Reference to a field of type 'Proxim8Personality'
   */
  export type EnumProxim8PersonalityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Proxim8Personality'>
    


  /**
   * Reference to a field of type 'Proxim8Personality[]'
   */
  export type ListEnumProxim8PersonalityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Proxim8Personality[]'>
    


  /**
   * Reference to a field of type 'MissionApproach'
   */
  export type EnumMissionApproachFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MissionApproach'>
    


  /**
   * Reference to a field of type 'MissionApproach[]'
   */
  export type ListEnumMissionApproachFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MissionApproach[]'>
    


  /**
   * Reference to a field of type 'DeploymentStatus'
   */
  export type EnumDeploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeploymentStatus'>
    


  /**
   * Reference to a field of type 'DeploymentStatus[]'
   */
  export type ListEnumDeploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeploymentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    walletAddress?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    profiles?: ProfileListRelationFilter
    fingerprints?: FingerprintListRelationFilter
    agents?: AgentListRelationFilter
    videos?: VideoListRelationFilter
    notifications?: NotificationListRelationFilter
    nftOwnerships?: NFTOwnershipListRelationFilter
    proxim8User?: XOR<Proxim8UserNullableScalarRelationFilter, Proxim8UserWhereInput> | null
    gameAgent?: XOR<GameAgentNullableScalarRelationFilter, GameAgentWhereInput> | null
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profiles?: ProfileOrderByRelationAggregateInput
    fingerprints?: FingerprintOrderByRelationAggregateInput
    agents?: AgentOrderByRelationAggregateInput
    videos?: VideoOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    nftOwnerships?: NFTOwnershipOrderByRelationAggregateInput
    proxim8User?: Proxim8UserOrderByWithRelationInput
    gameAgent?: GameAgentOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    walletAddress?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    profiles?: ProfileListRelationFilter
    fingerprints?: FingerprintListRelationFilter
    agents?: AgentListRelationFilter
    videos?: VideoListRelationFilter
    notifications?: NotificationListRelationFilter
    nftOwnerships?: NFTOwnershipListRelationFilter
    proxim8User?: XOR<Proxim8UserNullableScalarRelationFilter, Proxim8UserWhereInput> | null
    gameAgent?: XOR<GameAgentNullableScalarRelationFilter, GameAgentWhereInput> | null
  }, "id" | "walletAddress">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    walletAddress?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    accountId?: StringFilter<"Profile"> | string
    username?: StringFilter<"Profile"> | string
    bio?: StringNullableFilter<"Profile"> | string | null
    avatar?: StringNullableFilter<"Profile"> | string | null
    isPublic?: BoolFilter<"Profile"> | boolean
    socialLinks?: JsonNullableFilter<"Profile">
    preferences?: JsonNullableFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    visits?: VisitListRelationFilter
    impressions?: ImpressionListRelationFilter
    socialProfiles?: SocialProfileListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    socialLinks?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    visits?: VisitOrderByRelationAggregateInput
    impressions?: ImpressionOrderByRelationAggregateInput
    socialProfiles?: SocialProfileOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    accountId?: StringFilter<"Profile"> | string
    bio?: StringNullableFilter<"Profile"> | string | null
    avatar?: StringNullableFilter<"Profile"> | string | null
    isPublic?: BoolFilter<"Profile"> | boolean
    socialLinks?: JsonNullableFilter<"Profile">
    preferences?: JsonNullableFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    visits?: VisitListRelationFilter
    impressions?: ImpressionListRelationFilter
    socialProfiles?: SocialProfileListRelationFilter
  }, "id" | "username">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    socialLinks?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    accountId?: StringWithAggregatesFilter<"Profile"> | string
    username?: StringWithAggregatesFilter<"Profile"> | string
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Profile"> | boolean
    socialLinks?: JsonNullableWithAggregatesFilter<"Profile">
    preferences?: JsonNullableWithAggregatesFilter<"Profile">
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type FingerprintWhereInput = {
    AND?: FingerprintWhereInput | FingerprintWhereInput[]
    OR?: FingerprintWhereInput[]
    NOT?: FingerprintWhereInput | FingerprintWhereInput[]
    id?: StringFilter<"Fingerprint"> | string
    accountId?: StringNullableFilter<"Fingerprint"> | string | null
    fingerprint?: StringFilter<"Fingerprint"> | string
    roles?: StringNullableListFilter<"Fingerprint">
    createdAt?: DateTimeFilter<"Fingerprint"> | Date | string
    updatedAt?: DateTimeFilter<"Fingerprint"> | Date | string
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    visits?: VisitListRelationFilter
  }

  export type FingerprintOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    fingerprint?: SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    visits?: VisitOrderByRelationAggregateInput
  }

  export type FingerprintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fingerprint?: string
    AND?: FingerprintWhereInput | FingerprintWhereInput[]
    OR?: FingerprintWhereInput[]
    NOT?: FingerprintWhereInput | FingerprintWhereInput[]
    accountId?: StringNullableFilter<"Fingerprint"> | string | null
    roles?: StringNullableListFilter<"Fingerprint">
    createdAt?: DateTimeFilter<"Fingerprint"> | Date | string
    updatedAt?: DateTimeFilter<"Fingerprint"> | Date | string
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    visits?: VisitListRelationFilter
  }, "id" | "fingerprint">

  export type FingerprintOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    fingerprint?: SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FingerprintCountOrderByAggregateInput
    _max?: FingerprintMaxOrderByAggregateInput
    _min?: FingerprintMinOrderByAggregateInput
  }

  export type FingerprintScalarWhereWithAggregatesInput = {
    AND?: FingerprintScalarWhereWithAggregatesInput | FingerprintScalarWhereWithAggregatesInput[]
    OR?: FingerprintScalarWhereWithAggregatesInput[]
    NOT?: FingerprintScalarWhereWithAggregatesInput | FingerprintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fingerprint"> | string
    accountId?: StringNullableWithAggregatesFilter<"Fingerprint"> | string | null
    fingerprint?: StringWithAggregatesFilter<"Fingerprint"> | string
    roles?: StringNullableListFilter<"Fingerprint">
    createdAt?: DateTimeWithAggregatesFilter<"Fingerprint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fingerprint"> | Date | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    accountId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    avatar?: StringNullableFilter<"Agent"> | string | null
    isActive?: BoolFilter<"Agent"> | boolean
    config?: JsonNullableFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    knowledge?: KnowledgeListRelationFilter
    missions?: MissionListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    knowledge?: KnowledgeOrderByRelationAggregateInput
    missions?: MissionOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    accountId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    avatar?: StringNullableFilter<"Agent"> | string | null
    isActive?: BoolFilter<"Agent"> | boolean
    config?: JsonNullableFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    knowledge?: KnowledgeListRelationFilter
    missions?: MissionListRelationFilter
  }, "id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    accountId?: StringWithAggregatesFilter<"Agent"> | string
    name?: StringWithAggregatesFilter<"Agent"> | string
    description?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    isActive?: BoolWithAggregatesFilter<"Agent"> | boolean
    config?: JsonNullableWithAggregatesFilter<"Agent">
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type VisitWhereInput = {
    AND?: VisitWhereInput | VisitWhereInput[]
    OR?: VisitWhereInput[]
    NOT?: VisitWhereInput | VisitWhereInput[]
    id?: StringFilter<"Visit"> | string
    profileId?: StringNullableFilter<"Visit"> | string | null
    fingerprintId?: StringFilter<"Visit"> | string
    path?: StringFilter<"Visit"> | string
    userAgent?: StringNullableFilter<"Visit"> | string | null
    ipAddress?: StringNullableFilter<"Visit"> | string | null
    referrer?: StringNullableFilter<"Visit"> | string | null
    duration?: IntNullableFilter<"Visit"> | number | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    fingerprint?: XOR<FingerprintScalarRelationFilter, FingerprintWhereInput>
  }

  export type VisitOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    fingerprintId?: SortOrder
    path?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referrer?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    fingerprint?: FingerprintOrderByWithRelationInput
  }

  export type VisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitWhereInput | VisitWhereInput[]
    OR?: VisitWhereInput[]
    NOT?: VisitWhereInput | VisitWhereInput[]
    profileId?: StringNullableFilter<"Visit"> | string | null
    fingerprintId?: StringFilter<"Visit"> | string
    path?: StringFilter<"Visit"> | string
    userAgent?: StringNullableFilter<"Visit"> | string | null
    ipAddress?: StringNullableFilter<"Visit"> | string | null
    referrer?: StringNullableFilter<"Visit"> | string | null
    duration?: IntNullableFilter<"Visit"> | number | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    fingerprint?: XOR<FingerprintScalarRelationFilter, FingerprintWhereInput>
  }, "id">

  export type VisitOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    fingerprintId?: SortOrder
    path?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referrer?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    _count?: VisitCountOrderByAggregateInput
    _avg?: VisitAvgOrderByAggregateInput
    _max?: VisitMaxOrderByAggregateInput
    _min?: VisitMinOrderByAggregateInput
    _sum?: VisitSumOrderByAggregateInput
  }

  export type VisitScalarWhereWithAggregatesInput = {
    AND?: VisitScalarWhereWithAggregatesInput | VisitScalarWhereWithAggregatesInput[]
    OR?: VisitScalarWhereWithAggregatesInput[]
    NOT?: VisitScalarWhereWithAggregatesInput | VisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Visit"> | string
    profileId?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    fingerprintId?: StringWithAggregatesFilter<"Visit"> | string
    path?: StringWithAggregatesFilter<"Visit"> | string
    userAgent?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Visit"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
  }

  export type ImpressionWhereInput = {
    AND?: ImpressionWhereInput | ImpressionWhereInput[]
    OR?: ImpressionWhereInput[]
    NOT?: ImpressionWhereInput | ImpressionWhereInput[]
    id?: StringFilter<"Impression"> | string
    profileId?: StringFilter<"Impression"> | string
    type?: StringFilter<"Impression"> | string
    context?: JsonNullableFilter<"Impression">
    createdAt?: DateTimeFilter<"Impression"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ImpressionOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type ImpressionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImpressionWhereInput | ImpressionWhereInput[]
    OR?: ImpressionWhereInput[]
    NOT?: ImpressionWhereInput | ImpressionWhereInput[]
    profileId?: StringFilter<"Impression"> | string
    type?: StringFilter<"Impression"> | string
    context?: JsonNullableFilter<"Impression">
    createdAt?: DateTimeFilter<"Impression"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type ImpressionOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    _count?: ImpressionCountOrderByAggregateInput
    _max?: ImpressionMaxOrderByAggregateInput
    _min?: ImpressionMinOrderByAggregateInput
  }

  export type ImpressionScalarWhereWithAggregatesInput = {
    AND?: ImpressionScalarWhereWithAggregatesInput | ImpressionScalarWhereWithAggregatesInput[]
    OR?: ImpressionScalarWhereWithAggregatesInput[]
    NOT?: ImpressionScalarWhereWithAggregatesInput | ImpressionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Impression"> | string
    profileId?: StringWithAggregatesFilter<"Impression"> | string
    type?: StringWithAggregatesFilter<"Impression"> | string
    context?: JsonNullableWithAggregatesFilter<"Impression">
    createdAt?: DateTimeWithAggregatesFilter<"Impression"> | Date | string
  }

  export type SocialProfileWhereInput = {
    AND?: SocialProfileWhereInput | SocialProfileWhereInput[]
    OR?: SocialProfileWhereInput[]
    NOT?: SocialProfileWhereInput | SocialProfileWhereInput[]
    id?: StringFilter<"SocialProfile"> | string
    profileId?: StringFilter<"SocialProfile"> | string
    platform?: StringFilter<"SocialProfile"> | string
    username?: StringFilter<"SocialProfile"> | string
    url?: StringNullableFilter<"SocialProfile"> | string | null
    verified?: BoolFilter<"SocialProfile"> | boolean
    createdAt?: DateTimeFilter<"SocialProfile"> | Date | string
    updatedAt?: DateTimeFilter<"SocialProfile"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type SocialProfileOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    url?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type SocialProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_platform?: SocialProfileProfileIdPlatformCompoundUniqueInput
    AND?: SocialProfileWhereInput | SocialProfileWhereInput[]
    OR?: SocialProfileWhereInput[]
    NOT?: SocialProfileWhereInput | SocialProfileWhereInput[]
    profileId?: StringFilter<"SocialProfile"> | string
    platform?: StringFilter<"SocialProfile"> | string
    username?: StringFilter<"SocialProfile"> | string
    url?: StringNullableFilter<"SocialProfile"> | string | null
    verified?: BoolFilter<"SocialProfile"> | boolean
    createdAt?: DateTimeFilter<"SocialProfile"> | Date | string
    updatedAt?: DateTimeFilter<"SocialProfile"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "profileId_platform">

  export type SocialProfileOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    url?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialProfileCountOrderByAggregateInput
    _max?: SocialProfileMaxOrderByAggregateInput
    _min?: SocialProfileMinOrderByAggregateInput
  }

  export type SocialProfileScalarWhereWithAggregatesInput = {
    AND?: SocialProfileScalarWhereWithAggregatesInput | SocialProfileScalarWhereWithAggregatesInput[]
    OR?: SocialProfileScalarWhereWithAggregatesInput[]
    NOT?: SocialProfileScalarWhereWithAggregatesInput | SocialProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialProfile"> | string
    profileId?: StringWithAggregatesFilter<"SocialProfile"> | string
    platform?: StringWithAggregatesFilter<"SocialProfile"> | string
    username?: StringWithAggregatesFilter<"SocialProfile"> | string
    url?: StringNullableWithAggregatesFilter<"SocialProfile"> | string | null
    verified?: BoolWithAggregatesFilter<"SocialProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SocialProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialProfile"> | Date | string
  }

  export type KnowledgeWhereInput = {
    AND?: KnowledgeWhereInput | KnowledgeWhereInput[]
    OR?: KnowledgeWhereInput[]
    NOT?: KnowledgeWhereInput | KnowledgeWhereInput[]
    id?: StringFilter<"Knowledge"> | string
    agentId?: StringFilter<"Knowledge"> | string
    title?: StringFilter<"Knowledge"> | string
    content?: StringFilter<"Knowledge"> | string
    type?: StringFilter<"Knowledge"> | string
    source?: StringNullableFilter<"Knowledge"> | string | null
    metadata?: JsonNullableFilter<"Knowledge">
    createdAt?: DateTimeFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeFilter<"Knowledge"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type KnowledgeOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type KnowledgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeWhereInput | KnowledgeWhereInput[]
    OR?: KnowledgeWhereInput[]
    NOT?: KnowledgeWhereInput | KnowledgeWhereInput[]
    agentId?: StringFilter<"Knowledge"> | string
    title?: StringFilter<"Knowledge"> | string
    content?: StringFilter<"Knowledge"> | string
    type?: StringFilter<"Knowledge"> | string
    source?: StringNullableFilter<"Knowledge"> | string | null
    metadata?: JsonNullableFilter<"Knowledge">
    createdAt?: DateTimeFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeFilter<"Knowledge"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type KnowledgeOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeCountOrderByAggregateInput
    _max?: KnowledgeMaxOrderByAggregateInput
    _min?: KnowledgeMinOrderByAggregateInput
  }

  export type KnowledgeScalarWhereWithAggregatesInput = {
    AND?: KnowledgeScalarWhereWithAggregatesInput | KnowledgeScalarWhereWithAggregatesInput[]
    OR?: KnowledgeScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeScalarWhereWithAggregatesInput | KnowledgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Knowledge"> | string
    agentId?: StringWithAggregatesFilter<"Knowledge"> | string
    title?: StringWithAggregatesFilter<"Knowledge"> | string
    content?: StringWithAggregatesFilter<"Knowledge"> | string
    type?: StringWithAggregatesFilter<"Knowledge"> | string
    source?: StringNullableWithAggregatesFilter<"Knowledge"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Knowledge">
    createdAt?: DateTimeWithAggregatesFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Knowledge"> | Date | string
  }

  export type MissionWhereInput = {
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    id?: StringFilter<"Mission"> | string
    agentId?: StringFilter<"Mission"> | string
    title?: StringFilter<"Mission"> | string
    description?: StringFilter<"Mission"> | string
    status?: EnumMissionStatusFilter<"Mission"> | $Enums.MissionStatus
    priority?: IntFilter<"Mission"> | number
    dueDate?: DateTimeNullableFilter<"Mission"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Mission"> | Date | string | null
    result?: JsonNullableFilter<"Mission">
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type MissionOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type MissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    agentId?: StringFilter<"Mission"> | string
    title?: StringFilter<"Mission"> | string
    description?: StringFilter<"Mission"> | string
    status?: EnumMissionStatusFilter<"Mission"> | $Enums.MissionStatus
    priority?: IntFilter<"Mission"> | number
    dueDate?: DateTimeNullableFilter<"Mission"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Mission"> | Date | string | null
    result?: JsonNullableFilter<"Mission">
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type MissionOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MissionCountOrderByAggregateInput
    _avg?: MissionAvgOrderByAggregateInput
    _max?: MissionMaxOrderByAggregateInput
    _min?: MissionMinOrderByAggregateInput
    _sum?: MissionSumOrderByAggregateInput
  }

  export type MissionScalarWhereWithAggregatesInput = {
    AND?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    OR?: MissionScalarWhereWithAggregatesInput[]
    NOT?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mission"> | string
    agentId?: StringWithAggregatesFilter<"Mission"> | string
    title?: StringWithAggregatesFilter<"Mission"> | string
    description?: StringWithAggregatesFilter<"Mission"> | string
    status?: EnumMissionStatusWithAggregatesFilter<"Mission"> | $Enums.MissionStatus
    priority?: IntWithAggregatesFilter<"Mission"> | number
    dueDate?: DateTimeNullableWithAggregatesFilter<"Mission"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Mission"> | Date | string | null
    result?: JsonNullableWithAggregatesFilter<"Mission">
    createdAt?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
  }

  export type Proxim8UserWhereInput = {
    AND?: Proxim8UserWhereInput | Proxim8UserWhereInput[]
    OR?: Proxim8UserWhereInput[]
    NOT?: Proxim8UserWhereInput | Proxim8UserWhereInput[]
    id?: StringFilter<"Proxim8User"> | string
    accountId?: StringFilter<"Proxim8User"> | string
    username?: StringFilter<"Proxim8User"> | string
    email?: StringNullableFilter<"Proxim8User"> | string | null
    bio?: StringNullableFilter<"Proxim8User"> | string | null
    avatar?: StringNullableFilter<"Proxim8User"> | string | null
    isPublic?: BoolFilter<"Proxim8User"> | boolean
    isAdmin?: BoolFilter<"Proxim8User"> | boolean
    socialLinks?: JsonNullableFilter<"Proxim8User">
    preferences?: JsonNullableFilter<"Proxim8User">
    stats?: JsonNullableFilter<"Proxim8User">
    createdAt?: DateTimeFilter<"Proxim8User"> | Date | string
    updatedAt?: DateTimeFilter<"Proxim8User"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type Proxim8UserOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    isAdmin?: SortOrder
    socialLinks?: SortOrder
    preferences?: SortOrder
    stats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type Proxim8UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    username?: string
    AND?: Proxim8UserWhereInput | Proxim8UserWhereInput[]
    OR?: Proxim8UserWhereInput[]
    NOT?: Proxim8UserWhereInput | Proxim8UserWhereInput[]
    email?: StringNullableFilter<"Proxim8User"> | string | null
    bio?: StringNullableFilter<"Proxim8User"> | string | null
    avatar?: StringNullableFilter<"Proxim8User"> | string | null
    isPublic?: BoolFilter<"Proxim8User"> | boolean
    isAdmin?: BoolFilter<"Proxim8User"> | boolean
    socialLinks?: JsonNullableFilter<"Proxim8User">
    preferences?: JsonNullableFilter<"Proxim8User">
    stats?: JsonNullableFilter<"Proxim8User">
    createdAt?: DateTimeFilter<"Proxim8User"> | Date | string
    updatedAt?: DateTimeFilter<"Proxim8User"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "accountId" | "username">

  export type Proxim8UserOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    isAdmin?: SortOrder
    socialLinks?: SortOrder
    preferences?: SortOrder
    stats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Proxim8UserCountOrderByAggregateInput
    _max?: Proxim8UserMaxOrderByAggregateInput
    _min?: Proxim8UserMinOrderByAggregateInput
  }

  export type Proxim8UserScalarWhereWithAggregatesInput = {
    AND?: Proxim8UserScalarWhereWithAggregatesInput | Proxim8UserScalarWhereWithAggregatesInput[]
    OR?: Proxim8UserScalarWhereWithAggregatesInput[]
    NOT?: Proxim8UserScalarWhereWithAggregatesInput | Proxim8UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proxim8User"> | string
    accountId?: StringWithAggregatesFilter<"Proxim8User"> | string
    username?: StringWithAggregatesFilter<"Proxim8User"> | string
    email?: StringNullableWithAggregatesFilter<"Proxim8User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Proxim8User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Proxim8User"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Proxim8User"> | boolean
    isAdmin?: BoolWithAggregatesFilter<"Proxim8User"> | boolean
    socialLinks?: JsonNullableWithAggregatesFilter<"Proxim8User">
    preferences?: JsonNullableWithAggregatesFilter<"Proxim8User">
    stats?: JsonNullableWithAggregatesFilter<"Proxim8User">
    createdAt?: DateTimeWithAggregatesFilter<"Proxim8User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proxim8User"> | Date | string
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: StringFilter<"Video"> | string
    accountId?: StringFilter<"Video"> | string
    nftId?: StringFilter<"Video"> | string
    jobId?: StringFilter<"Video"> | string
    status?: EnumVideoStatusFilter<"Video"> | $Enums.VideoStatus
    title?: StringNullableFilter<"Video"> | string | null
    description?: StringNullableFilter<"Video"> | string | null
    videoUrl?: StringNullableFilter<"Video"> | string | null
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: IntNullableFilter<"Video"> | number | null
    resolution?: StringNullableFilter<"Video"> | string | null
    isPublic?: BoolFilter<"Video"> | boolean
    metadata?: JsonNullableFilter<"Video">
    errorMessage?: StringNullableFilter<"Video"> | string | null
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    nftId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    resolution?: SortOrder
    isPublic?: SortOrder
    metadata?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId?: string
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    accountId?: StringFilter<"Video"> | string
    nftId?: StringFilter<"Video"> | string
    status?: EnumVideoStatusFilter<"Video"> | $Enums.VideoStatus
    title?: StringNullableFilter<"Video"> | string | null
    description?: StringNullableFilter<"Video"> | string | null
    videoUrl?: StringNullableFilter<"Video"> | string | null
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: IntNullableFilter<"Video"> | number | null
    resolution?: StringNullableFilter<"Video"> | string | null
    isPublic?: BoolFilter<"Video"> | boolean
    metadata?: JsonNullableFilter<"Video">
    errorMessage?: StringNullableFilter<"Video"> | string | null
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "jobId">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    nftId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    resolution?: SortOrder
    isPublic?: SortOrder
    metadata?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Video"> | string
    accountId?: StringWithAggregatesFilter<"Video"> | string
    nftId?: StringWithAggregatesFilter<"Video"> | string
    jobId?: StringWithAggregatesFilter<"Video"> | string
    status?: EnumVideoStatusWithAggregatesFilter<"Video"> | $Enums.VideoStatus
    title?: StringNullableWithAggregatesFilter<"Video"> | string | null
    description?: StringNullableWithAggregatesFilter<"Video"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Video"> | number | null
    fileSize?: IntNullableWithAggregatesFilter<"Video"> | number | null
    resolution?: StringNullableWithAggregatesFilter<"Video"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Video"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Video">
    errorMessage?: StringNullableWithAggregatesFilter<"Video"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    accountId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    accountId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    accountId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NFTOwnershipWhereInput = {
    AND?: NFTOwnershipWhereInput | NFTOwnershipWhereInput[]
    OR?: NFTOwnershipWhereInput[]
    NOT?: NFTOwnershipWhereInput | NFTOwnershipWhereInput[]
    id?: StringFilter<"NFTOwnership"> | string
    nftId?: StringFilter<"NFTOwnership"> | string
    accountId?: StringFilter<"NFTOwnership"> | string
    walletAddress?: StringFilter<"NFTOwnership"> | string
    contractAddress?: StringFilter<"NFTOwnership"> | string
    tokenId?: StringFilter<"NFTOwnership"> | string
    blockchain?: StringFilter<"NFTOwnership"> | string
    verified?: BoolFilter<"NFTOwnership"> | boolean
    lastVerified?: DateTimeNullableFilter<"NFTOwnership"> | Date | string | null
    metadata?: JsonNullableFilter<"NFTOwnership">
    createdAt?: DateTimeFilter<"NFTOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"NFTOwnership"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type NFTOwnershipOrderByWithRelationInput = {
    id?: SortOrder
    nftId?: SortOrder
    accountId?: SortOrder
    walletAddress?: SortOrder
    contractAddress?: SortOrder
    tokenId?: SortOrder
    blockchain?: SortOrder
    verified?: SortOrder
    lastVerified?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type NFTOwnershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nftId_accountId?: NFTOwnershipNftIdAccountIdCompoundUniqueInput
    AND?: NFTOwnershipWhereInput | NFTOwnershipWhereInput[]
    OR?: NFTOwnershipWhereInput[]
    NOT?: NFTOwnershipWhereInput | NFTOwnershipWhereInput[]
    nftId?: StringFilter<"NFTOwnership"> | string
    accountId?: StringFilter<"NFTOwnership"> | string
    walletAddress?: StringFilter<"NFTOwnership"> | string
    contractAddress?: StringFilter<"NFTOwnership"> | string
    tokenId?: StringFilter<"NFTOwnership"> | string
    blockchain?: StringFilter<"NFTOwnership"> | string
    verified?: BoolFilter<"NFTOwnership"> | boolean
    lastVerified?: DateTimeNullableFilter<"NFTOwnership"> | Date | string | null
    metadata?: JsonNullableFilter<"NFTOwnership">
    createdAt?: DateTimeFilter<"NFTOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"NFTOwnership"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "nftId_accountId">

  export type NFTOwnershipOrderByWithAggregationInput = {
    id?: SortOrder
    nftId?: SortOrder
    accountId?: SortOrder
    walletAddress?: SortOrder
    contractAddress?: SortOrder
    tokenId?: SortOrder
    blockchain?: SortOrder
    verified?: SortOrder
    lastVerified?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NFTOwnershipCountOrderByAggregateInput
    _max?: NFTOwnershipMaxOrderByAggregateInput
    _min?: NFTOwnershipMinOrderByAggregateInput
  }

  export type NFTOwnershipScalarWhereWithAggregatesInput = {
    AND?: NFTOwnershipScalarWhereWithAggregatesInput | NFTOwnershipScalarWhereWithAggregatesInput[]
    OR?: NFTOwnershipScalarWhereWithAggregatesInput[]
    NOT?: NFTOwnershipScalarWhereWithAggregatesInput | NFTOwnershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NFTOwnership"> | string
    nftId?: StringWithAggregatesFilter<"NFTOwnership"> | string
    accountId?: StringWithAggregatesFilter<"NFTOwnership"> | string
    walletAddress?: StringWithAggregatesFilter<"NFTOwnership"> | string
    contractAddress?: StringWithAggregatesFilter<"NFTOwnership"> | string
    tokenId?: StringWithAggregatesFilter<"NFTOwnership"> | string
    blockchain?: StringWithAggregatesFilter<"NFTOwnership"> | string
    verified?: BoolWithAggregatesFilter<"NFTOwnership"> | boolean
    lastVerified?: DateTimeNullableWithAggregatesFilter<"NFTOwnership"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"NFTOwnership">
    createdAt?: DateTimeWithAggregatesFilter<"NFTOwnership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NFTOwnership"> | Date | string
  }

  export type LoreWhereInput = {
    AND?: LoreWhereInput | LoreWhereInput[]
    OR?: LoreWhereInput[]
    NOT?: LoreWhereInput | LoreWhereInput[]
    id?: StringFilter<"Lore"> | string
    nftId?: StringFilter<"Lore"> | string
    title?: StringFilter<"Lore"> | string
    content?: StringFilter<"Lore"> | string
    background?: StringFilter<"Lore"> | string
    traits?: JsonNullableFilter<"Lore">
    claimed?: BoolFilter<"Lore"> | boolean
    claimedBy?: StringNullableFilter<"Lore"> | string | null
    claimedAt?: DateTimeNullableFilter<"Lore"> | Date | string | null
    category?: StringNullableFilter<"Lore"> | string | null
    tags?: StringNullableListFilter<"Lore">
    isPublic?: BoolFilter<"Lore"> | boolean
    metadata?: JsonNullableFilter<"Lore">
    createdAt?: DateTimeFilter<"Lore"> | Date | string
    updatedAt?: DateTimeFilter<"Lore"> | Date | string
  }

  export type LoreOrderByWithRelationInput = {
    id?: SortOrder
    nftId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    background?: SortOrder
    traits?: SortOrder
    claimed?: SortOrder
    claimedBy?: SortOrder
    claimedAt?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoreWhereInput | LoreWhereInput[]
    OR?: LoreWhereInput[]
    NOT?: LoreWhereInput | LoreWhereInput[]
    nftId?: StringFilter<"Lore"> | string
    title?: StringFilter<"Lore"> | string
    content?: StringFilter<"Lore"> | string
    background?: StringFilter<"Lore"> | string
    traits?: JsonNullableFilter<"Lore">
    claimed?: BoolFilter<"Lore"> | boolean
    claimedBy?: StringNullableFilter<"Lore"> | string | null
    claimedAt?: DateTimeNullableFilter<"Lore"> | Date | string | null
    category?: StringNullableFilter<"Lore"> | string | null
    tags?: StringNullableListFilter<"Lore">
    isPublic?: BoolFilter<"Lore"> | boolean
    metadata?: JsonNullableFilter<"Lore">
    createdAt?: DateTimeFilter<"Lore"> | Date | string
    updatedAt?: DateTimeFilter<"Lore"> | Date | string
  }, "id">

  export type LoreOrderByWithAggregationInput = {
    id?: SortOrder
    nftId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    background?: SortOrder
    traits?: SortOrder
    claimed?: SortOrder
    claimedBy?: SortOrder
    claimedAt?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoreCountOrderByAggregateInput
    _max?: LoreMaxOrderByAggregateInput
    _min?: LoreMinOrderByAggregateInput
  }

  export type LoreScalarWhereWithAggregatesInput = {
    AND?: LoreScalarWhereWithAggregatesInput | LoreScalarWhereWithAggregatesInput[]
    OR?: LoreScalarWhereWithAggregatesInput[]
    NOT?: LoreScalarWhereWithAggregatesInput | LoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lore"> | string
    nftId?: StringWithAggregatesFilter<"Lore"> | string
    title?: StringWithAggregatesFilter<"Lore"> | string
    content?: StringWithAggregatesFilter<"Lore"> | string
    background?: StringWithAggregatesFilter<"Lore"> | string
    traits?: JsonNullableWithAggregatesFilter<"Lore">
    claimed?: BoolWithAggregatesFilter<"Lore"> | boolean
    claimedBy?: StringNullableWithAggregatesFilter<"Lore"> | string | null
    claimedAt?: DateTimeNullableWithAggregatesFilter<"Lore"> | Date | string | null
    category?: StringNullableWithAggregatesFilter<"Lore"> | string | null
    tags?: StringNullableListFilter<"Lore">
    isPublic?: BoolWithAggregatesFilter<"Lore"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Lore">
    createdAt?: DateTimeWithAggregatesFilter<"Lore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lore"> | Date | string
  }

  export type PipelineWhereInput = {
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    name?: StringFilter<"Pipeline"> | string
    description?: StringNullableFilter<"Pipeline"> | string | null
    type?: EnumPipelineTypeFilter<"Pipeline"> | $Enums.PipelineType
    status?: EnumPipelineStatusFilter<"Pipeline"> | $Enums.PipelineStatus
    config?: JsonFilter<"Pipeline">
    metadata?: JsonNullableFilter<"Pipeline">
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
  }

  export type PipelineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    name?: StringFilter<"Pipeline"> | string
    description?: StringNullableFilter<"Pipeline"> | string | null
    type?: EnumPipelineTypeFilter<"Pipeline"> | $Enums.PipelineType
    status?: EnumPipelineStatusFilter<"Pipeline"> | $Enums.PipelineStatus
    config?: JsonFilter<"Pipeline">
    metadata?: JsonNullableFilter<"Pipeline">
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
  }, "id">

  export type PipelineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PipelineCountOrderByAggregateInput
    _max?: PipelineMaxOrderByAggregateInput
    _min?: PipelineMinOrderByAggregateInput
  }

  export type PipelineScalarWhereWithAggregatesInput = {
    AND?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    OR?: PipelineScalarWhereWithAggregatesInput[]
    NOT?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pipeline"> | string
    name?: StringWithAggregatesFilter<"Pipeline"> | string
    description?: StringNullableWithAggregatesFilter<"Pipeline"> | string | null
    type?: EnumPipelineTypeWithAggregatesFilter<"Pipeline"> | $Enums.PipelineType
    status?: EnumPipelineStatusWithAggregatesFilter<"Pipeline"> | $Enums.PipelineStatus
    config?: JsonWithAggregatesFilter<"Pipeline">
    metadata?: JsonNullableWithAggregatesFilter<"Pipeline">
    createdAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
  }

  export type PublicVideoWhereInput = {
    AND?: PublicVideoWhereInput | PublicVideoWhereInput[]
    OR?: PublicVideoWhereInput[]
    NOT?: PublicVideoWhereInput | PublicVideoWhereInput[]
    id?: StringFilter<"PublicVideo"> | string
    videoId?: StringFilter<"PublicVideo"> | string
    title?: StringFilter<"PublicVideo"> | string
    description?: StringNullableFilter<"PublicVideo"> | string | null
    thumbnailUrl?: StringNullableFilter<"PublicVideo"> | string | null
    videoUrl?: StringFilter<"PublicVideo"> | string
    nftId?: StringFilter<"PublicVideo"> | string
    walletAddress?: StringFilter<"PublicVideo"> | string
    views?: IntFilter<"PublicVideo"> | number
    likes?: IntFilter<"PublicVideo"> | number
    featured?: BoolFilter<"PublicVideo"> | boolean
    tags?: StringNullableListFilter<"PublicVideo">
    metadata?: JsonNullableFilter<"PublicVideo">
    createdAt?: DateTimeFilter<"PublicVideo"> | Date | string
    updatedAt?: DateTimeFilter<"PublicVideo"> | Date | string
  }

  export type PublicVideoOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    videoUrl?: SortOrder
    nftId?: SortOrder
    walletAddress?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    featured?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicVideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoId?: string
    AND?: PublicVideoWhereInput | PublicVideoWhereInput[]
    OR?: PublicVideoWhereInput[]
    NOT?: PublicVideoWhereInput | PublicVideoWhereInput[]
    title?: StringFilter<"PublicVideo"> | string
    description?: StringNullableFilter<"PublicVideo"> | string | null
    thumbnailUrl?: StringNullableFilter<"PublicVideo"> | string | null
    videoUrl?: StringFilter<"PublicVideo"> | string
    nftId?: StringFilter<"PublicVideo"> | string
    walletAddress?: StringFilter<"PublicVideo"> | string
    views?: IntFilter<"PublicVideo"> | number
    likes?: IntFilter<"PublicVideo"> | number
    featured?: BoolFilter<"PublicVideo"> | boolean
    tags?: StringNullableListFilter<"PublicVideo">
    metadata?: JsonNullableFilter<"PublicVideo">
    createdAt?: DateTimeFilter<"PublicVideo"> | Date | string
    updatedAt?: DateTimeFilter<"PublicVideo"> | Date | string
  }, "id" | "videoId">

  export type PublicVideoOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    videoUrl?: SortOrder
    nftId?: SortOrder
    walletAddress?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    featured?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PublicVideoCountOrderByAggregateInput
    _avg?: PublicVideoAvgOrderByAggregateInput
    _max?: PublicVideoMaxOrderByAggregateInput
    _min?: PublicVideoMinOrderByAggregateInput
    _sum?: PublicVideoSumOrderByAggregateInput
  }

  export type PublicVideoScalarWhereWithAggregatesInput = {
    AND?: PublicVideoScalarWhereWithAggregatesInput | PublicVideoScalarWhereWithAggregatesInput[]
    OR?: PublicVideoScalarWhereWithAggregatesInput[]
    NOT?: PublicVideoScalarWhereWithAggregatesInput | PublicVideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PublicVideo"> | string
    videoId?: StringWithAggregatesFilter<"PublicVideo"> | string
    title?: StringWithAggregatesFilter<"PublicVideo"> | string
    description?: StringNullableWithAggregatesFilter<"PublicVideo"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"PublicVideo"> | string | null
    videoUrl?: StringWithAggregatesFilter<"PublicVideo"> | string
    nftId?: StringWithAggregatesFilter<"PublicVideo"> | string
    walletAddress?: StringWithAggregatesFilter<"PublicVideo"> | string
    views?: IntWithAggregatesFilter<"PublicVideo"> | number
    likes?: IntWithAggregatesFilter<"PublicVideo"> | number
    featured?: BoolWithAggregatesFilter<"PublicVideo"> | boolean
    tags?: StringNullableListFilter<"PublicVideo">
    metadata?: JsonNullableWithAggregatesFilter<"PublicVideo">
    createdAt?: DateTimeWithAggregatesFilter<"PublicVideo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PublicVideo"> | Date | string
  }

  export type GameAgentWhereInput = {
    AND?: GameAgentWhereInput | GameAgentWhereInput[]
    OR?: GameAgentWhereInput[]
    NOT?: GameAgentWhereInput | GameAgentWhereInput[]
    id?: StringFilter<"GameAgent"> | string
    accountId?: StringFilter<"GameAgent"> | string
    codename?: StringNullableFilter<"GameAgent"> | string | null
    rank?: EnumAgentRankFilter<"GameAgent"> | $Enums.AgentRank
    timelinePoints?: IntFilter<"GameAgent"> | number
    createdAt?: DateTimeFilter<"GameAgent"> | Date | string
    updatedAt?: DateTimeFilter<"GameAgent"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    proxim8s?: GameProxim8ListRelationFilter
    missionDeployments?: TrainingMissionDeploymentListRelationFilter
  }

  export type GameAgentOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    codename?: SortOrder
    rank?: SortOrder
    timelinePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    proxim8s?: GameProxim8OrderByRelationAggregateInput
    missionDeployments?: TrainingMissionDeploymentOrderByRelationAggregateInput
  }

  export type GameAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    AND?: GameAgentWhereInput | GameAgentWhereInput[]
    OR?: GameAgentWhereInput[]
    NOT?: GameAgentWhereInput | GameAgentWhereInput[]
    codename?: StringNullableFilter<"GameAgent"> | string | null
    rank?: EnumAgentRankFilter<"GameAgent"> | $Enums.AgentRank
    timelinePoints?: IntFilter<"GameAgent"> | number
    createdAt?: DateTimeFilter<"GameAgent"> | Date | string
    updatedAt?: DateTimeFilter<"GameAgent"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    proxim8s?: GameProxim8ListRelationFilter
    missionDeployments?: TrainingMissionDeploymentListRelationFilter
  }, "id" | "accountId">

  export type GameAgentOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    codename?: SortOrder
    rank?: SortOrder
    timelinePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameAgentCountOrderByAggregateInput
    _avg?: GameAgentAvgOrderByAggregateInput
    _max?: GameAgentMaxOrderByAggregateInput
    _min?: GameAgentMinOrderByAggregateInput
    _sum?: GameAgentSumOrderByAggregateInput
  }

  export type GameAgentScalarWhereWithAggregatesInput = {
    AND?: GameAgentScalarWhereWithAggregatesInput | GameAgentScalarWhereWithAggregatesInput[]
    OR?: GameAgentScalarWhereWithAggregatesInput[]
    NOT?: GameAgentScalarWhereWithAggregatesInput | GameAgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameAgent"> | string
    accountId?: StringWithAggregatesFilter<"GameAgent"> | string
    codename?: StringNullableWithAggregatesFilter<"GameAgent"> | string | null
    rank?: EnumAgentRankWithAggregatesFilter<"GameAgent"> | $Enums.AgentRank
    timelinePoints?: IntWithAggregatesFilter<"GameAgent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GameAgent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameAgent"> | Date | string
  }

  export type GameProxim8WhereInput = {
    AND?: GameProxim8WhereInput | GameProxim8WhereInput[]
    OR?: GameProxim8WhereInput[]
    NOT?: GameProxim8WhereInput | GameProxim8WhereInput[]
    id?: StringFilter<"GameProxim8"> | string
    gameAgentId?: StringFilter<"GameProxim8"> | string
    nftId?: StringFilter<"GameProxim8"> | string
    name?: StringFilter<"GameProxim8"> | string
    personality?: EnumProxim8PersonalityFilter<"GameProxim8"> | $Enums.Proxim8Personality
    level?: IntFilter<"GameProxim8"> | number
    experience?: IntFilter<"GameProxim8"> | number
    isDeployed?: BoolFilter<"GameProxim8"> | boolean
    lastMissionAt?: DateTimeNullableFilter<"GameProxim8"> | Date | string | null
    createdAt?: DateTimeFilter<"GameProxim8"> | Date | string
    updatedAt?: DateTimeFilter<"GameProxim8"> | Date | string
    gameAgent?: XOR<GameAgentScalarRelationFilter, GameAgentWhereInput>
    missionDeployments?: TrainingMissionDeploymentListRelationFilter
  }

  export type GameProxim8OrderByWithRelationInput = {
    id?: SortOrder
    gameAgentId?: SortOrder
    nftId?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isDeployed?: SortOrder
    lastMissionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameAgent?: GameAgentOrderByWithRelationInput
    missionDeployments?: TrainingMissionDeploymentOrderByRelationAggregateInput
  }

  export type GameProxim8WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameAgentId_nftId?: GameProxim8GameAgentIdNftIdCompoundUniqueInput
    AND?: GameProxim8WhereInput | GameProxim8WhereInput[]
    OR?: GameProxim8WhereInput[]
    NOT?: GameProxim8WhereInput | GameProxim8WhereInput[]
    gameAgentId?: StringFilter<"GameProxim8"> | string
    nftId?: StringFilter<"GameProxim8"> | string
    name?: StringFilter<"GameProxim8"> | string
    personality?: EnumProxim8PersonalityFilter<"GameProxim8"> | $Enums.Proxim8Personality
    level?: IntFilter<"GameProxim8"> | number
    experience?: IntFilter<"GameProxim8"> | number
    isDeployed?: BoolFilter<"GameProxim8"> | boolean
    lastMissionAt?: DateTimeNullableFilter<"GameProxim8"> | Date | string | null
    createdAt?: DateTimeFilter<"GameProxim8"> | Date | string
    updatedAt?: DateTimeFilter<"GameProxim8"> | Date | string
    gameAgent?: XOR<GameAgentScalarRelationFilter, GameAgentWhereInput>
    missionDeployments?: TrainingMissionDeploymentListRelationFilter
  }, "id" | "gameAgentId_nftId">

  export type GameProxim8OrderByWithAggregationInput = {
    id?: SortOrder
    gameAgentId?: SortOrder
    nftId?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isDeployed?: SortOrder
    lastMissionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameProxim8CountOrderByAggregateInput
    _avg?: GameProxim8AvgOrderByAggregateInput
    _max?: GameProxim8MaxOrderByAggregateInput
    _min?: GameProxim8MinOrderByAggregateInput
    _sum?: GameProxim8SumOrderByAggregateInput
  }

  export type GameProxim8ScalarWhereWithAggregatesInput = {
    AND?: GameProxim8ScalarWhereWithAggregatesInput | GameProxim8ScalarWhereWithAggregatesInput[]
    OR?: GameProxim8ScalarWhereWithAggregatesInput[]
    NOT?: GameProxim8ScalarWhereWithAggregatesInput | GameProxim8ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameProxim8"> | string
    gameAgentId?: StringWithAggregatesFilter<"GameProxim8"> | string
    nftId?: StringWithAggregatesFilter<"GameProxim8"> | string
    name?: StringWithAggregatesFilter<"GameProxim8"> | string
    personality?: EnumProxim8PersonalityWithAggregatesFilter<"GameProxim8"> | $Enums.Proxim8Personality
    level?: IntWithAggregatesFilter<"GameProxim8"> | number
    experience?: IntWithAggregatesFilter<"GameProxim8"> | number
    isDeployed?: BoolWithAggregatesFilter<"GameProxim8"> | boolean
    lastMissionAt?: DateTimeNullableWithAggregatesFilter<"GameProxim8"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GameProxim8"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameProxim8"> | Date | string
  }

  export type TrainingMissionDeploymentWhereInput = {
    AND?: TrainingMissionDeploymentWhereInput | TrainingMissionDeploymentWhereInput[]
    OR?: TrainingMissionDeploymentWhereInput[]
    NOT?: TrainingMissionDeploymentWhereInput | TrainingMissionDeploymentWhereInput[]
    id?: StringFilter<"TrainingMissionDeployment"> | string
    deploymentId?: StringFilter<"TrainingMissionDeployment"> | string
    missionId?: StringFilter<"TrainingMissionDeployment"> | string
    gameAgentId?: StringFilter<"TrainingMissionDeployment"> | string
    gameProxim8Id?: StringFilter<"TrainingMissionDeployment"> | string
    approach?: EnumMissionApproachFilter<"TrainingMissionDeployment"> | $Enums.MissionApproach
    deployedAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    completesAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    duration?: IntFilter<"TrainingMissionDeployment"> | number
    status?: EnumDeploymentStatusFilter<"TrainingMissionDeployment"> | $Enums.DeploymentStatus
    currentPhase?: IntFilter<"TrainingMissionDeployment"> | number
    finalSuccessRate?: FloatFilter<"TrainingMissionDeployment"> | number
    phaseOutcomes?: JsonFilter<"TrainingMissionDeployment">
    result?: JsonNullableFilter<"TrainingMissionDeployment">
    createdAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    gameAgent?: XOR<GameAgentScalarRelationFilter, GameAgentWhereInput>
    gameProxim8?: XOR<GameProxim8ScalarRelationFilter, GameProxim8WhereInput>
  }

  export type TrainingMissionDeploymentOrderByWithRelationInput = {
    id?: SortOrder
    deploymentId?: SortOrder
    missionId?: SortOrder
    gameAgentId?: SortOrder
    gameProxim8Id?: SortOrder
    approach?: SortOrder
    deployedAt?: SortOrder
    completesAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    finalSuccessRate?: SortOrder
    phaseOutcomes?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameAgent?: GameAgentOrderByWithRelationInput
    gameProxim8?: GameProxim8OrderByWithRelationInput
  }

  export type TrainingMissionDeploymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deploymentId?: string
    AND?: TrainingMissionDeploymentWhereInput | TrainingMissionDeploymentWhereInput[]
    OR?: TrainingMissionDeploymentWhereInput[]
    NOT?: TrainingMissionDeploymentWhereInput | TrainingMissionDeploymentWhereInput[]
    missionId?: StringFilter<"TrainingMissionDeployment"> | string
    gameAgentId?: StringFilter<"TrainingMissionDeployment"> | string
    gameProxim8Id?: StringFilter<"TrainingMissionDeployment"> | string
    approach?: EnumMissionApproachFilter<"TrainingMissionDeployment"> | $Enums.MissionApproach
    deployedAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    completesAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    duration?: IntFilter<"TrainingMissionDeployment"> | number
    status?: EnumDeploymentStatusFilter<"TrainingMissionDeployment"> | $Enums.DeploymentStatus
    currentPhase?: IntFilter<"TrainingMissionDeployment"> | number
    finalSuccessRate?: FloatFilter<"TrainingMissionDeployment"> | number
    phaseOutcomes?: JsonFilter<"TrainingMissionDeployment">
    result?: JsonNullableFilter<"TrainingMissionDeployment">
    createdAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    gameAgent?: XOR<GameAgentScalarRelationFilter, GameAgentWhereInput>
    gameProxim8?: XOR<GameProxim8ScalarRelationFilter, GameProxim8WhereInput>
  }, "id" | "deploymentId">

  export type TrainingMissionDeploymentOrderByWithAggregationInput = {
    id?: SortOrder
    deploymentId?: SortOrder
    missionId?: SortOrder
    gameAgentId?: SortOrder
    gameProxim8Id?: SortOrder
    approach?: SortOrder
    deployedAt?: SortOrder
    completesAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    finalSuccessRate?: SortOrder
    phaseOutcomes?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingMissionDeploymentCountOrderByAggregateInput
    _avg?: TrainingMissionDeploymentAvgOrderByAggregateInput
    _max?: TrainingMissionDeploymentMaxOrderByAggregateInput
    _min?: TrainingMissionDeploymentMinOrderByAggregateInput
    _sum?: TrainingMissionDeploymentSumOrderByAggregateInput
  }

  export type TrainingMissionDeploymentScalarWhereWithAggregatesInput = {
    AND?: TrainingMissionDeploymentScalarWhereWithAggregatesInput | TrainingMissionDeploymentScalarWhereWithAggregatesInput[]
    OR?: TrainingMissionDeploymentScalarWhereWithAggregatesInput[]
    NOT?: TrainingMissionDeploymentScalarWhereWithAggregatesInput | TrainingMissionDeploymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingMissionDeployment"> | string
    deploymentId?: StringWithAggregatesFilter<"TrainingMissionDeployment"> | string
    missionId?: StringWithAggregatesFilter<"TrainingMissionDeployment"> | string
    gameAgentId?: StringWithAggregatesFilter<"TrainingMissionDeployment"> | string
    gameProxim8Id?: StringWithAggregatesFilter<"TrainingMissionDeployment"> | string
    approach?: EnumMissionApproachWithAggregatesFilter<"TrainingMissionDeployment"> | $Enums.MissionApproach
    deployedAt?: DateTimeWithAggregatesFilter<"TrainingMissionDeployment"> | Date | string
    completesAt?: DateTimeWithAggregatesFilter<"TrainingMissionDeployment"> | Date | string
    duration?: IntWithAggregatesFilter<"TrainingMissionDeployment"> | number
    status?: EnumDeploymentStatusWithAggregatesFilter<"TrainingMissionDeployment"> | $Enums.DeploymentStatus
    currentPhase?: IntWithAggregatesFilter<"TrainingMissionDeployment"> | number
    finalSuccessRate?: FloatWithAggregatesFilter<"TrainingMissionDeployment"> | number
    phaseOutcomes?: JsonWithAggregatesFilter<"TrainingMissionDeployment">
    result?: JsonNullableWithAggregatesFilter<"TrainingMissionDeployment">
    createdAt?: DateTimeWithAggregatesFilter<"TrainingMissionDeployment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingMissionDeployment"> | Date | string
  }

  export type UserStatsWhereInput = {
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    id?: StringFilter<"UserStats"> | string
    profileId?: StringFilter<"UserStats"> | string
    stats?: JsonFilter<"UserStats">
    createdAt?: DateTimeFilter<"UserStats"> | Date | string
    updatedAt?: DateTimeFilter<"UserStats"> | Date | string
  }

  export type UserStatsOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    stats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId?: string
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    stats?: JsonFilter<"UserStats">
    createdAt?: DateTimeFilter<"UserStats"> | Date | string
    updatedAt?: DateTimeFilter<"UserStats"> | Date | string
  }, "id" | "profileId">

  export type UserStatsOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    stats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserStatsCountOrderByAggregateInput
    _max?: UserStatsMaxOrderByAggregateInput
    _min?: UserStatsMinOrderByAggregateInput
  }

  export type UserStatsScalarWhereWithAggregatesInput = {
    AND?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    OR?: UserStatsScalarWhereWithAggregatesInput[]
    NOT?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserStats"> | string
    profileId?: StringWithAggregatesFilter<"UserStats"> | string
    stats?: JsonWithAggregatesFilter<"UserStats">
    createdAt?: DateTimeWithAggregatesFilter<"UserStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserStats"> | Date | string
  }

  export type NFTWhereInput = {
    AND?: NFTWhereInput | NFTWhereInput[]
    OR?: NFTWhereInput[]
    NOT?: NFTWhereInput | NFTWhereInput[]
    id?: StringFilter<"NFT"> | string
    tokenId?: StringFilter<"NFT"> | string
    metadata?: JsonFilter<"NFT">
    createdAt?: DateTimeFilter<"NFT"> | Date | string
    updatedAt?: DateTimeFilter<"NFT"> | Date | string
  }

  export type NFTOrderByWithRelationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenId?: string
    AND?: NFTWhereInput | NFTWhereInput[]
    OR?: NFTWhereInput[]
    NOT?: NFTWhereInput | NFTWhereInput[]
    metadata?: JsonFilter<"NFT">
    createdAt?: DateTimeFilter<"NFT"> | Date | string
    updatedAt?: DateTimeFilter<"NFT"> | Date | string
  }, "id" | "tokenId">

  export type NFTOrderByWithAggregationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NFTCountOrderByAggregateInput
    _max?: NFTMaxOrderByAggregateInput
    _min?: NFTMinOrderByAggregateInput
  }

  export type NFTScalarWhereWithAggregatesInput = {
    AND?: NFTScalarWhereWithAggregatesInput | NFTScalarWhereWithAggregatesInput[]
    OR?: NFTScalarWhereWithAggregatesInput[]
    NOT?: NFTScalarWhereWithAggregatesInput | NFTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NFT"> | string
    tokenId?: StringWithAggregatesFilter<"NFT"> | string
    metadata?: JsonWithAggregatesFilter<"NFT">
    createdAt?: DateTimeWithAggregatesFilter<"NFT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NFT"> | Date | string
  }

  export type TrainingMissionWhereInput = {
    AND?: TrainingMissionWhereInput | TrainingMissionWhereInput[]
    OR?: TrainingMissionWhereInput[]
    NOT?: TrainingMissionWhereInput | TrainingMissionWhereInput[]
    id?: StringFilter<"TrainingMission"> | string
    title?: StringFilter<"TrainingMission"> | string
    status?: StringFilter<"TrainingMission"> | string
    isActive?: BoolFilter<"TrainingMission"> | boolean
    createdAt?: DateTimeFilter<"TrainingMission"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingMission"> | Date | string
  }

  export type TrainingMissionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingMissionWhereInput | TrainingMissionWhereInput[]
    OR?: TrainingMissionWhereInput[]
    NOT?: TrainingMissionWhereInput | TrainingMissionWhereInput[]
    title?: StringFilter<"TrainingMission"> | string
    status?: StringFilter<"TrainingMission"> | string
    isActive?: BoolFilter<"TrainingMission"> | boolean
    createdAt?: DateTimeFilter<"TrainingMission"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingMission"> | Date | string
  }, "id">

  export type TrainingMissionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingMissionCountOrderByAggregateInput
    _max?: TrainingMissionMaxOrderByAggregateInput
    _min?: TrainingMissionMinOrderByAggregateInput
  }

  export type TrainingMissionScalarWhereWithAggregatesInput = {
    AND?: TrainingMissionScalarWhereWithAggregatesInput | TrainingMissionScalarWhereWithAggregatesInput[]
    OR?: TrainingMissionScalarWhereWithAggregatesInput[]
    NOT?: TrainingMissionScalarWhereWithAggregatesInput | TrainingMissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingMission"> | string
    title?: StringWithAggregatesFilter<"TrainingMission"> | string
    status?: StringWithAggregatesFilter<"TrainingMission"> | string
    isActive?: BoolWithAggregatesFilter<"TrainingMission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TrainingMission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingMission"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintCreateNestedManyWithoutAccountInput
    agents?: AgentCreateNestedManyWithoutAccountInput
    videos?: VideoCreateNestedManyWithoutAccountInput
    notifications?: NotificationCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintUncheckedCreateNestedManyWithoutAccountInput
    agents?: AgentUncheckedCreateNestedManyWithoutAccountInput
    videos?: VideoUncheckedCreateNestedManyWithoutAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserUncheckedCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountUpdateInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUpdateManyWithoutAccountNestedInput
    agents?: AgentUpdateManyWithoutAccountNestedInput
    videos?: VideoUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUncheckedUpdateManyWithoutAccountNestedInput
    agents?: AgentUncheckedUpdateManyWithoutAccountNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutProfilesInput
    visits?: VisitCreateNestedManyWithoutProfileInput
    impressions?: ImpressionCreateNestedManyWithoutProfileInput
    socialProfiles?: SocialProfileCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    accountId: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutProfileInput
    impressions?: ImpressionUncheckedCreateNestedManyWithoutProfileInput
    socialProfiles?: SocialProfileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutProfilesNestedInput
    visits?: VisitUpdateManyWithoutProfileNestedInput
    impressions?: ImpressionUpdateManyWithoutProfileNestedInput
    socialProfiles?: SocialProfileUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutProfileNestedInput
    impressions?: ImpressionUncheckedUpdateManyWithoutProfileNestedInput
    socialProfiles?: SocialProfileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    accountId: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FingerprintCreateInput = {
    id?: string
    fingerprint: string
    roles?: FingerprintCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutFingerprintsInput
    visits?: VisitCreateNestedManyWithoutFingerprintInput
  }

  export type FingerprintUncheckedCreateInput = {
    id?: string
    accountId?: string | null
    fingerprint: string
    roles?: FingerprintCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutFingerprintInput
  }

  export type FingerprintUpdateInput = {
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutFingerprintsNestedInput
    visits?: VisitUpdateManyWithoutFingerprintNestedInput
  }

  export type FingerprintUncheckedUpdateInput = {
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutFingerprintNestedInput
  }

  export type FingerprintCreateManyInput = {
    id?: string
    accountId?: string | null
    fingerprint: string
    roles?: FingerprintCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FingerprintUpdateManyMutationInput = {
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FingerprintUncheckedUpdateManyInput = {
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    id?: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAgentsInput
    knowledge?: KnowledgeCreateNestedManyWithoutAgentInput
    missions?: MissionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    accountId: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutAgentInput
    missions?: MissionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAgentsNestedInput
    knowledge?: KnowledgeUpdateManyWithoutAgentNestedInput
    missions?: MissionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutAgentNestedInput
    missions?: MissionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    accountId: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateInput = {
    id?: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutVisitsInput
    fingerprint: FingerprintCreateNestedOneWithoutVisitsInput
  }

  export type VisitUncheckedCreateInput = {
    id?: string
    profileId?: string | null
    fingerprintId: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type VisitUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutVisitsNestedInput
    fingerprint?: FingerprintUpdateOneRequiredWithoutVisitsNestedInput
  }

  export type VisitUncheckedUpdateInput = {
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateManyInput = {
    id?: string
    profileId?: string | null
    fingerprintId: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type VisitUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUncheckedUpdateManyInput = {
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionCreateInput = {
    id?: string
    type: string
    context?: InputJsonValue | null
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutImpressionsInput
  }

  export type ImpressionUncheckedCreateInput = {
    id?: string
    profileId: string
    type: string
    context?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type ImpressionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    context?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutImpressionsNestedInput
  }

  export type ImpressionUncheckedUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    context?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionCreateManyInput = {
    id?: string
    profileId: string
    type: string
    context?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type ImpressionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    context?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionUncheckedUpdateManyInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    context?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileCreateInput = {
    id?: string
    platform: string
    username: string
    url?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutSocialProfilesInput
  }

  export type SocialProfileUncheckedCreateInput = {
    id?: string
    profileId: string
    platform: string
    username: string
    url?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialProfileUpdateInput = {
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutSocialProfilesNestedInput
  }

  export type SocialProfileUncheckedUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileCreateManyInput = {
    id?: string
    profileId: string
    platform: string
    username: string
    url?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialProfileUpdateManyMutationInput = {
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileUncheckedUpdateManyInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCreateInput = {
    id?: string
    title: string
    content: string
    type: string
    source?: string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutKnowledgeInput
  }

  export type KnowledgeUncheckedCreateInput = {
    id?: string
    agentId: string
    title: string
    content: string
    type: string
    source?: string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutKnowledgeNestedInput
  }

  export type KnowledgeUncheckedUpdateInput = {
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCreateManyInput = {
    id?: string
    agentId: string
    title: string
    content: string
    type: string
    source?: string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeUncheckedUpdateManyInput = {
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.MissionStatus
    priority?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutMissionsInput
  }

  export type MissionUncheckedCreateInput = {
    id?: string
    agentId: string
    title: string
    description: string
    status?: $Enums.MissionStatus
    priority?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutMissionsNestedInput
  }

  export type MissionUncheckedUpdateInput = {
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionCreateManyInput = {
    id?: string
    agentId: string
    title: string
    description: string
    status?: $Enums.MissionStatus
    priority?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionUncheckedUpdateManyInput = {
    agentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Proxim8UserCreateInput = {
    id?: string
    username: string
    email?: string | null
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    isAdmin?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    stats?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutProxim8UserInput
  }

  export type Proxim8UserUncheckedCreateInput = {
    id?: string
    accountId: string
    username: string
    email?: string | null
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    isAdmin?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    stats?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Proxim8UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    stats?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutProxim8UserNestedInput
  }

  export type Proxim8UserUncheckedUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    stats?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Proxim8UserCreateManyInput = {
    id?: string
    accountId: string
    username: string
    email?: string | null
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    isAdmin?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    stats?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Proxim8UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    stats?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Proxim8UserUncheckedUpdateManyInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    stats?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    id?: string
    nftId: string
    jobId: string
    status?: $Enums.VideoStatus
    title?: string | null
    description?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    resolution?: string | null
    isPublic?: boolean
    metadata?: InputJsonValue | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutVideosInput
  }

  export type VideoUncheckedCreateInput = {
    id?: string
    accountId: string
    nftId: string
    jobId: string
    status?: $Enums.VideoStatus
    title?: string | null
    description?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    resolution?: string | null
    isPublic?: boolean
    metadata?: InputJsonValue | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutVideosNestedInput
  }

  export type VideoUncheckedUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyInput = {
    id?: string
    accountId: string
    nftId: string
    jobId: string
    status?: $Enums.VideoStatus
    title?: string | null
    description?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    resolution?: string | null
    isPublic?: boolean
    metadata?: InputJsonValue | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: InputJsonValue | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    accountId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: InputJsonValue | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    accountId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: InputJsonValue | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTOwnershipCreateInput = {
    id?: string
    nftId: string
    walletAddress: string
    contractAddress: string
    tokenId: string
    blockchain?: string
    verified?: boolean
    lastVerified?: Date | string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutNftOwnershipsInput
  }

  export type NFTOwnershipUncheckedCreateInput = {
    id?: string
    nftId: string
    accountId: string
    walletAddress: string
    contractAddress: string
    tokenId: string
    blockchain?: string
    verified?: boolean
    lastVerified?: Date | string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTOwnershipUpdateInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    blockchain?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    lastVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutNftOwnershipsNestedInput
  }

  export type NFTOwnershipUncheckedUpdateInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    blockchain?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    lastVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTOwnershipCreateManyInput = {
    id?: string
    nftId: string
    accountId: string
    walletAddress: string
    contractAddress: string
    tokenId: string
    blockchain?: string
    verified?: boolean
    lastVerified?: Date | string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTOwnershipUpdateManyMutationInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    blockchain?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    lastVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTOwnershipUncheckedUpdateManyInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    blockchain?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    lastVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoreCreateInput = {
    id?: string
    nftId: string
    title: string
    content: string
    background: string
    traits?: InputJsonValue | null
    claimed?: boolean
    claimedBy?: string | null
    claimedAt?: Date | string | null
    category?: string | null
    tags?: LoreCreatetagsInput | string[]
    isPublic?: boolean
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoreUncheckedCreateInput = {
    id?: string
    nftId: string
    title: string
    content: string
    background: string
    traits?: InputJsonValue | null
    claimed?: boolean
    claimedBy?: string | null
    claimedAt?: Date | string | null
    category?: string | null
    tags?: LoreCreatetagsInput | string[]
    isPublic?: boolean
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoreUpdateInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    traits?: InputJsonValue | InputJsonValue | null
    claimed?: BoolFieldUpdateOperationsInput | boolean
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoreUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoreUncheckedUpdateInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    traits?: InputJsonValue | InputJsonValue | null
    claimed?: BoolFieldUpdateOperationsInput | boolean
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoreUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoreCreateManyInput = {
    id?: string
    nftId: string
    title: string
    content: string
    background: string
    traits?: InputJsonValue | null
    claimed?: boolean
    claimedBy?: string | null
    claimedAt?: Date | string | null
    category?: string | null
    tags?: LoreCreatetagsInput | string[]
    isPublic?: boolean
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoreUpdateManyMutationInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    traits?: InputJsonValue | InputJsonValue | null
    claimed?: BoolFieldUpdateOperationsInput | boolean
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoreUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoreUncheckedUpdateManyInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    traits?: InputJsonValue | InputJsonValue | null
    claimed?: BoolFieldUpdateOperationsInput | boolean
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoreUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.PipelineType
    status?: $Enums.PipelineStatus
    config: InputJsonValue
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.PipelineType
    status?: $Enums.PipelineStatus
    config: InputJsonValue
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPipelineTypeFieldUpdateOperationsInput | $Enums.PipelineType
    status?: EnumPipelineStatusFieldUpdateOperationsInput | $Enums.PipelineStatus
    config?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPipelineTypeFieldUpdateOperationsInput | $Enums.PipelineType
    status?: EnumPipelineStatusFieldUpdateOperationsInput | $Enums.PipelineStatus
    config?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.PipelineType
    status?: $Enums.PipelineStatus
    config: InputJsonValue
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPipelineTypeFieldUpdateOperationsInput | $Enums.PipelineType
    status?: EnumPipelineStatusFieldUpdateOperationsInput | $Enums.PipelineStatus
    config?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPipelineTypeFieldUpdateOperationsInput | $Enums.PipelineType
    status?: EnumPipelineStatusFieldUpdateOperationsInput | $Enums.PipelineStatus
    config?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicVideoCreateInput = {
    id?: string
    videoId: string
    title: string
    description?: string | null
    thumbnailUrl?: string | null
    videoUrl: string
    nftId: string
    walletAddress: string
    views?: number
    likes?: number
    featured?: boolean
    tags?: PublicVideoCreatetagsInput | string[]
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicVideoUncheckedCreateInput = {
    id?: string
    videoId: string
    title: string
    description?: string | null
    thumbnailUrl?: string | null
    videoUrl: string
    nftId: string
    walletAddress: string
    views?: number
    likes?: number
    featured?: boolean
    tags?: PublicVideoCreatetagsInput | string[]
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicVideoUpdateInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    tags?: PublicVideoUpdatetagsInput | string[]
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicVideoUncheckedUpdateInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    tags?: PublicVideoUpdatetagsInput | string[]
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicVideoCreateManyInput = {
    id?: string
    videoId: string
    title: string
    description?: string | null
    thumbnailUrl?: string | null
    videoUrl: string
    nftId: string
    walletAddress: string
    views?: number
    likes?: number
    featured?: boolean
    tags?: PublicVideoCreatetagsInput | string[]
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicVideoUpdateManyMutationInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    tags?: PublicVideoUpdatetagsInput | string[]
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicVideoUncheckedUpdateManyInput = {
    videoId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    tags?: PublicVideoUpdatetagsInput | string[]
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAgentCreateInput = {
    id?: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutGameAgentInput
    proxim8s?: GameProxim8CreateNestedManyWithoutGameAgentInput
    missionDeployments?: TrainingMissionDeploymentCreateNestedManyWithoutGameAgentInput
  }

  export type GameAgentUncheckedCreateInput = {
    id?: string
    accountId: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proxim8s?: GameProxim8UncheckedCreateNestedManyWithoutGameAgentInput
    missionDeployments?: TrainingMissionDeploymentUncheckedCreateNestedManyWithoutGameAgentInput
  }

  export type GameAgentUpdateInput = {
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutGameAgentNestedInput
    proxim8s?: GameProxim8UpdateManyWithoutGameAgentNestedInput
    missionDeployments?: TrainingMissionDeploymentUpdateManyWithoutGameAgentNestedInput
  }

  export type GameAgentUncheckedUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxim8s?: GameProxim8UncheckedUpdateManyWithoutGameAgentNestedInput
    missionDeployments?: TrainingMissionDeploymentUncheckedUpdateManyWithoutGameAgentNestedInput
  }

  export type GameAgentCreateManyInput = {
    id?: string
    accountId: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameAgentUpdateManyMutationInput = {
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAgentUncheckedUpdateManyInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameProxim8CreateInput = {
    id?: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level?: number
    experience?: number
    isDeployed?: boolean
    lastMissionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameAgent: GameAgentCreateNestedOneWithoutProxim8sInput
    missionDeployments?: TrainingMissionDeploymentCreateNestedManyWithoutGameProxim8Input
  }

  export type GameProxim8UncheckedCreateInput = {
    id?: string
    gameAgentId: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level?: number
    experience?: number
    isDeployed?: boolean
    lastMissionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    missionDeployments?: TrainingMissionDeploymentUncheckedCreateNestedManyWithoutGameProxim8Input
  }

  export type GameProxim8UpdateInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameAgent?: GameAgentUpdateOneRequiredWithoutProxim8sNestedInput
    missionDeployments?: TrainingMissionDeploymentUpdateManyWithoutGameProxim8NestedInput
  }

  export type GameProxim8UncheckedUpdateInput = {
    gameAgentId?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    missionDeployments?: TrainingMissionDeploymentUncheckedUpdateManyWithoutGameProxim8NestedInput
  }

  export type GameProxim8CreateManyInput = {
    id?: string
    gameAgentId: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level?: number
    experience?: number
    isDeployed?: boolean
    lastMissionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameProxim8UpdateManyMutationInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameProxim8UncheckedUpdateManyInput = {
    gameAgentId?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionDeploymentCreateInput = {
    id?: string
    deploymentId: string
    missionId: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameAgent: GameAgentCreateNestedOneWithoutMissionDeploymentsInput
    gameProxim8: GameProxim8CreateNestedOneWithoutMissionDeploymentsInput
  }

  export type TrainingMissionDeploymentUncheckedCreateInput = {
    id?: string
    deploymentId: string
    missionId: string
    gameAgentId: string
    gameProxim8Id: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionDeploymentUpdateInput = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameAgent?: GameAgentUpdateOneRequiredWithoutMissionDeploymentsNestedInput
    gameProxim8?: GameProxim8UpdateOneRequiredWithoutMissionDeploymentsNestedInput
  }

  export type TrainingMissionDeploymentUncheckedUpdateInput = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    gameAgentId?: StringFieldUpdateOperationsInput | string
    gameProxim8Id?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionDeploymentCreateManyInput = {
    id?: string
    deploymentId: string
    missionId: string
    gameAgentId: string
    gameProxim8Id: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionDeploymentUpdateManyMutationInput = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionDeploymentUncheckedUpdateManyInput = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    gameAgentId?: StringFieldUpdateOperationsInput | string
    gameProxim8Id?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatsCreateInput = {
    id?: string
    profileId: string
    stats: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStatsUncheckedCreateInput = {
    id?: string
    profileId: string
    stats: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStatsUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    stats?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatsUncheckedUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    stats?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatsCreateManyInput = {
    id?: string
    profileId: string
    stats: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStatsUpdateManyMutationInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    stats?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatsUncheckedUpdateManyInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    stats?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTCreateInput = {
    id?: string
    tokenId: string
    metadata: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTUncheckedCreateInput = {
    id?: string
    tokenId: string
    metadata: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTUpdateInput = {
    tokenId?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTUncheckedUpdateInput = {
    tokenId?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTCreateManyInput = {
    id?: string
    tokenId: string
    metadata: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTUpdateManyMutationInput = {
    tokenId?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTUncheckedUpdateManyInput = {
    tokenId?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionCreateInput = {
    id?: string
    title: string
    status?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionUncheckedCreateInput = {
    id?: string
    title: string
    status?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionCreateManyInput = {
    id?: string
    title: string
    status?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type FingerprintListRelationFilter = {
    every?: FingerprintWhereInput
    some?: FingerprintWhereInput
    none?: FingerprintWhereInput
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NFTOwnershipListRelationFilter = {
    every?: NFTOwnershipWhereInput
    some?: NFTOwnershipWhereInput
    none?: NFTOwnershipWhereInput
  }

  export type Proxim8UserNullableScalarRelationFilter = {
    is?: Proxim8UserWhereInput | null
    isNot?: Proxim8UserWhereInput | null
  }

  export type GameAgentNullableScalarRelationFilter = {
    is?: GameAgentWhereInput | null
    isNot?: GameAgentWhereInput | null
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FingerprintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NFTOwnershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type VisitListRelationFilter = {
    every?: VisitWhereInput
    some?: VisitWhereInput
    none?: VisitWhereInput
  }

  export type ImpressionListRelationFilter = {
    every?: ImpressionWhereInput
    some?: ImpressionWhereInput
    none?: ImpressionWhereInput
  }

  export type SocialProfileListRelationFilter = {
    every?: SocialProfileWhereInput
    some?: SocialProfileWhereInput
    none?: SocialProfileWhereInput
  }

  export type VisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImpressionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    socialLinks?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type FingerprintCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    fingerprint?: SortOrder
    roles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FingerprintMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FingerprintMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeListRelationFilter = {
    every?: KnowledgeWhereInput
    some?: KnowledgeWhereInput
    none?: KnowledgeWhereInput
  }

  export type MissionListRelationFilter = {
    every?: MissionWhereInput
    some?: MissionWhereInput
    none?: MissionWhereInput
  }

  export type KnowledgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type FingerprintScalarRelationFilter = {
    is?: FingerprintWhereInput
    isNot?: FingerprintWhereInput
  }

  export type VisitCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    fingerprintId?: SortOrder
    path?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referrer?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type VisitMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    fingerprintId?: SortOrder
    path?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referrer?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    fingerprintId?: SortOrder
    path?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referrer?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type ImpressionCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type ImpressionMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ImpressionMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type SocialProfileProfileIdPlatformCompoundUniqueInput = {
    profileId: string
    platform: string
  }

  export type SocialProfileCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    url?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    url?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialProfileMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    url?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type KnowledgeCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionStatus | EnumMissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionStatusFilter<$PrismaModel> | $Enums.MissionStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type MissionCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type MissionMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumMissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionStatus | EnumMissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.MissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMissionStatusFilter<$PrismaModel>
    _max?: NestedEnumMissionStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type Proxim8UserCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    isAdmin?: SortOrder
    socialLinks?: SortOrder
    preferences?: SortOrder
    stats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Proxim8UserMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Proxim8UserMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVideoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoStatus | EnumVideoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoStatusFilter<$PrismaModel> | $Enums.VideoStatus
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    nftId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    resolution?: SortOrder
    isPublic?: SortOrder
    metadata?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    duration?: SortOrder
    fileSize?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    nftId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    resolution?: SortOrder
    isPublic?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    nftId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    resolution?: SortOrder
    isPublic?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    duration?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumVideoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoStatus | EnumVideoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoStatusWithAggregatesFilter<$PrismaModel> | $Enums.VideoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoStatusFilter<$PrismaModel>
    _max?: NestedEnumVideoStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NFTOwnershipNftIdAccountIdCompoundUniqueInput = {
    nftId: string
    accountId: string
  }

  export type NFTOwnershipCountOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    accountId?: SortOrder
    walletAddress?: SortOrder
    contractAddress?: SortOrder
    tokenId?: SortOrder
    blockchain?: SortOrder
    verified?: SortOrder
    lastVerified?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTOwnershipMaxOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    accountId?: SortOrder
    walletAddress?: SortOrder
    contractAddress?: SortOrder
    tokenId?: SortOrder
    blockchain?: SortOrder
    verified?: SortOrder
    lastVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTOwnershipMinOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    accountId?: SortOrder
    walletAddress?: SortOrder
    contractAddress?: SortOrder
    tokenId?: SortOrder
    blockchain?: SortOrder
    verified?: SortOrder
    lastVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoreCountOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    background?: SortOrder
    traits?: SortOrder
    claimed?: SortOrder
    claimedBy?: SortOrder
    claimedAt?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoreMaxOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    background?: SortOrder
    claimed?: SortOrder
    claimedBy?: SortOrder
    claimedAt?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoreMinOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    background?: SortOrder
    claimed?: SortOrder
    claimedBy?: SortOrder
    claimedAt?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPipelineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PipelineType | EnumPipelineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PipelineType[] | ListEnumPipelineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PipelineType[] | ListEnumPipelineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPipelineTypeFilter<$PrismaModel> | $Enums.PipelineType
  }

  export type EnumPipelineStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PipelineStatus | EnumPipelineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PipelineStatus[] | ListEnumPipelineStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PipelineStatus[] | ListEnumPipelineStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPipelineStatusFilter<$PrismaModel> | $Enums.PipelineStatus
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type PipelineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPipelineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PipelineType | EnumPipelineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PipelineType[] | ListEnumPipelineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PipelineType[] | ListEnumPipelineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPipelineTypeWithAggregatesFilter<$PrismaModel> | $Enums.PipelineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPipelineTypeFilter<$PrismaModel>
    _max?: NestedEnumPipelineTypeFilter<$PrismaModel>
  }

  export type EnumPipelineStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PipelineStatus | EnumPipelineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PipelineStatus[] | ListEnumPipelineStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PipelineStatus[] | ListEnumPipelineStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPipelineStatusWithAggregatesFilter<$PrismaModel> | $Enums.PipelineStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPipelineStatusFilter<$PrismaModel>
    _max?: NestedEnumPipelineStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PublicVideoCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    videoUrl?: SortOrder
    nftId?: SortOrder
    walletAddress?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    featured?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicVideoAvgOrderByAggregateInput = {
    views?: SortOrder
    likes?: SortOrder
  }

  export type PublicVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    videoUrl?: SortOrder
    nftId?: SortOrder
    walletAddress?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicVideoMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    videoUrl?: SortOrder
    nftId?: SortOrder
    walletAddress?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    featured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicVideoSumOrderByAggregateInput = {
    views?: SortOrder
    likes?: SortOrder
  }

  export type EnumAgentRankFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentRank | EnumAgentRankFieldRefInput<$PrismaModel>
    in?: $Enums.AgentRank[] | ListEnumAgentRankFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentRank[] | ListEnumAgentRankFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentRankFilter<$PrismaModel> | $Enums.AgentRank
  }

  export type GameProxim8ListRelationFilter = {
    every?: GameProxim8WhereInput
    some?: GameProxim8WhereInput
    none?: GameProxim8WhereInput
  }

  export type TrainingMissionDeploymentListRelationFilter = {
    every?: TrainingMissionDeploymentWhereInput
    some?: TrainingMissionDeploymentWhereInput
    none?: TrainingMissionDeploymentWhereInput
  }

  export type GameProxim8OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingMissionDeploymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameAgentCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    codename?: SortOrder
    rank?: SortOrder
    timelinePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAgentAvgOrderByAggregateInput = {
    timelinePoints?: SortOrder
  }

  export type GameAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    codename?: SortOrder
    rank?: SortOrder
    timelinePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAgentMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    codename?: SortOrder
    rank?: SortOrder
    timelinePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAgentSumOrderByAggregateInput = {
    timelinePoints?: SortOrder
  }

  export type EnumAgentRankWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentRank | EnumAgentRankFieldRefInput<$PrismaModel>
    in?: $Enums.AgentRank[] | ListEnumAgentRankFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentRank[] | ListEnumAgentRankFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentRankWithAggregatesFilter<$PrismaModel> | $Enums.AgentRank
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentRankFilter<$PrismaModel>
    _max?: NestedEnumAgentRankFilter<$PrismaModel>
  }

  export type EnumProxim8PersonalityFilter<$PrismaModel = never> = {
    equals?: $Enums.Proxim8Personality | EnumProxim8PersonalityFieldRefInput<$PrismaModel>
    in?: $Enums.Proxim8Personality[] | ListEnumProxim8PersonalityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Proxim8Personality[] | ListEnumProxim8PersonalityFieldRefInput<$PrismaModel>
    not?: NestedEnumProxim8PersonalityFilter<$PrismaModel> | $Enums.Proxim8Personality
  }

  export type GameAgentScalarRelationFilter = {
    is?: GameAgentWhereInput
    isNot?: GameAgentWhereInput
  }

  export type GameProxim8GameAgentIdNftIdCompoundUniqueInput = {
    gameAgentId: string
    nftId: string
  }

  export type GameProxim8CountOrderByAggregateInput = {
    id?: SortOrder
    gameAgentId?: SortOrder
    nftId?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isDeployed?: SortOrder
    lastMissionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameProxim8AvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type GameProxim8MaxOrderByAggregateInput = {
    id?: SortOrder
    gameAgentId?: SortOrder
    nftId?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isDeployed?: SortOrder
    lastMissionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameProxim8MinOrderByAggregateInput = {
    id?: SortOrder
    gameAgentId?: SortOrder
    nftId?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    isDeployed?: SortOrder
    lastMissionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameProxim8SumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type EnumProxim8PersonalityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Proxim8Personality | EnumProxim8PersonalityFieldRefInput<$PrismaModel>
    in?: $Enums.Proxim8Personality[] | ListEnumProxim8PersonalityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Proxim8Personality[] | ListEnumProxim8PersonalityFieldRefInput<$PrismaModel>
    not?: NestedEnumProxim8PersonalityWithAggregatesFilter<$PrismaModel> | $Enums.Proxim8Personality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProxim8PersonalityFilter<$PrismaModel>
    _max?: NestedEnumProxim8PersonalityFilter<$PrismaModel>
  }

  export type EnumMissionApproachFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionApproach | EnumMissionApproachFieldRefInput<$PrismaModel>
    in?: $Enums.MissionApproach[] | ListEnumMissionApproachFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionApproach[] | ListEnumMissionApproachFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionApproachFilter<$PrismaModel> | $Enums.MissionApproach
  }

  export type EnumDeploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusFilter<$PrismaModel> | $Enums.DeploymentStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GameProxim8ScalarRelationFilter = {
    is?: GameProxim8WhereInput
    isNot?: GameProxim8WhereInput
  }

  export type TrainingMissionDeploymentCountOrderByAggregateInput = {
    id?: SortOrder
    deploymentId?: SortOrder
    missionId?: SortOrder
    gameAgentId?: SortOrder
    gameProxim8Id?: SortOrder
    approach?: SortOrder
    deployedAt?: SortOrder
    completesAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    finalSuccessRate?: SortOrder
    phaseOutcomes?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMissionDeploymentAvgOrderByAggregateInput = {
    duration?: SortOrder
    currentPhase?: SortOrder
    finalSuccessRate?: SortOrder
  }

  export type TrainingMissionDeploymentMaxOrderByAggregateInput = {
    id?: SortOrder
    deploymentId?: SortOrder
    missionId?: SortOrder
    gameAgentId?: SortOrder
    gameProxim8Id?: SortOrder
    approach?: SortOrder
    deployedAt?: SortOrder
    completesAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    finalSuccessRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMissionDeploymentMinOrderByAggregateInput = {
    id?: SortOrder
    deploymentId?: SortOrder
    missionId?: SortOrder
    gameAgentId?: SortOrder
    gameProxim8Id?: SortOrder
    approach?: SortOrder
    deployedAt?: SortOrder
    completesAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    currentPhase?: SortOrder
    finalSuccessRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMissionDeploymentSumOrderByAggregateInput = {
    duration?: SortOrder
    currentPhase?: SortOrder
    finalSuccessRate?: SortOrder
  }

  export type EnumMissionApproachWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionApproach | EnumMissionApproachFieldRefInput<$PrismaModel>
    in?: $Enums.MissionApproach[] | ListEnumMissionApproachFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionApproach[] | ListEnumMissionApproachFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionApproachWithAggregatesFilter<$PrismaModel> | $Enums.MissionApproach
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMissionApproachFilter<$PrismaModel>
    _max?: NestedEnumMissionApproachFilter<$PrismaModel>
  }

  export type EnumDeploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumDeploymentStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserStatsCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    stats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStatsMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTCountOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTMinOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMissionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMissionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMissionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileCreateNestedManyWithoutAccountInput = {
    create?: XOR<ProfileCreateWithoutAccountInput, ProfileUncheckedCreateWithoutAccountInput> | ProfileCreateWithoutAccountInput[] | ProfileUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutAccountInput | ProfileCreateOrConnectWithoutAccountInput[]
    createMany?: ProfileCreateManyAccountInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type FingerprintCreateNestedManyWithoutAccountInput = {
    create?: XOR<FingerprintCreateWithoutAccountInput, FingerprintUncheckedCreateWithoutAccountInput> | FingerprintCreateWithoutAccountInput[] | FingerprintUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: FingerprintCreateOrConnectWithoutAccountInput | FingerprintCreateOrConnectWithoutAccountInput[]
    createMany?: FingerprintCreateManyAccountInputEnvelope
    connect?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutAccountInput = {
    create?: XOR<AgentCreateWithoutAccountInput, AgentUncheckedCreateWithoutAccountInput> | AgentCreateWithoutAccountInput[] | AgentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutAccountInput | AgentCreateOrConnectWithoutAccountInput[]
    createMany?: AgentCreateManyAccountInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutAccountInput = {
    create?: XOR<VideoCreateWithoutAccountInput, VideoUncheckedCreateWithoutAccountInput> | VideoCreateWithoutAccountInput[] | VideoUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAccountInput | VideoCreateOrConnectWithoutAccountInput[]
    createMany?: VideoCreateManyAccountInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutAccountInput = {
    create?: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput> | NotificationCreateWithoutAccountInput[] | NotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
    createMany?: NotificationCreateManyAccountInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NFTOwnershipCreateNestedManyWithoutAccountInput = {
    create?: XOR<NFTOwnershipCreateWithoutAccountInput, NFTOwnershipUncheckedCreateWithoutAccountInput> | NFTOwnershipCreateWithoutAccountInput[] | NFTOwnershipUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NFTOwnershipCreateOrConnectWithoutAccountInput | NFTOwnershipCreateOrConnectWithoutAccountInput[]
    createMany?: NFTOwnershipCreateManyAccountInputEnvelope
    connect?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
  }

  export type Proxim8UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<Proxim8UserCreateWithoutAccountInput, Proxim8UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: Proxim8UserCreateOrConnectWithoutAccountInput
    connect?: Proxim8UserWhereUniqueInput
  }

  export type GameAgentCreateNestedOneWithoutAccountInput = {
    create?: XOR<GameAgentCreateWithoutAccountInput, GameAgentUncheckedCreateWithoutAccountInput>
    connectOrCreate?: GameAgentCreateOrConnectWithoutAccountInput
    connect?: GameAgentWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ProfileCreateWithoutAccountInput, ProfileUncheckedCreateWithoutAccountInput> | ProfileCreateWithoutAccountInput[] | ProfileUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutAccountInput | ProfileCreateOrConnectWithoutAccountInput[]
    createMany?: ProfileCreateManyAccountInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type FingerprintUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<FingerprintCreateWithoutAccountInput, FingerprintUncheckedCreateWithoutAccountInput> | FingerprintCreateWithoutAccountInput[] | FingerprintUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: FingerprintCreateOrConnectWithoutAccountInput | FingerprintCreateOrConnectWithoutAccountInput[]
    createMany?: FingerprintCreateManyAccountInputEnvelope
    connect?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AgentCreateWithoutAccountInput, AgentUncheckedCreateWithoutAccountInput> | AgentCreateWithoutAccountInput[] | AgentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutAccountInput | AgentCreateOrConnectWithoutAccountInput[]
    createMany?: AgentCreateManyAccountInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<VideoCreateWithoutAccountInput, VideoUncheckedCreateWithoutAccountInput> | VideoCreateWithoutAccountInput[] | VideoUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAccountInput | VideoCreateOrConnectWithoutAccountInput[]
    createMany?: VideoCreateManyAccountInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput> | NotificationCreateWithoutAccountInput[] | NotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
    createMany?: NotificationCreateManyAccountInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<NFTOwnershipCreateWithoutAccountInput, NFTOwnershipUncheckedCreateWithoutAccountInput> | NFTOwnershipCreateWithoutAccountInput[] | NFTOwnershipUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NFTOwnershipCreateOrConnectWithoutAccountInput | NFTOwnershipCreateOrConnectWithoutAccountInput[]
    createMany?: NFTOwnershipCreateManyAccountInputEnvelope
    connect?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
  }

  export type Proxim8UserUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<Proxim8UserCreateWithoutAccountInput, Proxim8UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: Proxim8UserCreateOrConnectWithoutAccountInput
    connect?: Proxim8UserWhereUniqueInput
  }

  export type GameAgentUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<GameAgentCreateWithoutAccountInput, GameAgentUncheckedCreateWithoutAccountInput>
    connectOrCreate?: GameAgentCreateOrConnectWithoutAccountInput
    connect?: GameAgentWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ProfileCreateWithoutAccountInput, ProfileUncheckedCreateWithoutAccountInput> | ProfileCreateWithoutAccountInput[] | ProfileUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutAccountInput | ProfileCreateOrConnectWithoutAccountInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutAccountInput | ProfileUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ProfileCreateManyAccountInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutAccountInput | ProfileUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutAccountInput | ProfileUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type FingerprintUpdateManyWithoutAccountNestedInput = {
    create?: XOR<FingerprintCreateWithoutAccountInput, FingerprintUncheckedCreateWithoutAccountInput> | FingerprintCreateWithoutAccountInput[] | FingerprintUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: FingerprintCreateOrConnectWithoutAccountInput | FingerprintCreateOrConnectWithoutAccountInput[]
    upsert?: FingerprintUpsertWithWhereUniqueWithoutAccountInput | FingerprintUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: FingerprintCreateManyAccountInputEnvelope
    set?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
    disconnect?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
    delete?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
    connect?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
    update?: FingerprintUpdateWithWhereUniqueWithoutAccountInput | FingerprintUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: FingerprintUpdateManyWithWhereWithoutAccountInput | FingerprintUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: FingerprintScalarWhereInput | FingerprintScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AgentCreateWithoutAccountInput, AgentUncheckedCreateWithoutAccountInput> | AgentCreateWithoutAccountInput[] | AgentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutAccountInput | AgentCreateOrConnectWithoutAccountInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutAccountInput | AgentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AgentCreateManyAccountInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutAccountInput | AgentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutAccountInput | AgentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutAccountNestedInput = {
    create?: XOR<VideoCreateWithoutAccountInput, VideoUncheckedCreateWithoutAccountInput> | VideoCreateWithoutAccountInput[] | VideoUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAccountInput | VideoCreateOrConnectWithoutAccountInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutAccountInput | VideoUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: VideoCreateManyAccountInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutAccountInput | VideoUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutAccountInput | VideoUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput> | NotificationCreateWithoutAccountInput[] | NotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAccountInput | NotificationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NotificationCreateManyAccountInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAccountInput | NotificationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAccountInput | NotificationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NFTOwnershipUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NFTOwnershipCreateWithoutAccountInput, NFTOwnershipUncheckedCreateWithoutAccountInput> | NFTOwnershipCreateWithoutAccountInput[] | NFTOwnershipUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NFTOwnershipCreateOrConnectWithoutAccountInput | NFTOwnershipCreateOrConnectWithoutAccountInput[]
    upsert?: NFTOwnershipUpsertWithWhereUniqueWithoutAccountInput | NFTOwnershipUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NFTOwnershipCreateManyAccountInputEnvelope
    set?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
    disconnect?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
    delete?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
    connect?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
    update?: NFTOwnershipUpdateWithWhereUniqueWithoutAccountInput | NFTOwnershipUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NFTOwnershipUpdateManyWithWhereWithoutAccountInput | NFTOwnershipUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NFTOwnershipScalarWhereInput | NFTOwnershipScalarWhereInput[]
  }

  export type Proxim8UserUpdateOneWithoutAccountNestedInput = {
    create?: XOR<Proxim8UserCreateWithoutAccountInput, Proxim8UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: Proxim8UserCreateOrConnectWithoutAccountInput
    upsert?: Proxim8UserUpsertWithoutAccountInput
    disconnect?: Proxim8UserWhereInput | boolean
    delete?: Proxim8UserWhereInput | boolean
    connect?: Proxim8UserWhereUniqueInput
    update?: XOR<XOR<Proxim8UserUpdateToOneWithWhereWithoutAccountInput, Proxim8UserUpdateWithoutAccountInput>, Proxim8UserUncheckedUpdateWithoutAccountInput>
  }

  export type GameAgentUpdateOneWithoutAccountNestedInput = {
    create?: XOR<GameAgentCreateWithoutAccountInput, GameAgentUncheckedCreateWithoutAccountInput>
    connectOrCreate?: GameAgentCreateOrConnectWithoutAccountInput
    upsert?: GameAgentUpsertWithoutAccountInput
    disconnect?: GameAgentWhereInput | boolean
    delete?: GameAgentWhereInput | boolean
    connect?: GameAgentWhereUniqueInput
    update?: XOR<XOR<GameAgentUpdateToOneWithWhereWithoutAccountInput, GameAgentUpdateWithoutAccountInput>, GameAgentUncheckedUpdateWithoutAccountInput>
  }

  export type ProfileUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ProfileCreateWithoutAccountInput, ProfileUncheckedCreateWithoutAccountInput> | ProfileCreateWithoutAccountInput[] | ProfileUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutAccountInput | ProfileCreateOrConnectWithoutAccountInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutAccountInput | ProfileUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ProfileCreateManyAccountInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutAccountInput | ProfileUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutAccountInput | ProfileUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type FingerprintUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<FingerprintCreateWithoutAccountInput, FingerprintUncheckedCreateWithoutAccountInput> | FingerprintCreateWithoutAccountInput[] | FingerprintUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: FingerprintCreateOrConnectWithoutAccountInput | FingerprintCreateOrConnectWithoutAccountInput[]
    upsert?: FingerprintUpsertWithWhereUniqueWithoutAccountInput | FingerprintUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: FingerprintCreateManyAccountInputEnvelope
    set?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
    disconnect?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
    delete?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
    connect?: FingerprintWhereUniqueInput | FingerprintWhereUniqueInput[]
    update?: FingerprintUpdateWithWhereUniqueWithoutAccountInput | FingerprintUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: FingerprintUpdateManyWithWhereWithoutAccountInput | FingerprintUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: FingerprintScalarWhereInput | FingerprintScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AgentCreateWithoutAccountInput, AgentUncheckedCreateWithoutAccountInput> | AgentCreateWithoutAccountInput[] | AgentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutAccountInput | AgentCreateOrConnectWithoutAccountInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutAccountInput | AgentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AgentCreateManyAccountInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutAccountInput | AgentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutAccountInput | AgentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<VideoCreateWithoutAccountInput, VideoUncheckedCreateWithoutAccountInput> | VideoCreateWithoutAccountInput[] | VideoUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAccountInput | VideoCreateOrConnectWithoutAccountInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutAccountInput | VideoUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: VideoCreateManyAccountInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutAccountInput | VideoUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutAccountInput | VideoUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput> | NotificationCreateWithoutAccountInput[] | NotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAccountInput | NotificationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NotificationCreateManyAccountInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAccountInput | NotificationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAccountInput | NotificationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NFTOwnershipCreateWithoutAccountInput, NFTOwnershipUncheckedCreateWithoutAccountInput> | NFTOwnershipCreateWithoutAccountInput[] | NFTOwnershipUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NFTOwnershipCreateOrConnectWithoutAccountInput | NFTOwnershipCreateOrConnectWithoutAccountInput[]
    upsert?: NFTOwnershipUpsertWithWhereUniqueWithoutAccountInput | NFTOwnershipUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NFTOwnershipCreateManyAccountInputEnvelope
    set?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
    disconnect?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
    delete?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
    connect?: NFTOwnershipWhereUniqueInput | NFTOwnershipWhereUniqueInput[]
    update?: NFTOwnershipUpdateWithWhereUniqueWithoutAccountInput | NFTOwnershipUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NFTOwnershipUpdateManyWithWhereWithoutAccountInput | NFTOwnershipUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NFTOwnershipScalarWhereInput | NFTOwnershipScalarWhereInput[]
  }

  export type Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<Proxim8UserCreateWithoutAccountInput, Proxim8UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: Proxim8UserCreateOrConnectWithoutAccountInput
    upsert?: Proxim8UserUpsertWithoutAccountInput
    disconnect?: Proxim8UserWhereInput | boolean
    delete?: Proxim8UserWhereInput | boolean
    connect?: Proxim8UserWhereUniqueInput
    update?: XOR<XOR<Proxim8UserUpdateToOneWithWhereWithoutAccountInput, Proxim8UserUpdateWithoutAccountInput>, Proxim8UserUncheckedUpdateWithoutAccountInput>
  }

  export type GameAgentUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<GameAgentCreateWithoutAccountInput, GameAgentUncheckedCreateWithoutAccountInput>
    connectOrCreate?: GameAgentCreateOrConnectWithoutAccountInput
    upsert?: GameAgentUpsertWithoutAccountInput
    disconnect?: GameAgentWhereInput | boolean
    delete?: GameAgentWhereInput | boolean
    connect?: GameAgentWhereUniqueInput
    update?: XOR<XOR<GameAgentUpdateToOneWithWhereWithoutAccountInput, GameAgentUpdateWithoutAccountInput>, GameAgentUncheckedUpdateWithoutAccountInput>
  }

  export type AccountCreateNestedOneWithoutProfilesInput = {
    create?: XOR<AccountCreateWithoutProfilesInput, AccountUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProfilesInput
    connect?: AccountWhereUniqueInput
  }

  export type VisitCreateNestedManyWithoutProfileInput = {
    create?: XOR<VisitCreateWithoutProfileInput, VisitUncheckedCreateWithoutProfileInput> | VisitCreateWithoutProfileInput[] | VisitUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutProfileInput | VisitCreateOrConnectWithoutProfileInput[]
    createMany?: VisitCreateManyProfileInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type ImpressionCreateNestedManyWithoutProfileInput = {
    create?: XOR<ImpressionCreateWithoutProfileInput, ImpressionUncheckedCreateWithoutProfileInput> | ImpressionCreateWithoutProfileInput[] | ImpressionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutProfileInput | ImpressionCreateOrConnectWithoutProfileInput[]
    createMany?: ImpressionCreateManyProfileInputEnvelope
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
  }

  export type SocialProfileCreateNestedManyWithoutProfileInput = {
    create?: XOR<SocialProfileCreateWithoutProfileInput, SocialProfileUncheckedCreateWithoutProfileInput> | SocialProfileCreateWithoutProfileInput[] | SocialProfileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SocialProfileCreateOrConnectWithoutProfileInput | SocialProfileCreateOrConnectWithoutProfileInput[]
    createMany?: SocialProfileCreateManyProfileInputEnvelope
    connect?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<VisitCreateWithoutProfileInput, VisitUncheckedCreateWithoutProfileInput> | VisitCreateWithoutProfileInput[] | VisitUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutProfileInput | VisitCreateOrConnectWithoutProfileInput[]
    createMany?: VisitCreateManyProfileInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type ImpressionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ImpressionCreateWithoutProfileInput, ImpressionUncheckedCreateWithoutProfileInput> | ImpressionCreateWithoutProfileInput[] | ImpressionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutProfileInput | ImpressionCreateOrConnectWithoutProfileInput[]
    createMany?: ImpressionCreateManyProfileInputEnvelope
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
  }

  export type SocialProfileUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<SocialProfileCreateWithoutProfileInput, SocialProfileUncheckedCreateWithoutProfileInput> | SocialProfileCreateWithoutProfileInput[] | SocialProfileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SocialProfileCreateOrConnectWithoutProfileInput | SocialProfileCreateOrConnectWithoutProfileInput[]
    createMany?: SocialProfileCreateManyProfileInputEnvelope
    connect?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AccountUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<AccountCreateWithoutProfilesInput, AccountUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProfilesInput
    upsert?: AccountUpsertWithoutProfilesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutProfilesInput, AccountUpdateWithoutProfilesInput>, AccountUncheckedUpdateWithoutProfilesInput>
  }

  export type VisitUpdateManyWithoutProfileNestedInput = {
    create?: XOR<VisitCreateWithoutProfileInput, VisitUncheckedCreateWithoutProfileInput> | VisitCreateWithoutProfileInput[] | VisitUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutProfileInput | VisitCreateOrConnectWithoutProfileInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutProfileInput | VisitUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: VisitCreateManyProfileInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutProfileInput | VisitUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutProfileInput | VisitUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type ImpressionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ImpressionCreateWithoutProfileInput, ImpressionUncheckedCreateWithoutProfileInput> | ImpressionCreateWithoutProfileInput[] | ImpressionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutProfileInput | ImpressionCreateOrConnectWithoutProfileInput[]
    upsert?: ImpressionUpsertWithWhereUniqueWithoutProfileInput | ImpressionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ImpressionCreateManyProfileInputEnvelope
    set?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    disconnect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    delete?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    update?: ImpressionUpdateWithWhereUniqueWithoutProfileInput | ImpressionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ImpressionUpdateManyWithWhereWithoutProfileInput | ImpressionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
  }

  export type SocialProfileUpdateManyWithoutProfileNestedInput = {
    create?: XOR<SocialProfileCreateWithoutProfileInput, SocialProfileUncheckedCreateWithoutProfileInput> | SocialProfileCreateWithoutProfileInput[] | SocialProfileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SocialProfileCreateOrConnectWithoutProfileInput | SocialProfileCreateOrConnectWithoutProfileInput[]
    upsert?: SocialProfileUpsertWithWhereUniqueWithoutProfileInput | SocialProfileUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: SocialProfileCreateManyProfileInputEnvelope
    set?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
    disconnect?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
    delete?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
    connect?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
    update?: SocialProfileUpdateWithWhereUniqueWithoutProfileInput | SocialProfileUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: SocialProfileUpdateManyWithWhereWithoutProfileInput | SocialProfileUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: SocialProfileScalarWhereInput | SocialProfileScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<VisitCreateWithoutProfileInput, VisitUncheckedCreateWithoutProfileInput> | VisitCreateWithoutProfileInput[] | VisitUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutProfileInput | VisitCreateOrConnectWithoutProfileInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutProfileInput | VisitUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: VisitCreateManyProfileInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutProfileInput | VisitUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutProfileInput | VisitUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type ImpressionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ImpressionCreateWithoutProfileInput, ImpressionUncheckedCreateWithoutProfileInput> | ImpressionCreateWithoutProfileInput[] | ImpressionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutProfileInput | ImpressionCreateOrConnectWithoutProfileInput[]
    upsert?: ImpressionUpsertWithWhereUniqueWithoutProfileInput | ImpressionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ImpressionCreateManyProfileInputEnvelope
    set?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    disconnect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    delete?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    update?: ImpressionUpdateWithWhereUniqueWithoutProfileInput | ImpressionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ImpressionUpdateManyWithWhereWithoutProfileInput | ImpressionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
  }

  export type SocialProfileUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<SocialProfileCreateWithoutProfileInput, SocialProfileUncheckedCreateWithoutProfileInput> | SocialProfileCreateWithoutProfileInput[] | SocialProfileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SocialProfileCreateOrConnectWithoutProfileInput | SocialProfileCreateOrConnectWithoutProfileInput[]
    upsert?: SocialProfileUpsertWithWhereUniqueWithoutProfileInput | SocialProfileUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: SocialProfileCreateManyProfileInputEnvelope
    set?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
    disconnect?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
    delete?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
    connect?: SocialProfileWhereUniqueInput | SocialProfileWhereUniqueInput[]
    update?: SocialProfileUpdateWithWhereUniqueWithoutProfileInput | SocialProfileUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: SocialProfileUpdateManyWithWhereWithoutProfileInput | SocialProfileUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: SocialProfileScalarWhereInput | SocialProfileScalarWhereInput[]
  }

  export type FingerprintCreaterolesInput = {
    set: string[]
  }

  export type AccountCreateNestedOneWithoutFingerprintsInput = {
    create?: XOR<AccountCreateWithoutFingerprintsInput, AccountUncheckedCreateWithoutFingerprintsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutFingerprintsInput
    connect?: AccountWhereUniqueInput
  }

  export type VisitCreateNestedManyWithoutFingerprintInput = {
    create?: XOR<VisitCreateWithoutFingerprintInput, VisitUncheckedCreateWithoutFingerprintInput> | VisitCreateWithoutFingerprintInput[] | VisitUncheckedCreateWithoutFingerprintInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutFingerprintInput | VisitCreateOrConnectWithoutFingerprintInput[]
    createMany?: VisitCreateManyFingerprintInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutFingerprintInput = {
    create?: XOR<VisitCreateWithoutFingerprintInput, VisitUncheckedCreateWithoutFingerprintInput> | VisitCreateWithoutFingerprintInput[] | VisitUncheckedCreateWithoutFingerprintInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutFingerprintInput | VisitCreateOrConnectWithoutFingerprintInput[]
    createMany?: VisitCreateManyFingerprintInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type FingerprintUpdaterolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccountUpdateOneWithoutFingerprintsNestedInput = {
    create?: XOR<AccountCreateWithoutFingerprintsInput, AccountUncheckedCreateWithoutFingerprintsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutFingerprintsInput
    upsert?: AccountUpsertWithoutFingerprintsInput
    disconnect?: boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutFingerprintsInput, AccountUpdateWithoutFingerprintsInput>, AccountUncheckedUpdateWithoutFingerprintsInput>
  }

  export type VisitUpdateManyWithoutFingerprintNestedInput = {
    create?: XOR<VisitCreateWithoutFingerprintInput, VisitUncheckedCreateWithoutFingerprintInput> | VisitCreateWithoutFingerprintInput[] | VisitUncheckedCreateWithoutFingerprintInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutFingerprintInput | VisitCreateOrConnectWithoutFingerprintInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutFingerprintInput | VisitUpsertWithWhereUniqueWithoutFingerprintInput[]
    createMany?: VisitCreateManyFingerprintInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutFingerprintInput | VisitUpdateWithWhereUniqueWithoutFingerprintInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutFingerprintInput | VisitUpdateManyWithWhereWithoutFingerprintInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutFingerprintNestedInput = {
    create?: XOR<VisitCreateWithoutFingerprintInput, VisitUncheckedCreateWithoutFingerprintInput> | VisitCreateWithoutFingerprintInput[] | VisitUncheckedCreateWithoutFingerprintInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutFingerprintInput | VisitCreateOrConnectWithoutFingerprintInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutFingerprintInput | VisitUpsertWithWhereUniqueWithoutFingerprintInput[]
    createMany?: VisitCreateManyFingerprintInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutFingerprintInput | VisitUpdateWithWhereUniqueWithoutFingerprintInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutFingerprintInput | VisitUpdateManyWithWhereWithoutFingerprintInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutAgentsInput = {
    create?: XOR<AccountCreateWithoutAgentsInput, AccountUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAgentsInput
    connect?: AccountWhereUniqueInput
  }

  export type KnowledgeCreateNestedManyWithoutAgentInput = {
    create?: XOR<KnowledgeCreateWithoutAgentInput, KnowledgeUncheckedCreateWithoutAgentInput> | KnowledgeCreateWithoutAgentInput[] | KnowledgeUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: KnowledgeCreateOrConnectWithoutAgentInput | KnowledgeCreateOrConnectWithoutAgentInput[]
    createMany?: KnowledgeCreateManyAgentInputEnvelope
    connect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
  }

  export type MissionCreateNestedManyWithoutAgentInput = {
    create?: XOR<MissionCreateWithoutAgentInput, MissionUncheckedCreateWithoutAgentInput> | MissionCreateWithoutAgentInput[] | MissionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutAgentInput | MissionCreateOrConnectWithoutAgentInput[]
    createMany?: MissionCreateManyAgentInputEnvelope
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type KnowledgeUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<KnowledgeCreateWithoutAgentInput, KnowledgeUncheckedCreateWithoutAgentInput> | KnowledgeCreateWithoutAgentInput[] | KnowledgeUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: KnowledgeCreateOrConnectWithoutAgentInput | KnowledgeCreateOrConnectWithoutAgentInput[]
    createMany?: KnowledgeCreateManyAgentInputEnvelope
    connect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
  }

  export type MissionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<MissionCreateWithoutAgentInput, MissionUncheckedCreateWithoutAgentInput> | MissionCreateWithoutAgentInput[] | MissionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutAgentInput | MissionCreateOrConnectWithoutAgentInput[]
    createMany?: MissionCreateManyAgentInputEnvelope
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<AccountCreateWithoutAgentsInput, AccountUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAgentsInput
    upsert?: AccountUpsertWithoutAgentsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAgentsInput, AccountUpdateWithoutAgentsInput>, AccountUncheckedUpdateWithoutAgentsInput>
  }

  export type KnowledgeUpdateManyWithoutAgentNestedInput = {
    create?: XOR<KnowledgeCreateWithoutAgentInput, KnowledgeUncheckedCreateWithoutAgentInput> | KnowledgeCreateWithoutAgentInput[] | KnowledgeUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: KnowledgeCreateOrConnectWithoutAgentInput | KnowledgeCreateOrConnectWithoutAgentInput[]
    upsert?: KnowledgeUpsertWithWhereUniqueWithoutAgentInput | KnowledgeUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: KnowledgeCreateManyAgentInputEnvelope
    set?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    disconnect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    delete?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    connect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    update?: KnowledgeUpdateWithWhereUniqueWithoutAgentInput | KnowledgeUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: KnowledgeUpdateManyWithWhereWithoutAgentInput | KnowledgeUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: KnowledgeScalarWhereInput | KnowledgeScalarWhereInput[]
  }

  export type MissionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MissionCreateWithoutAgentInput, MissionUncheckedCreateWithoutAgentInput> | MissionCreateWithoutAgentInput[] | MissionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutAgentInput | MissionCreateOrConnectWithoutAgentInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutAgentInput | MissionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MissionCreateManyAgentInputEnvelope
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutAgentInput | MissionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutAgentInput | MissionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type KnowledgeUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<KnowledgeCreateWithoutAgentInput, KnowledgeUncheckedCreateWithoutAgentInput> | KnowledgeCreateWithoutAgentInput[] | KnowledgeUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: KnowledgeCreateOrConnectWithoutAgentInput | KnowledgeCreateOrConnectWithoutAgentInput[]
    upsert?: KnowledgeUpsertWithWhereUniqueWithoutAgentInput | KnowledgeUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: KnowledgeCreateManyAgentInputEnvelope
    set?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    disconnect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    delete?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    connect?: KnowledgeWhereUniqueInput | KnowledgeWhereUniqueInput[]
    update?: KnowledgeUpdateWithWhereUniqueWithoutAgentInput | KnowledgeUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: KnowledgeUpdateManyWithWhereWithoutAgentInput | KnowledgeUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: KnowledgeScalarWhereInput | KnowledgeScalarWhereInput[]
  }

  export type MissionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MissionCreateWithoutAgentInput, MissionUncheckedCreateWithoutAgentInput> | MissionCreateWithoutAgentInput[] | MissionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutAgentInput | MissionCreateOrConnectWithoutAgentInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutAgentInput | MissionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MissionCreateManyAgentInputEnvelope
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutAgentInput | MissionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutAgentInput | MissionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutVisitsInput = {
    create?: XOR<ProfileCreateWithoutVisitsInput, ProfileUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutVisitsInput
    connect?: ProfileWhereUniqueInput
  }

  export type FingerprintCreateNestedOneWithoutVisitsInput = {
    create?: XOR<FingerprintCreateWithoutVisitsInput, FingerprintUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: FingerprintCreateOrConnectWithoutVisitsInput
    connect?: FingerprintWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type ProfileUpdateOneWithoutVisitsNestedInput = {
    create?: XOR<ProfileCreateWithoutVisitsInput, ProfileUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutVisitsInput
    upsert?: ProfileUpsertWithoutVisitsInput
    disconnect?: boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutVisitsInput, ProfileUpdateWithoutVisitsInput>, ProfileUncheckedUpdateWithoutVisitsInput>
  }

  export type FingerprintUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<FingerprintCreateWithoutVisitsInput, FingerprintUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: FingerprintCreateOrConnectWithoutVisitsInput
    upsert?: FingerprintUpsertWithoutVisitsInput
    connect?: FingerprintWhereUniqueInput
    update?: XOR<XOR<FingerprintUpdateToOneWithWhereWithoutVisitsInput, FingerprintUpdateWithoutVisitsInput>, FingerprintUncheckedUpdateWithoutVisitsInput>
  }

  export type ProfileCreateNestedOneWithoutImpressionsInput = {
    create?: XOR<ProfileCreateWithoutImpressionsInput, ProfileUncheckedCreateWithoutImpressionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutImpressionsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutImpressionsNestedInput = {
    create?: XOR<ProfileCreateWithoutImpressionsInput, ProfileUncheckedCreateWithoutImpressionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutImpressionsInput
    upsert?: ProfileUpsertWithoutImpressionsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutImpressionsInput, ProfileUpdateWithoutImpressionsInput>, ProfileUncheckedUpdateWithoutImpressionsInput>
  }

  export type ProfileCreateNestedOneWithoutSocialProfilesInput = {
    create?: XOR<ProfileCreateWithoutSocialProfilesInput, ProfileUncheckedCreateWithoutSocialProfilesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSocialProfilesInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutSocialProfilesNestedInput = {
    create?: XOR<ProfileCreateWithoutSocialProfilesInput, ProfileUncheckedCreateWithoutSocialProfilesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSocialProfilesInput
    upsert?: ProfileUpsertWithoutSocialProfilesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutSocialProfilesInput, ProfileUpdateWithoutSocialProfilesInput>, ProfileUncheckedUpdateWithoutSocialProfilesInput>
  }

  export type AgentCreateNestedOneWithoutKnowledgeInput = {
    create?: XOR<AgentCreateWithoutKnowledgeInput, AgentUncheckedCreateWithoutKnowledgeInput>
    connectOrCreate?: AgentCreateOrConnectWithoutKnowledgeInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutKnowledgeNestedInput = {
    create?: XOR<AgentCreateWithoutKnowledgeInput, AgentUncheckedCreateWithoutKnowledgeInput>
    connectOrCreate?: AgentCreateOrConnectWithoutKnowledgeInput
    upsert?: AgentUpsertWithoutKnowledgeInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutKnowledgeInput, AgentUpdateWithoutKnowledgeInput>, AgentUncheckedUpdateWithoutKnowledgeInput>
  }

  export type AgentCreateNestedOneWithoutMissionsInput = {
    create?: XOR<AgentCreateWithoutMissionsInput, AgentUncheckedCreateWithoutMissionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMissionsInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumMissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.MissionStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type AgentUpdateOneRequiredWithoutMissionsNestedInput = {
    create?: XOR<AgentCreateWithoutMissionsInput, AgentUncheckedCreateWithoutMissionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMissionsInput
    upsert?: AgentUpsertWithoutMissionsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMissionsInput, AgentUpdateWithoutMissionsInput>, AgentUncheckedUpdateWithoutMissionsInput>
  }

  export type AccountCreateNestedOneWithoutProxim8UserInput = {
    create?: XOR<AccountCreateWithoutProxim8UserInput, AccountUncheckedCreateWithoutProxim8UserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProxim8UserInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutProxim8UserNestedInput = {
    create?: XOR<AccountCreateWithoutProxim8UserInput, AccountUncheckedCreateWithoutProxim8UserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProxim8UserInput
    upsert?: AccountUpsertWithoutProxim8UserInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutProxim8UserInput, AccountUpdateWithoutProxim8UserInput>, AccountUncheckedUpdateWithoutProxim8UserInput>
  }

  export type AccountCreateNestedOneWithoutVideosInput = {
    create?: XOR<AccountCreateWithoutVideosInput, AccountUncheckedCreateWithoutVideosInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVideosInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumVideoStatusFieldUpdateOperationsInput = {
    set?: $Enums.VideoStatus
  }

  export type AccountUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<AccountCreateWithoutVideosInput, AccountUncheckedCreateWithoutVideosInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVideosInput
    upsert?: AccountUpsertWithoutVideosInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutVideosInput, AccountUpdateWithoutVideosInput>, AccountUncheckedUpdateWithoutVideosInput>
  }

  export type AccountCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AccountCreateWithoutNotificationsInput, AccountUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNotificationsInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type AccountUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<AccountCreateWithoutNotificationsInput, AccountUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNotificationsInput
    upsert?: AccountUpsertWithoutNotificationsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutNotificationsInput, AccountUpdateWithoutNotificationsInput>, AccountUncheckedUpdateWithoutNotificationsInput>
  }

  export type AccountCreateNestedOneWithoutNftOwnershipsInput = {
    create?: XOR<AccountCreateWithoutNftOwnershipsInput, AccountUncheckedCreateWithoutNftOwnershipsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNftOwnershipsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutNftOwnershipsNestedInput = {
    create?: XOR<AccountCreateWithoutNftOwnershipsInput, AccountUncheckedCreateWithoutNftOwnershipsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNftOwnershipsInput
    upsert?: AccountUpsertWithoutNftOwnershipsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutNftOwnershipsInput, AccountUpdateWithoutNftOwnershipsInput>, AccountUncheckedUpdateWithoutNftOwnershipsInput>
  }

  export type LoreCreatetagsInput = {
    set: string[]
  }

  export type LoreUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumPipelineTypeFieldUpdateOperationsInput = {
    set?: $Enums.PipelineType
  }

  export type EnumPipelineStatusFieldUpdateOperationsInput = {
    set?: $Enums.PipelineStatus
  }

  export type PublicVideoCreatetagsInput = {
    set: string[]
  }

  export type PublicVideoUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccountCreateNestedOneWithoutGameAgentInput = {
    create?: XOR<AccountCreateWithoutGameAgentInput, AccountUncheckedCreateWithoutGameAgentInput>
    connectOrCreate?: AccountCreateOrConnectWithoutGameAgentInput
    connect?: AccountWhereUniqueInput
  }

  export type GameProxim8CreateNestedManyWithoutGameAgentInput = {
    create?: XOR<GameProxim8CreateWithoutGameAgentInput, GameProxim8UncheckedCreateWithoutGameAgentInput> | GameProxim8CreateWithoutGameAgentInput[] | GameProxim8UncheckedCreateWithoutGameAgentInput[]
    connectOrCreate?: GameProxim8CreateOrConnectWithoutGameAgentInput | GameProxim8CreateOrConnectWithoutGameAgentInput[]
    createMany?: GameProxim8CreateManyGameAgentInputEnvelope
    connect?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
  }

  export type TrainingMissionDeploymentCreateNestedManyWithoutGameAgentInput = {
    create?: XOR<TrainingMissionDeploymentCreateWithoutGameAgentInput, TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput> | TrainingMissionDeploymentCreateWithoutGameAgentInput[] | TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput[]
    connectOrCreate?: TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput | TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput[]
    createMany?: TrainingMissionDeploymentCreateManyGameAgentInputEnvelope
    connect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
  }

  export type GameProxim8UncheckedCreateNestedManyWithoutGameAgentInput = {
    create?: XOR<GameProxim8CreateWithoutGameAgentInput, GameProxim8UncheckedCreateWithoutGameAgentInput> | GameProxim8CreateWithoutGameAgentInput[] | GameProxim8UncheckedCreateWithoutGameAgentInput[]
    connectOrCreate?: GameProxim8CreateOrConnectWithoutGameAgentInput | GameProxim8CreateOrConnectWithoutGameAgentInput[]
    createMany?: GameProxim8CreateManyGameAgentInputEnvelope
    connect?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
  }

  export type TrainingMissionDeploymentUncheckedCreateNestedManyWithoutGameAgentInput = {
    create?: XOR<TrainingMissionDeploymentCreateWithoutGameAgentInput, TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput> | TrainingMissionDeploymentCreateWithoutGameAgentInput[] | TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput[]
    connectOrCreate?: TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput | TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput[]
    createMany?: TrainingMissionDeploymentCreateManyGameAgentInputEnvelope
    connect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
  }

  export type EnumAgentRankFieldUpdateOperationsInput = {
    set?: $Enums.AgentRank
  }

  export type AccountUpdateOneRequiredWithoutGameAgentNestedInput = {
    create?: XOR<AccountCreateWithoutGameAgentInput, AccountUncheckedCreateWithoutGameAgentInput>
    connectOrCreate?: AccountCreateOrConnectWithoutGameAgentInput
    upsert?: AccountUpsertWithoutGameAgentInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutGameAgentInput, AccountUpdateWithoutGameAgentInput>, AccountUncheckedUpdateWithoutGameAgentInput>
  }

  export type GameProxim8UpdateManyWithoutGameAgentNestedInput = {
    create?: XOR<GameProxim8CreateWithoutGameAgentInput, GameProxim8UncheckedCreateWithoutGameAgentInput> | GameProxim8CreateWithoutGameAgentInput[] | GameProxim8UncheckedCreateWithoutGameAgentInput[]
    connectOrCreate?: GameProxim8CreateOrConnectWithoutGameAgentInput | GameProxim8CreateOrConnectWithoutGameAgentInput[]
    upsert?: GameProxim8UpsertWithWhereUniqueWithoutGameAgentInput | GameProxim8UpsertWithWhereUniqueWithoutGameAgentInput[]
    createMany?: GameProxim8CreateManyGameAgentInputEnvelope
    set?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
    disconnect?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
    delete?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
    connect?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
    update?: GameProxim8UpdateWithWhereUniqueWithoutGameAgentInput | GameProxim8UpdateWithWhereUniqueWithoutGameAgentInput[]
    updateMany?: GameProxim8UpdateManyWithWhereWithoutGameAgentInput | GameProxim8UpdateManyWithWhereWithoutGameAgentInput[]
    deleteMany?: GameProxim8ScalarWhereInput | GameProxim8ScalarWhereInput[]
  }

  export type TrainingMissionDeploymentUpdateManyWithoutGameAgentNestedInput = {
    create?: XOR<TrainingMissionDeploymentCreateWithoutGameAgentInput, TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput> | TrainingMissionDeploymentCreateWithoutGameAgentInput[] | TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput[]
    connectOrCreate?: TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput | TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput[]
    upsert?: TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameAgentInput | TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameAgentInput[]
    createMany?: TrainingMissionDeploymentCreateManyGameAgentInputEnvelope
    set?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    disconnect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    delete?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    connect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    update?: TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameAgentInput | TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameAgentInput[]
    updateMany?: TrainingMissionDeploymentUpdateManyWithWhereWithoutGameAgentInput | TrainingMissionDeploymentUpdateManyWithWhereWithoutGameAgentInput[]
    deleteMany?: TrainingMissionDeploymentScalarWhereInput | TrainingMissionDeploymentScalarWhereInput[]
  }

  export type GameProxim8UncheckedUpdateManyWithoutGameAgentNestedInput = {
    create?: XOR<GameProxim8CreateWithoutGameAgentInput, GameProxim8UncheckedCreateWithoutGameAgentInput> | GameProxim8CreateWithoutGameAgentInput[] | GameProxim8UncheckedCreateWithoutGameAgentInput[]
    connectOrCreate?: GameProxim8CreateOrConnectWithoutGameAgentInput | GameProxim8CreateOrConnectWithoutGameAgentInput[]
    upsert?: GameProxim8UpsertWithWhereUniqueWithoutGameAgentInput | GameProxim8UpsertWithWhereUniqueWithoutGameAgentInput[]
    createMany?: GameProxim8CreateManyGameAgentInputEnvelope
    set?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
    disconnect?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
    delete?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
    connect?: GameProxim8WhereUniqueInput | GameProxim8WhereUniqueInput[]
    update?: GameProxim8UpdateWithWhereUniqueWithoutGameAgentInput | GameProxim8UpdateWithWhereUniqueWithoutGameAgentInput[]
    updateMany?: GameProxim8UpdateManyWithWhereWithoutGameAgentInput | GameProxim8UpdateManyWithWhereWithoutGameAgentInput[]
    deleteMany?: GameProxim8ScalarWhereInput | GameProxim8ScalarWhereInput[]
  }

  export type TrainingMissionDeploymentUncheckedUpdateManyWithoutGameAgentNestedInput = {
    create?: XOR<TrainingMissionDeploymentCreateWithoutGameAgentInput, TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput> | TrainingMissionDeploymentCreateWithoutGameAgentInput[] | TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput[]
    connectOrCreate?: TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput | TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput[]
    upsert?: TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameAgentInput | TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameAgentInput[]
    createMany?: TrainingMissionDeploymentCreateManyGameAgentInputEnvelope
    set?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    disconnect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    delete?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    connect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    update?: TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameAgentInput | TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameAgentInput[]
    updateMany?: TrainingMissionDeploymentUpdateManyWithWhereWithoutGameAgentInput | TrainingMissionDeploymentUpdateManyWithWhereWithoutGameAgentInput[]
    deleteMany?: TrainingMissionDeploymentScalarWhereInput | TrainingMissionDeploymentScalarWhereInput[]
  }

  export type GameAgentCreateNestedOneWithoutProxim8sInput = {
    create?: XOR<GameAgentCreateWithoutProxim8sInput, GameAgentUncheckedCreateWithoutProxim8sInput>
    connectOrCreate?: GameAgentCreateOrConnectWithoutProxim8sInput
    connect?: GameAgentWhereUniqueInput
  }

  export type TrainingMissionDeploymentCreateNestedManyWithoutGameProxim8Input = {
    create?: XOR<TrainingMissionDeploymentCreateWithoutGameProxim8Input, TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input> | TrainingMissionDeploymentCreateWithoutGameProxim8Input[] | TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input[]
    connectOrCreate?: TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input | TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input[]
    createMany?: TrainingMissionDeploymentCreateManyGameProxim8InputEnvelope
    connect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
  }

  export type TrainingMissionDeploymentUncheckedCreateNestedManyWithoutGameProxim8Input = {
    create?: XOR<TrainingMissionDeploymentCreateWithoutGameProxim8Input, TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input> | TrainingMissionDeploymentCreateWithoutGameProxim8Input[] | TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input[]
    connectOrCreate?: TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input | TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input[]
    createMany?: TrainingMissionDeploymentCreateManyGameProxim8InputEnvelope
    connect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
  }

  export type EnumProxim8PersonalityFieldUpdateOperationsInput = {
    set?: $Enums.Proxim8Personality
  }

  export type GameAgentUpdateOneRequiredWithoutProxim8sNestedInput = {
    create?: XOR<GameAgentCreateWithoutProxim8sInput, GameAgentUncheckedCreateWithoutProxim8sInput>
    connectOrCreate?: GameAgentCreateOrConnectWithoutProxim8sInput
    upsert?: GameAgentUpsertWithoutProxim8sInput
    connect?: GameAgentWhereUniqueInput
    update?: XOR<XOR<GameAgentUpdateToOneWithWhereWithoutProxim8sInput, GameAgentUpdateWithoutProxim8sInput>, GameAgentUncheckedUpdateWithoutProxim8sInput>
  }

  export type TrainingMissionDeploymentUpdateManyWithoutGameProxim8NestedInput = {
    create?: XOR<TrainingMissionDeploymentCreateWithoutGameProxim8Input, TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input> | TrainingMissionDeploymentCreateWithoutGameProxim8Input[] | TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input[]
    connectOrCreate?: TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input | TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input[]
    upsert?: TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameProxim8Input | TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameProxim8Input[]
    createMany?: TrainingMissionDeploymentCreateManyGameProxim8InputEnvelope
    set?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    disconnect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    delete?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    connect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    update?: TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameProxim8Input | TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameProxim8Input[]
    updateMany?: TrainingMissionDeploymentUpdateManyWithWhereWithoutGameProxim8Input | TrainingMissionDeploymentUpdateManyWithWhereWithoutGameProxim8Input[]
    deleteMany?: TrainingMissionDeploymentScalarWhereInput | TrainingMissionDeploymentScalarWhereInput[]
  }

  export type TrainingMissionDeploymentUncheckedUpdateManyWithoutGameProxim8NestedInput = {
    create?: XOR<TrainingMissionDeploymentCreateWithoutGameProxim8Input, TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input> | TrainingMissionDeploymentCreateWithoutGameProxim8Input[] | TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input[]
    connectOrCreate?: TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input | TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input[]
    upsert?: TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameProxim8Input | TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameProxim8Input[]
    createMany?: TrainingMissionDeploymentCreateManyGameProxim8InputEnvelope
    set?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    disconnect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    delete?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    connect?: TrainingMissionDeploymentWhereUniqueInput | TrainingMissionDeploymentWhereUniqueInput[]
    update?: TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameProxim8Input | TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameProxim8Input[]
    updateMany?: TrainingMissionDeploymentUpdateManyWithWhereWithoutGameProxim8Input | TrainingMissionDeploymentUpdateManyWithWhereWithoutGameProxim8Input[]
    deleteMany?: TrainingMissionDeploymentScalarWhereInput | TrainingMissionDeploymentScalarWhereInput[]
  }

  export type GameAgentCreateNestedOneWithoutMissionDeploymentsInput = {
    create?: XOR<GameAgentCreateWithoutMissionDeploymentsInput, GameAgentUncheckedCreateWithoutMissionDeploymentsInput>
    connectOrCreate?: GameAgentCreateOrConnectWithoutMissionDeploymentsInput
    connect?: GameAgentWhereUniqueInput
  }

  export type GameProxim8CreateNestedOneWithoutMissionDeploymentsInput = {
    create?: XOR<GameProxim8CreateWithoutMissionDeploymentsInput, GameProxim8UncheckedCreateWithoutMissionDeploymentsInput>
    connectOrCreate?: GameProxim8CreateOrConnectWithoutMissionDeploymentsInput
    connect?: GameProxim8WhereUniqueInput
  }

  export type EnumMissionApproachFieldUpdateOperationsInput = {
    set?: $Enums.MissionApproach
  }

  export type EnumDeploymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeploymentStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GameAgentUpdateOneRequiredWithoutMissionDeploymentsNestedInput = {
    create?: XOR<GameAgentCreateWithoutMissionDeploymentsInput, GameAgentUncheckedCreateWithoutMissionDeploymentsInput>
    connectOrCreate?: GameAgentCreateOrConnectWithoutMissionDeploymentsInput
    upsert?: GameAgentUpsertWithoutMissionDeploymentsInput
    connect?: GameAgentWhereUniqueInput
    update?: XOR<XOR<GameAgentUpdateToOneWithWhereWithoutMissionDeploymentsInput, GameAgentUpdateWithoutMissionDeploymentsInput>, GameAgentUncheckedUpdateWithoutMissionDeploymentsInput>
  }

  export type GameProxim8UpdateOneRequiredWithoutMissionDeploymentsNestedInput = {
    create?: XOR<GameProxim8CreateWithoutMissionDeploymentsInput, GameProxim8UncheckedCreateWithoutMissionDeploymentsInput>
    connectOrCreate?: GameProxim8CreateOrConnectWithoutMissionDeploymentsInput
    upsert?: GameProxim8UpsertWithoutMissionDeploymentsInput
    connect?: GameProxim8WhereUniqueInput
    update?: XOR<XOR<GameProxim8UpdateToOneWithWhereWithoutMissionDeploymentsInput, GameProxim8UpdateWithoutMissionDeploymentsInput>, GameProxim8UncheckedUpdateWithoutMissionDeploymentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumMissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionStatus | EnumMissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionStatusFilter<$PrismaModel> | $Enums.MissionStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumMissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionStatus | EnumMissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.MissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMissionStatusFilter<$PrismaModel>
    _max?: NestedEnumMissionStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumVideoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoStatus | EnumVideoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoStatusFilter<$PrismaModel> | $Enums.VideoStatus
  }

  export type NestedEnumVideoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoStatus | EnumVideoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoStatusWithAggregatesFilter<$PrismaModel> | $Enums.VideoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoStatusFilter<$PrismaModel>
    _max?: NestedEnumVideoStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumPipelineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PipelineType | EnumPipelineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PipelineType[] | ListEnumPipelineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PipelineType[] | ListEnumPipelineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPipelineTypeFilter<$PrismaModel> | $Enums.PipelineType
  }

  export type NestedEnumPipelineStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PipelineStatus | EnumPipelineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PipelineStatus[] | ListEnumPipelineStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PipelineStatus[] | ListEnumPipelineStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPipelineStatusFilter<$PrismaModel> | $Enums.PipelineStatus
  }

  export type NestedEnumPipelineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PipelineType | EnumPipelineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PipelineType[] | ListEnumPipelineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PipelineType[] | ListEnumPipelineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPipelineTypeWithAggregatesFilter<$PrismaModel> | $Enums.PipelineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPipelineTypeFilter<$PrismaModel>
    _max?: NestedEnumPipelineTypeFilter<$PrismaModel>
  }

  export type NestedEnumPipelineStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PipelineStatus | EnumPipelineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PipelineStatus[] | ListEnumPipelineStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PipelineStatus[] | ListEnumPipelineStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPipelineStatusWithAggregatesFilter<$PrismaModel> | $Enums.PipelineStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPipelineStatusFilter<$PrismaModel>
    _max?: NestedEnumPipelineStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedEnumAgentRankFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentRank | EnumAgentRankFieldRefInput<$PrismaModel>
    in?: $Enums.AgentRank[] | ListEnumAgentRankFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentRank[] | ListEnumAgentRankFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentRankFilter<$PrismaModel> | $Enums.AgentRank
  }

  export type NestedEnumAgentRankWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentRank | EnumAgentRankFieldRefInput<$PrismaModel>
    in?: $Enums.AgentRank[] | ListEnumAgentRankFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentRank[] | ListEnumAgentRankFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentRankWithAggregatesFilter<$PrismaModel> | $Enums.AgentRank
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentRankFilter<$PrismaModel>
    _max?: NestedEnumAgentRankFilter<$PrismaModel>
  }

  export type NestedEnumProxim8PersonalityFilter<$PrismaModel = never> = {
    equals?: $Enums.Proxim8Personality | EnumProxim8PersonalityFieldRefInput<$PrismaModel>
    in?: $Enums.Proxim8Personality[] | ListEnumProxim8PersonalityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Proxim8Personality[] | ListEnumProxim8PersonalityFieldRefInput<$PrismaModel>
    not?: NestedEnumProxim8PersonalityFilter<$PrismaModel> | $Enums.Proxim8Personality
  }

  export type NestedEnumProxim8PersonalityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Proxim8Personality | EnumProxim8PersonalityFieldRefInput<$PrismaModel>
    in?: $Enums.Proxim8Personality[] | ListEnumProxim8PersonalityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Proxim8Personality[] | ListEnumProxim8PersonalityFieldRefInput<$PrismaModel>
    not?: NestedEnumProxim8PersonalityWithAggregatesFilter<$PrismaModel> | $Enums.Proxim8Personality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProxim8PersonalityFilter<$PrismaModel>
    _max?: NestedEnumProxim8PersonalityFilter<$PrismaModel>
  }

  export type NestedEnumMissionApproachFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionApproach | EnumMissionApproachFieldRefInput<$PrismaModel>
    in?: $Enums.MissionApproach[] | ListEnumMissionApproachFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionApproach[] | ListEnumMissionApproachFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionApproachFilter<$PrismaModel> | $Enums.MissionApproach
  }

  export type NestedEnumDeploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusFilter<$PrismaModel> | $Enums.DeploymentStatus
  }

  export type NestedEnumMissionApproachWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionApproach | EnumMissionApproachFieldRefInput<$PrismaModel>
    in?: $Enums.MissionApproach[] | ListEnumMissionApproachFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionApproach[] | ListEnumMissionApproachFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionApproachWithAggregatesFilter<$PrismaModel> | $Enums.MissionApproach
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMissionApproachFilter<$PrismaModel>
    _max?: NestedEnumMissionApproachFilter<$PrismaModel>
  }

  export type NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumDeploymentStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutAccountInput = {
    id?: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitCreateNestedManyWithoutProfileInput
    impressions?: ImpressionCreateNestedManyWithoutProfileInput
    socialProfiles?: SocialProfileCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutAccountInput = {
    id?: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutProfileInput
    impressions?: ImpressionUncheckedCreateNestedManyWithoutProfileInput
    socialProfiles?: SocialProfileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutAccountInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutAccountInput, ProfileUncheckedCreateWithoutAccountInput>
  }

  export type ProfileCreateManyAccountInputEnvelope = {
    data: ProfileCreateManyAccountInput | ProfileCreateManyAccountInput[]
  }

  export type FingerprintCreateWithoutAccountInput = {
    id?: string
    fingerprint: string
    roles?: FingerprintCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitCreateNestedManyWithoutFingerprintInput
  }

  export type FingerprintUncheckedCreateWithoutAccountInput = {
    id?: string
    fingerprint: string
    roles?: FingerprintCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutFingerprintInput
  }

  export type FingerprintCreateOrConnectWithoutAccountInput = {
    where: FingerprintWhereUniqueInput
    create: XOR<FingerprintCreateWithoutAccountInput, FingerprintUncheckedCreateWithoutAccountInput>
  }

  export type FingerprintCreateManyAccountInputEnvelope = {
    data: FingerprintCreateManyAccountInput | FingerprintCreateManyAccountInput[]
  }

  export type AgentCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeCreateNestedManyWithoutAgentInput
    missions?: MissionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutAgentInput
    missions?: MissionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAccountInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAccountInput, AgentUncheckedCreateWithoutAccountInput>
  }

  export type AgentCreateManyAccountInputEnvelope = {
    data: AgentCreateManyAccountInput | AgentCreateManyAccountInput[]
  }

  export type VideoCreateWithoutAccountInput = {
    id?: string
    nftId: string
    jobId: string
    status?: $Enums.VideoStatus
    title?: string | null
    description?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    resolution?: string | null
    isPublic?: boolean
    metadata?: InputJsonValue | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutAccountInput = {
    id?: string
    nftId: string
    jobId: string
    status?: $Enums.VideoStatus
    title?: string | null
    description?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    resolution?: string | null
    isPublic?: boolean
    metadata?: InputJsonValue | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutAccountInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutAccountInput, VideoUncheckedCreateWithoutAccountInput>
  }

  export type VideoCreateManyAccountInputEnvelope = {
    data: VideoCreateManyAccountInput | VideoCreateManyAccountInput[]
  }

  export type NotificationCreateWithoutAccountInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: InputJsonValue | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutAccountInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: InputJsonValue | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutAccountInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
  }

  export type NotificationCreateManyAccountInputEnvelope = {
    data: NotificationCreateManyAccountInput | NotificationCreateManyAccountInput[]
  }

  export type NFTOwnershipCreateWithoutAccountInput = {
    id?: string
    nftId: string
    walletAddress: string
    contractAddress: string
    tokenId: string
    blockchain?: string
    verified?: boolean
    lastVerified?: Date | string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTOwnershipUncheckedCreateWithoutAccountInput = {
    id?: string
    nftId: string
    walletAddress: string
    contractAddress: string
    tokenId: string
    blockchain?: string
    verified?: boolean
    lastVerified?: Date | string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTOwnershipCreateOrConnectWithoutAccountInput = {
    where: NFTOwnershipWhereUniqueInput
    create: XOR<NFTOwnershipCreateWithoutAccountInput, NFTOwnershipUncheckedCreateWithoutAccountInput>
  }

  export type NFTOwnershipCreateManyAccountInputEnvelope = {
    data: NFTOwnershipCreateManyAccountInput | NFTOwnershipCreateManyAccountInput[]
  }

  export type Proxim8UserCreateWithoutAccountInput = {
    id?: string
    username: string
    email?: string | null
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    isAdmin?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    stats?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Proxim8UserUncheckedCreateWithoutAccountInput = {
    id?: string
    username: string
    email?: string | null
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    isAdmin?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    stats?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Proxim8UserCreateOrConnectWithoutAccountInput = {
    where: Proxim8UserWhereUniqueInput
    create: XOR<Proxim8UserCreateWithoutAccountInput, Proxim8UserUncheckedCreateWithoutAccountInput>
  }

  export type GameAgentCreateWithoutAccountInput = {
    id?: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proxim8s?: GameProxim8CreateNestedManyWithoutGameAgentInput
    missionDeployments?: TrainingMissionDeploymentCreateNestedManyWithoutGameAgentInput
  }

  export type GameAgentUncheckedCreateWithoutAccountInput = {
    id?: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proxim8s?: GameProxim8UncheckedCreateNestedManyWithoutGameAgentInput
    missionDeployments?: TrainingMissionDeploymentUncheckedCreateNestedManyWithoutGameAgentInput
  }

  export type GameAgentCreateOrConnectWithoutAccountInput = {
    where: GameAgentWhereUniqueInput
    create: XOR<GameAgentCreateWithoutAccountInput, GameAgentUncheckedCreateWithoutAccountInput>
  }

  export type ProfileUpsertWithWhereUniqueWithoutAccountInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutAccountInput, ProfileUncheckedUpdateWithoutAccountInput>
    create: XOR<ProfileCreateWithoutAccountInput, ProfileUncheckedCreateWithoutAccountInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutAccountInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutAccountInput, ProfileUncheckedUpdateWithoutAccountInput>
  }

  export type ProfileUpdateManyWithWhereWithoutAccountInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutAccountInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: StringFilter<"Profile"> | string
    accountId?: StringFilter<"Profile"> | string
    username?: StringFilter<"Profile"> | string
    bio?: StringNullableFilter<"Profile"> | string | null
    avatar?: StringNullableFilter<"Profile"> | string | null
    isPublic?: BoolFilter<"Profile"> | boolean
    socialLinks?: JsonNullableFilter<"Profile">
    preferences?: JsonNullableFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
  }

  export type FingerprintUpsertWithWhereUniqueWithoutAccountInput = {
    where: FingerprintWhereUniqueInput
    update: XOR<FingerprintUpdateWithoutAccountInput, FingerprintUncheckedUpdateWithoutAccountInput>
    create: XOR<FingerprintCreateWithoutAccountInput, FingerprintUncheckedCreateWithoutAccountInput>
  }

  export type FingerprintUpdateWithWhereUniqueWithoutAccountInput = {
    where: FingerprintWhereUniqueInput
    data: XOR<FingerprintUpdateWithoutAccountInput, FingerprintUncheckedUpdateWithoutAccountInput>
  }

  export type FingerprintUpdateManyWithWhereWithoutAccountInput = {
    where: FingerprintScalarWhereInput
    data: XOR<FingerprintUpdateManyMutationInput, FingerprintUncheckedUpdateManyWithoutAccountInput>
  }

  export type FingerprintScalarWhereInput = {
    AND?: FingerprintScalarWhereInput | FingerprintScalarWhereInput[]
    OR?: FingerprintScalarWhereInput[]
    NOT?: FingerprintScalarWhereInput | FingerprintScalarWhereInput[]
    id?: StringFilter<"Fingerprint"> | string
    accountId?: StringNullableFilter<"Fingerprint"> | string | null
    fingerprint?: StringFilter<"Fingerprint"> | string
    roles?: StringNullableListFilter<"Fingerprint">
    createdAt?: DateTimeFilter<"Fingerprint"> | Date | string
    updatedAt?: DateTimeFilter<"Fingerprint"> | Date | string
  }

  export type AgentUpsertWithWhereUniqueWithoutAccountInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutAccountInput, AgentUncheckedUpdateWithoutAccountInput>
    create: XOR<AgentCreateWithoutAccountInput, AgentUncheckedCreateWithoutAccountInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutAccountInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutAccountInput, AgentUncheckedUpdateWithoutAccountInput>
  }

  export type AgentUpdateManyWithWhereWithoutAccountInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutAccountInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: StringFilter<"Agent"> | string
    accountId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    avatar?: StringNullableFilter<"Agent"> | string | null
    isActive?: BoolFilter<"Agent"> | boolean
    config?: JsonNullableFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
  }

  export type VideoUpsertWithWhereUniqueWithoutAccountInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutAccountInput, VideoUncheckedUpdateWithoutAccountInput>
    create: XOR<VideoCreateWithoutAccountInput, VideoUncheckedCreateWithoutAccountInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutAccountInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutAccountInput, VideoUncheckedUpdateWithoutAccountInput>
  }

  export type VideoUpdateManyWithWhereWithoutAccountInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutAccountInput>
  }

  export type VideoScalarWhereInput = {
    AND?: VideoScalarWhereInput | VideoScalarWhereInput[]
    OR?: VideoScalarWhereInput[]
    NOT?: VideoScalarWhereInput | VideoScalarWhereInput[]
    id?: StringFilter<"Video"> | string
    accountId?: StringFilter<"Video"> | string
    nftId?: StringFilter<"Video"> | string
    jobId?: StringFilter<"Video"> | string
    status?: EnumVideoStatusFilter<"Video"> | $Enums.VideoStatus
    title?: StringNullableFilter<"Video"> | string | null
    description?: StringNullableFilter<"Video"> | string | null
    videoUrl?: StringNullableFilter<"Video"> | string | null
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: IntNullableFilter<"Video"> | number | null
    resolution?: StringNullableFilter<"Video"> | string | null
    isPublic?: BoolFilter<"Video"> | boolean
    metadata?: JsonNullableFilter<"Video">
    errorMessage?: StringNullableFilter<"Video"> | string | null
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutAccountInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAccountInput, NotificationUncheckedUpdateWithoutAccountInput>
    create: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAccountInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAccountInput, NotificationUncheckedUpdateWithoutAccountInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAccountInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAccountInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    accountId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NFTOwnershipUpsertWithWhereUniqueWithoutAccountInput = {
    where: NFTOwnershipWhereUniqueInput
    update: XOR<NFTOwnershipUpdateWithoutAccountInput, NFTOwnershipUncheckedUpdateWithoutAccountInput>
    create: XOR<NFTOwnershipCreateWithoutAccountInput, NFTOwnershipUncheckedCreateWithoutAccountInput>
  }

  export type NFTOwnershipUpdateWithWhereUniqueWithoutAccountInput = {
    where: NFTOwnershipWhereUniqueInput
    data: XOR<NFTOwnershipUpdateWithoutAccountInput, NFTOwnershipUncheckedUpdateWithoutAccountInput>
  }

  export type NFTOwnershipUpdateManyWithWhereWithoutAccountInput = {
    where: NFTOwnershipScalarWhereInput
    data: XOR<NFTOwnershipUpdateManyMutationInput, NFTOwnershipUncheckedUpdateManyWithoutAccountInput>
  }

  export type NFTOwnershipScalarWhereInput = {
    AND?: NFTOwnershipScalarWhereInput | NFTOwnershipScalarWhereInput[]
    OR?: NFTOwnershipScalarWhereInput[]
    NOT?: NFTOwnershipScalarWhereInput | NFTOwnershipScalarWhereInput[]
    id?: StringFilter<"NFTOwnership"> | string
    nftId?: StringFilter<"NFTOwnership"> | string
    accountId?: StringFilter<"NFTOwnership"> | string
    walletAddress?: StringFilter<"NFTOwnership"> | string
    contractAddress?: StringFilter<"NFTOwnership"> | string
    tokenId?: StringFilter<"NFTOwnership"> | string
    blockchain?: StringFilter<"NFTOwnership"> | string
    verified?: BoolFilter<"NFTOwnership"> | boolean
    lastVerified?: DateTimeNullableFilter<"NFTOwnership"> | Date | string | null
    metadata?: JsonNullableFilter<"NFTOwnership">
    createdAt?: DateTimeFilter<"NFTOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"NFTOwnership"> | Date | string
  }

  export type Proxim8UserUpsertWithoutAccountInput = {
    update: XOR<Proxim8UserUpdateWithoutAccountInput, Proxim8UserUncheckedUpdateWithoutAccountInput>
    create: XOR<Proxim8UserCreateWithoutAccountInput, Proxim8UserUncheckedCreateWithoutAccountInput>
    where?: Proxim8UserWhereInput
  }

  export type Proxim8UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: Proxim8UserWhereInput
    data: XOR<Proxim8UserUpdateWithoutAccountInput, Proxim8UserUncheckedUpdateWithoutAccountInput>
  }

  export type Proxim8UserUpdateWithoutAccountInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    stats?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Proxim8UserUncheckedUpdateWithoutAccountInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    stats?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAgentUpsertWithoutAccountInput = {
    update: XOR<GameAgentUpdateWithoutAccountInput, GameAgentUncheckedUpdateWithoutAccountInput>
    create: XOR<GameAgentCreateWithoutAccountInput, GameAgentUncheckedCreateWithoutAccountInput>
    where?: GameAgentWhereInput
  }

  export type GameAgentUpdateToOneWithWhereWithoutAccountInput = {
    where?: GameAgentWhereInput
    data: XOR<GameAgentUpdateWithoutAccountInput, GameAgentUncheckedUpdateWithoutAccountInput>
  }

  export type GameAgentUpdateWithoutAccountInput = {
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxim8s?: GameProxim8UpdateManyWithoutGameAgentNestedInput
    missionDeployments?: TrainingMissionDeploymentUpdateManyWithoutGameAgentNestedInput
  }

  export type GameAgentUncheckedUpdateWithoutAccountInput = {
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxim8s?: GameProxim8UncheckedUpdateManyWithoutGameAgentNestedInput
    missionDeployments?: TrainingMissionDeploymentUncheckedUpdateManyWithoutGameAgentNestedInput
  }

  export type AccountCreateWithoutProfilesInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fingerprints?: FingerprintCreateNestedManyWithoutAccountInput
    agents?: AgentCreateNestedManyWithoutAccountInput
    videos?: VideoCreateNestedManyWithoutAccountInput
    notifications?: NotificationCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutProfilesInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fingerprints?: FingerprintUncheckedCreateNestedManyWithoutAccountInput
    agents?: AgentUncheckedCreateNestedManyWithoutAccountInput
    videos?: VideoUncheckedCreateNestedManyWithoutAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserUncheckedCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutProfilesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutProfilesInput, AccountUncheckedCreateWithoutProfilesInput>
  }

  export type VisitCreateWithoutProfileInput = {
    id?: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
    fingerprint: FingerprintCreateNestedOneWithoutVisitsInput
  }

  export type VisitUncheckedCreateWithoutProfileInput = {
    id?: string
    fingerprintId: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type VisitCreateOrConnectWithoutProfileInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutProfileInput, VisitUncheckedCreateWithoutProfileInput>
  }

  export type VisitCreateManyProfileInputEnvelope = {
    data: VisitCreateManyProfileInput | VisitCreateManyProfileInput[]
  }

  export type ImpressionCreateWithoutProfileInput = {
    id?: string
    type: string
    context?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type ImpressionUncheckedCreateWithoutProfileInput = {
    id?: string
    type: string
    context?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type ImpressionCreateOrConnectWithoutProfileInput = {
    where: ImpressionWhereUniqueInput
    create: XOR<ImpressionCreateWithoutProfileInput, ImpressionUncheckedCreateWithoutProfileInput>
  }

  export type ImpressionCreateManyProfileInputEnvelope = {
    data: ImpressionCreateManyProfileInput | ImpressionCreateManyProfileInput[]
  }

  export type SocialProfileCreateWithoutProfileInput = {
    id?: string
    platform: string
    username: string
    url?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialProfileUncheckedCreateWithoutProfileInput = {
    id?: string
    platform: string
    username: string
    url?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialProfileCreateOrConnectWithoutProfileInput = {
    where: SocialProfileWhereUniqueInput
    create: XOR<SocialProfileCreateWithoutProfileInput, SocialProfileUncheckedCreateWithoutProfileInput>
  }

  export type SocialProfileCreateManyProfileInputEnvelope = {
    data: SocialProfileCreateManyProfileInput | SocialProfileCreateManyProfileInput[]
  }

  export type AccountUpsertWithoutProfilesInput = {
    update: XOR<AccountUpdateWithoutProfilesInput, AccountUncheckedUpdateWithoutProfilesInput>
    create: XOR<AccountCreateWithoutProfilesInput, AccountUncheckedCreateWithoutProfilesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutProfilesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutProfilesInput, AccountUncheckedUpdateWithoutProfilesInput>
  }

  export type AccountUpdateWithoutProfilesInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fingerprints?: FingerprintUpdateManyWithoutAccountNestedInput
    agents?: AgentUpdateManyWithoutAccountNestedInput
    videos?: VideoUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutProfilesInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fingerprints?: FingerprintUncheckedUpdateManyWithoutAccountNestedInput
    agents?: AgentUncheckedUpdateManyWithoutAccountNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type VisitUpsertWithWhereUniqueWithoutProfileInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutProfileInput, VisitUncheckedUpdateWithoutProfileInput>
    create: XOR<VisitCreateWithoutProfileInput, VisitUncheckedCreateWithoutProfileInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutProfileInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutProfileInput, VisitUncheckedUpdateWithoutProfileInput>
  }

  export type VisitUpdateManyWithWhereWithoutProfileInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutProfileInput>
  }

  export type VisitScalarWhereInput = {
    AND?: VisitScalarWhereInput | VisitScalarWhereInput[]
    OR?: VisitScalarWhereInput[]
    NOT?: VisitScalarWhereInput | VisitScalarWhereInput[]
    id?: StringFilter<"Visit"> | string
    profileId?: StringNullableFilter<"Visit"> | string | null
    fingerprintId?: StringFilter<"Visit"> | string
    path?: StringFilter<"Visit"> | string
    userAgent?: StringNullableFilter<"Visit"> | string | null
    ipAddress?: StringNullableFilter<"Visit"> | string | null
    referrer?: StringNullableFilter<"Visit"> | string | null
    duration?: IntNullableFilter<"Visit"> | number | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
  }

  export type ImpressionUpsertWithWhereUniqueWithoutProfileInput = {
    where: ImpressionWhereUniqueInput
    update: XOR<ImpressionUpdateWithoutProfileInput, ImpressionUncheckedUpdateWithoutProfileInput>
    create: XOR<ImpressionCreateWithoutProfileInput, ImpressionUncheckedCreateWithoutProfileInput>
  }

  export type ImpressionUpdateWithWhereUniqueWithoutProfileInput = {
    where: ImpressionWhereUniqueInput
    data: XOR<ImpressionUpdateWithoutProfileInput, ImpressionUncheckedUpdateWithoutProfileInput>
  }

  export type ImpressionUpdateManyWithWhereWithoutProfileInput = {
    where: ImpressionScalarWhereInput
    data: XOR<ImpressionUpdateManyMutationInput, ImpressionUncheckedUpdateManyWithoutProfileInput>
  }

  export type ImpressionScalarWhereInput = {
    AND?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
    OR?: ImpressionScalarWhereInput[]
    NOT?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
    id?: StringFilter<"Impression"> | string
    profileId?: StringFilter<"Impression"> | string
    type?: StringFilter<"Impression"> | string
    context?: JsonNullableFilter<"Impression">
    createdAt?: DateTimeFilter<"Impression"> | Date | string
  }

  export type SocialProfileUpsertWithWhereUniqueWithoutProfileInput = {
    where: SocialProfileWhereUniqueInput
    update: XOR<SocialProfileUpdateWithoutProfileInput, SocialProfileUncheckedUpdateWithoutProfileInput>
    create: XOR<SocialProfileCreateWithoutProfileInput, SocialProfileUncheckedCreateWithoutProfileInput>
  }

  export type SocialProfileUpdateWithWhereUniqueWithoutProfileInput = {
    where: SocialProfileWhereUniqueInput
    data: XOR<SocialProfileUpdateWithoutProfileInput, SocialProfileUncheckedUpdateWithoutProfileInput>
  }

  export type SocialProfileUpdateManyWithWhereWithoutProfileInput = {
    where: SocialProfileScalarWhereInput
    data: XOR<SocialProfileUpdateManyMutationInput, SocialProfileUncheckedUpdateManyWithoutProfileInput>
  }

  export type SocialProfileScalarWhereInput = {
    AND?: SocialProfileScalarWhereInput | SocialProfileScalarWhereInput[]
    OR?: SocialProfileScalarWhereInput[]
    NOT?: SocialProfileScalarWhereInput | SocialProfileScalarWhereInput[]
    id?: StringFilter<"SocialProfile"> | string
    profileId?: StringFilter<"SocialProfile"> | string
    platform?: StringFilter<"SocialProfile"> | string
    username?: StringFilter<"SocialProfile"> | string
    url?: StringNullableFilter<"SocialProfile"> | string | null
    verified?: BoolFilter<"SocialProfile"> | boolean
    createdAt?: DateTimeFilter<"SocialProfile"> | Date | string
    updatedAt?: DateTimeFilter<"SocialProfile"> | Date | string
  }

  export type AccountCreateWithoutFingerprintsInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileCreateNestedManyWithoutAccountInput
    agents?: AgentCreateNestedManyWithoutAccountInput
    videos?: VideoCreateNestedManyWithoutAccountInput
    notifications?: NotificationCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutFingerprintsInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutAccountInput
    agents?: AgentUncheckedCreateNestedManyWithoutAccountInput
    videos?: VideoUncheckedCreateNestedManyWithoutAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserUncheckedCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutFingerprintsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutFingerprintsInput, AccountUncheckedCreateWithoutFingerprintsInput>
  }

  export type VisitCreateWithoutFingerprintInput = {
    id?: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutVisitsInput
  }

  export type VisitUncheckedCreateWithoutFingerprintInput = {
    id?: string
    profileId?: string | null
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type VisitCreateOrConnectWithoutFingerprintInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutFingerprintInput, VisitUncheckedCreateWithoutFingerprintInput>
  }

  export type VisitCreateManyFingerprintInputEnvelope = {
    data: VisitCreateManyFingerprintInput | VisitCreateManyFingerprintInput[]
  }

  export type AccountUpsertWithoutFingerprintsInput = {
    update: XOR<AccountUpdateWithoutFingerprintsInput, AccountUncheckedUpdateWithoutFingerprintsInput>
    create: XOR<AccountCreateWithoutFingerprintsInput, AccountUncheckedCreateWithoutFingerprintsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutFingerprintsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutFingerprintsInput, AccountUncheckedUpdateWithoutFingerprintsInput>
  }

  export type AccountUpdateWithoutFingerprintsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUpdateManyWithoutAccountNestedInput
    agents?: AgentUpdateManyWithoutAccountNestedInput
    videos?: VideoUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutFingerprintsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutAccountNestedInput
    agents?: AgentUncheckedUpdateManyWithoutAccountNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type VisitUpsertWithWhereUniqueWithoutFingerprintInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutFingerprintInput, VisitUncheckedUpdateWithoutFingerprintInput>
    create: XOR<VisitCreateWithoutFingerprintInput, VisitUncheckedCreateWithoutFingerprintInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutFingerprintInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutFingerprintInput, VisitUncheckedUpdateWithoutFingerprintInput>
  }

  export type VisitUpdateManyWithWhereWithoutFingerprintInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutFingerprintInput>
  }

  export type AccountCreateWithoutAgentsInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintCreateNestedManyWithoutAccountInput
    videos?: VideoCreateNestedManyWithoutAccountInput
    notifications?: NotificationCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutAgentsInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintUncheckedCreateNestedManyWithoutAccountInput
    videos?: VideoUncheckedCreateNestedManyWithoutAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserUncheckedCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutAgentsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAgentsInput, AccountUncheckedCreateWithoutAgentsInput>
  }

  export type KnowledgeCreateWithoutAgentInput = {
    id?: string
    title: string
    content: string
    type: string
    source?: string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUncheckedCreateWithoutAgentInput = {
    id?: string
    title: string
    content: string
    type: string
    source?: string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeCreateOrConnectWithoutAgentInput = {
    where: KnowledgeWhereUniqueInput
    create: XOR<KnowledgeCreateWithoutAgentInput, KnowledgeUncheckedCreateWithoutAgentInput>
  }

  export type KnowledgeCreateManyAgentInputEnvelope = {
    data: KnowledgeCreateManyAgentInput | KnowledgeCreateManyAgentInput[]
  }

  export type MissionCreateWithoutAgentInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.MissionStatus
    priority?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionUncheckedCreateWithoutAgentInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.MissionStatus
    priority?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionCreateOrConnectWithoutAgentInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutAgentInput, MissionUncheckedCreateWithoutAgentInput>
  }

  export type MissionCreateManyAgentInputEnvelope = {
    data: MissionCreateManyAgentInput | MissionCreateManyAgentInput[]
  }

  export type AccountUpsertWithoutAgentsInput = {
    update: XOR<AccountUpdateWithoutAgentsInput, AccountUncheckedUpdateWithoutAgentsInput>
    create: XOR<AccountCreateWithoutAgentsInput, AccountUncheckedCreateWithoutAgentsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAgentsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAgentsInput, AccountUncheckedUpdateWithoutAgentsInput>
  }

  export type AccountUpdateWithoutAgentsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUpdateManyWithoutAccountNestedInput
    videos?: VideoUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutAgentsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUncheckedUpdateManyWithoutAccountNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type KnowledgeUpsertWithWhereUniqueWithoutAgentInput = {
    where: KnowledgeWhereUniqueInput
    update: XOR<KnowledgeUpdateWithoutAgentInput, KnowledgeUncheckedUpdateWithoutAgentInput>
    create: XOR<KnowledgeCreateWithoutAgentInput, KnowledgeUncheckedCreateWithoutAgentInput>
  }

  export type KnowledgeUpdateWithWhereUniqueWithoutAgentInput = {
    where: KnowledgeWhereUniqueInput
    data: XOR<KnowledgeUpdateWithoutAgentInput, KnowledgeUncheckedUpdateWithoutAgentInput>
  }

  export type KnowledgeUpdateManyWithWhereWithoutAgentInput = {
    where: KnowledgeScalarWhereInput
    data: XOR<KnowledgeUpdateManyMutationInput, KnowledgeUncheckedUpdateManyWithoutAgentInput>
  }

  export type KnowledgeScalarWhereInput = {
    AND?: KnowledgeScalarWhereInput | KnowledgeScalarWhereInput[]
    OR?: KnowledgeScalarWhereInput[]
    NOT?: KnowledgeScalarWhereInput | KnowledgeScalarWhereInput[]
    id?: StringFilter<"Knowledge"> | string
    agentId?: StringFilter<"Knowledge"> | string
    title?: StringFilter<"Knowledge"> | string
    content?: StringFilter<"Knowledge"> | string
    type?: StringFilter<"Knowledge"> | string
    source?: StringNullableFilter<"Knowledge"> | string | null
    metadata?: JsonNullableFilter<"Knowledge">
    createdAt?: DateTimeFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeFilter<"Knowledge"> | Date | string
  }

  export type MissionUpsertWithWhereUniqueWithoutAgentInput = {
    where: MissionWhereUniqueInput
    update: XOR<MissionUpdateWithoutAgentInput, MissionUncheckedUpdateWithoutAgentInput>
    create: XOR<MissionCreateWithoutAgentInput, MissionUncheckedCreateWithoutAgentInput>
  }

  export type MissionUpdateWithWhereUniqueWithoutAgentInput = {
    where: MissionWhereUniqueInput
    data: XOR<MissionUpdateWithoutAgentInput, MissionUncheckedUpdateWithoutAgentInput>
  }

  export type MissionUpdateManyWithWhereWithoutAgentInput = {
    where: MissionScalarWhereInput
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyWithoutAgentInput>
  }

  export type MissionScalarWhereInput = {
    AND?: MissionScalarWhereInput | MissionScalarWhereInput[]
    OR?: MissionScalarWhereInput[]
    NOT?: MissionScalarWhereInput | MissionScalarWhereInput[]
    id?: StringFilter<"Mission"> | string
    agentId?: StringFilter<"Mission"> | string
    title?: StringFilter<"Mission"> | string
    description?: StringFilter<"Mission"> | string
    status?: EnumMissionStatusFilter<"Mission"> | $Enums.MissionStatus
    priority?: IntFilter<"Mission"> | number
    dueDate?: DateTimeNullableFilter<"Mission"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Mission"> | Date | string | null
    result?: JsonNullableFilter<"Mission">
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
  }

  export type ProfileCreateWithoutVisitsInput = {
    id?: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutProfilesInput
    impressions?: ImpressionCreateNestedManyWithoutProfileInput
    socialProfiles?: SocialProfileCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutVisitsInput = {
    id?: string
    accountId: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    impressions?: ImpressionUncheckedCreateNestedManyWithoutProfileInput
    socialProfiles?: SocialProfileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutVisitsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutVisitsInput, ProfileUncheckedCreateWithoutVisitsInput>
  }

  export type FingerprintCreateWithoutVisitsInput = {
    id?: string
    fingerprint: string
    roles?: FingerprintCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutFingerprintsInput
  }

  export type FingerprintUncheckedCreateWithoutVisitsInput = {
    id?: string
    accountId?: string | null
    fingerprint: string
    roles?: FingerprintCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FingerprintCreateOrConnectWithoutVisitsInput = {
    where: FingerprintWhereUniqueInput
    create: XOR<FingerprintCreateWithoutVisitsInput, FingerprintUncheckedCreateWithoutVisitsInput>
  }

  export type ProfileUpsertWithoutVisitsInput = {
    update: XOR<ProfileUpdateWithoutVisitsInput, ProfileUncheckedUpdateWithoutVisitsInput>
    create: XOR<ProfileCreateWithoutVisitsInput, ProfileUncheckedCreateWithoutVisitsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutVisitsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutVisitsInput, ProfileUncheckedUpdateWithoutVisitsInput>
  }

  export type ProfileUpdateWithoutVisitsInput = {
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutProfilesNestedInput
    impressions?: ImpressionUpdateManyWithoutProfileNestedInput
    socialProfiles?: SocialProfileUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutVisitsInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: ImpressionUncheckedUpdateManyWithoutProfileNestedInput
    socialProfiles?: SocialProfileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type FingerprintUpsertWithoutVisitsInput = {
    update: XOR<FingerprintUpdateWithoutVisitsInput, FingerprintUncheckedUpdateWithoutVisitsInput>
    create: XOR<FingerprintCreateWithoutVisitsInput, FingerprintUncheckedCreateWithoutVisitsInput>
    where?: FingerprintWhereInput
  }

  export type FingerprintUpdateToOneWithWhereWithoutVisitsInput = {
    where?: FingerprintWhereInput
    data: XOR<FingerprintUpdateWithoutVisitsInput, FingerprintUncheckedUpdateWithoutVisitsInput>
  }

  export type FingerprintUpdateWithoutVisitsInput = {
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutFingerprintsNestedInput
  }

  export type FingerprintUncheckedUpdateWithoutVisitsInput = {
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateWithoutImpressionsInput = {
    id?: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutProfilesInput
    visits?: VisitCreateNestedManyWithoutProfileInput
    socialProfiles?: SocialProfileCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutImpressionsInput = {
    id?: string
    accountId: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutProfileInput
    socialProfiles?: SocialProfileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutImpressionsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutImpressionsInput, ProfileUncheckedCreateWithoutImpressionsInput>
  }

  export type ProfileUpsertWithoutImpressionsInput = {
    update: XOR<ProfileUpdateWithoutImpressionsInput, ProfileUncheckedUpdateWithoutImpressionsInput>
    create: XOR<ProfileCreateWithoutImpressionsInput, ProfileUncheckedCreateWithoutImpressionsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutImpressionsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutImpressionsInput, ProfileUncheckedUpdateWithoutImpressionsInput>
  }

  export type ProfileUpdateWithoutImpressionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutProfilesNestedInput
    visits?: VisitUpdateManyWithoutProfileNestedInput
    socialProfiles?: SocialProfileUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutImpressionsInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutProfileNestedInput
    socialProfiles?: SocialProfileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutSocialProfilesInput = {
    id?: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutProfilesInput
    visits?: VisitCreateNestedManyWithoutProfileInput
    impressions?: ImpressionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutSocialProfilesInput = {
    id?: string
    accountId: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutProfileInput
    impressions?: ImpressionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutSocialProfilesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSocialProfilesInput, ProfileUncheckedCreateWithoutSocialProfilesInput>
  }

  export type ProfileUpsertWithoutSocialProfilesInput = {
    update: XOR<ProfileUpdateWithoutSocialProfilesInput, ProfileUncheckedUpdateWithoutSocialProfilesInput>
    create: XOR<ProfileCreateWithoutSocialProfilesInput, ProfileUncheckedCreateWithoutSocialProfilesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutSocialProfilesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutSocialProfilesInput, ProfileUncheckedUpdateWithoutSocialProfilesInput>
  }

  export type ProfileUpdateWithoutSocialProfilesInput = {
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutProfilesNestedInput
    visits?: VisitUpdateManyWithoutProfileNestedInput
    impressions?: ImpressionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSocialProfilesInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutProfileNestedInput
    impressions?: ImpressionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type AgentCreateWithoutKnowledgeInput = {
    id?: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAgentsInput
    missions?: MissionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutKnowledgeInput = {
    id?: string
    accountId: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    missions?: MissionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutKnowledgeInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutKnowledgeInput, AgentUncheckedCreateWithoutKnowledgeInput>
  }

  export type AgentUpsertWithoutKnowledgeInput = {
    update: XOR<AgentUpdateWithoutKnowledgeInput, AgentUncheckedUpdateWithoutKnowledgeInput>
    create: XOR<AgentCreateWithoutKnowledgeInput, AgentUncheckedCreateWithoutKnowledgeInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutKnowledgeInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutKnowledgeInput, AgentUncheckedUpdateWithoutKnowledgeInput>
  }

  export type AgentUpdateWithoutKnowledgeInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAgentsNestedInput
    missions?: MissionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutKnowledgeInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    missions?: MissionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutMissionsInput = {
    id?: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAgentsInput
    knowledge?: KnowledgeCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutMissionsInput = {
    id?: string
    accountId: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge?: KnowledgeUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutMissionsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMissionsInput, AgentUncheckedCreateWithoutMissionsInput>
  }

  export type AgentUpsertWithoutMissionsInput = {
    update: XOR<AgentUpdateWithoutMissionsInput, AgentUncheckedUpdateWithoutMissionsInput>
    create: XOR<AgentCreateWithoutMissionsInput, AgentUncheckedCreateWithoutMissionsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMissionsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMissionsInput, AgentUncheckedUpdateWithoutMissionsInput>
  }

  export type AgentUpdateWithoutMissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAgentsNestedInput
    knowledge?: KnowledgeUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutMissionsInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AccountCreateWithoutProxim8UserInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintCreateNestedManyWithoutAccountInput
    agents?: AgentCreateNestedManyWithoutAccountInput
    videos?: VideoCreateNestedManyWithoutAccountInput
    notifications?: NotificationCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipCreateNestedManyWithoutAccountInput
    gameAgent?: GameAgentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutProxim8UserInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintUncheckedCreateNestedManyWithoutAccountInput
    agents?: AgentUncheckedCreateNestedManyWithoutAccountInput
    videos?: VideoUncheckedCreateNestedManyWithoutAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput
    gameAgent?: GameAgentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutProxim8UserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutProxim8UserInput, AccountUncheckedCreateWithoutProxim8UserInput>
  }

  export type AccountUpsertWithoutProxim8UserInput = {
    update: XOR<AccountUpdateWithoutProxim8UserInput, AccountUncheckedUpdateWithoutProxim8UserInput>
    create: XOR<AccountCreateWithoutProxim8UserInput, AccountUncheckedCreateWithoutProxim8UserInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutProxim8UserInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutProxim8UserInput, AccountUncheckedUpdateWithoutProxim8UserInput>
  }

  export type AccountUpdateWithoutProxim8UserInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUpdateManyWithoutAccountNestedInput
    agents?: AgentUpdateManyWithoutAccountNestedInput
    videos?: VideoUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUpdateManyWithoutAccountNestedInput
    gameAgent?: GameAgentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutProxim8UserInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUncheckedUpdateManyWithoutAccountNestedInput
    agents?: AgentUncheckedUpdateManyWithoutAccountNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput
    gameAgent?: GameAgentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountCreateWithoutVideosInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintCreateNestedManyWithoutAccountInput
    agents?: AgentCreateNestedManyWithoutAccountInput
    notifications?: NotificationCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutVideosInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintUncheckedCreateNestedManyWithoutAccountInput
    agents?: AgentUncheckedCreateNestedManyWithoutAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserUncheckedCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutVideosInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutVideosInput, AccountUncheckedCreateWithoutVideosInput>
  }

  export type AccountUpsertWithoutVideosInput = {
    update: XOR<AccountUpdateWithoutVideosInput, AccountUncheckedUpdateWithoutVideosInput>
    create: XOR<AccountCreateWithoutVideosInput, AccountUncheckedCreateWithoutVideosInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutVideosInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutVideosInput, AccountUncheckedUpdateWithoutVideosInput>
  }

  export type AccountUpdateWithoutVideosInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUpdateManyWithoutAccountNestedInput
    agents?: AgentUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutVideosInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUncheckedUpdateManyWithoutAccountNestedInput
    agents?: AgentUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountCreateWithoutNotificationsInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintCreateNestedManyWithoutAccountInput
    agents?: AgentCreateNestedManyWithoutAccountInput
    videos?: VideoCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutNotificationsInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintUncheckedCreateNestedManyWithoutAccountInput
    agents?: AgentUncheckedCreateNestedManyWithoutAccountInput
    videos?: VideoUncheckedCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserUncheckedCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutNotificationsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutNotificationsInput, AccountUncheckedCreateWithoutNotificationsInput>
  }

  export type AccountUpsertWithoutNotificationsInput = {
    update: XOR<AccountUpdateWithoutNotificationsInput, AccountUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AccountCreateWithoutNotificationsInput, AccountUncheckedCreateWithoutNotificationsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutNotificationsInput, AccountUncheckedUpdateWithoutNotificationsInput>
  }

  export type AccountUpdateWithoutNotificationsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUpdateManyWithoutAccountNestedInput
    agents?: AgentUpdateManyWithoutAccountNestedInput
    videos?: VideoUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutNotificationsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUncheckedUpdateManyWithoutAccountNestedInput
    agents?: AgentUncheckedUpdateManyWithoutAccountNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountCreateWithoutNftOwnershipsInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintCreateNestedManyWithoutAccountInput
    agents?: AgentCreateNestedManyWithoutAccountInput
    videos?: VideoCreateNestedManyWithoutAccountInput
    notifications?: NotificationCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutNftOwnershipsInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintUncheckedCreateNestedManyWithoutAccountInput
    agents?: AgentUncheckedCreateNestedManyWithoutAccountInput
    videos?: VideoUncheckedCreateNestedManyWithoutAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserUncheckedCreateNestedOneWithoutAccountInput
    gameAgent?: GameAgentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutNftOwnershipsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutNftOwnershipsInput, AccountUncheckedCreateWithoutNftOwnershipsInput>
  }

  export type AccountUpsertWithoutNftOwnershipsInput = {
    update: XOR<AccountUpdateWithoutNftOwnershipsInput, AccountUncheckedUpdateWithoutNftOwnershipsInput>
    create: XOR<AccountCreateWithoutNftOwnershipsInput, AccountUncheckedCreateWithoutNftOwnershipsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutNftOwnershipsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutNftOwnershipsInput, AccountUncheckedUpdateWithoutNftOwnershipsInput>
  }

  export type AccountUpdateWithoutNftOwnershipsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUpdateManyWithoutAccountNestedInput
    agents?: AgentUpdateManyWithoutAccountNestedInput
    videos?: VideoUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutNftOwnershipsInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUncheckedUpdateManyWithoutAccountNestedInput
    agents?: AgentUncheckedUpdateManyWithoutAccountNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput
    gameAgent?: GameAgentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountCreateWithoutGameAgentInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintCreateNestedManyWithoutAccountInput
    agents?: AgentCreateNestedManyWithoutAccountInput
    videos?: VideoCreateNestedManyWithoutAccountInput
    notifications?: NotificationCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutGameAgentInput = {
    id?: string
    walletAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutAccountInput
    fingerprints?: FingerprintUncheckedCreateNestedManyWithoutAccountInput
    agents?: AgentUncheckedCreateNestedManyWithoutAccountInput
    videos?: VideoUncheckedCreateNestedManyWithoutAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    nftOwnerships?: NFTOwnershipUncheckedCreateNestedManyWithoutAccountInput
    proxim8User?: Proxim8UserUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutGameAgentInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutGameAgentInput, AccountUncheckedCreateWithoutGameAgentInput>
  }

  export type GameProxim8CreateWithoutGameAgentInput = {
    id?: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level?: number
    experience?: number
    isDeployed?: boolean
    lastMissionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    missionDeployments?: TrainingMissionDeploymentCreateNestedManyWithoutGameProxim8Input
  }

  export type GameProxim8UncheckedCreateWithoutGameAgentInput = {
    id?: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level?: number
    experience?: number
    isDeployed?: boolean
    lastMissionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    missionDeployments?: TrainingMissionDeploymentUncheckedCreateNestedManyWithoutGameProxim8Input
  }

  export type GameProxim8CreateOrConnectWithoutGameAgentInput = {
    where: GameProxim8WhereUniqueInput
    create: XOR<GameProxim8CreateWithoutGameAgentInput, GameProxim8UncheckedCreateWithoutGameAgentInput>
  }

  export type GameProxim8CreateManyGameAgentInputEnvelope = {
    data: GameProxim8CreateManyGameAgentInput | GameProxim8CreateManyGameAgentInput[]
  }

  export type TrainingMissionDeploymentCreateWithoutGameAgentInput = {
    id?: string
    deploymentId: string
    missionId: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameProxim8: GameProxim8CreateNestedOneWithoutMissionDeploymentsInput
  }

  export type TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput = {
    id?: string
    deploymentId: string
    missionId: string
    gameProxim8Id: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionDeploymentCreateOrConnectWithoutGameAgentInput = {
    where: TrainingMissionDeploymentWhereUniqueInput
    create: XOR<TrainingMissionDeploymentCreateWithoutGameAgentInput, TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput>
  }

  export type TrainingMissionDeploymentCreateManyGameAgentInputEnvelope = {
    data: TrainingMissionDeploymentCreateManyGameAgentInput | TrainingMissionDeploymentCreateManyGameAgentInput[]
  }

  export type AccountUpsertWithoutGameAgentInput = {
    update: XOR<AccountUpdateWithoutGameAgentInput, AccountUncheckedUpdateWithoutGameAgentInput>
    create: XOR<AccountCreateWithoutGameAgentInput, AccountUncheckedCreateWithoutGameAgentInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutGameAgentInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutGameAgentInput, AccountUncheckedUpdateWithoutGameAgentInput>
  }

  export type AccountUpdateWithoutGameAgentInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUpdateManyWithoutAccountNestedInput
    agents?: AgentUpdateManyWithoutAccountNestedInput
    videos?: VideoUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutGameAgentInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutAccountNestedInput
    fingerprints?: FingerprintUncheckedUpdateManyWithoutAccountNestedInput
    agents?: AgentUncheckedUpdateManyWithoutAccountNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    nftOwnerships?: NFTOwnershipUncheckedUpdateManyWithoutAccountNestedInput
    proxim8User?: Proxim8UserUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type GameProxim8UpsertWithWhereUniqueWithoutGameAgentInput = {
    where: GameProxim8WhereUniqueInput
    update: XOR<GameProxim8UpdateWithoutGameAgentInput, GameProxim8UncheckedUpdateWithoutGameAgentInput>
    create: XOR<GameProxim8CreateWithoutGameAgentInput, GameProxim8UncheckedCreateWithoutGameAgentInput>
  }

  export type GameProxim8UpdateWithWhereUniqueWithoutGameAgentInput = {
    where: GameProxim8WhereUniqueInput
    data: XOR<GameProxim8UpdateWithoutGameAgentInput, GameProxim8UncheckedUpdateWithoutGameAgentInput>
  }

  export type GameProxim8UpdateManyWithWhereWithoutGameAgentInput = {
    where: GameProxim8ScalarWhereInput
    data: XOR<GameProxim8UpdateManyMutationInput, GameProxim8UncheckedUpdateManyWithoutGameAgentInput>
  }

  export type GameProxim8ScalarWhereInput = {
    AND?: GameProxim8ScalarWhereInput | GameProxim8ScalarWhereInput[]
    OR?: GameProxim8ScalarWhereInput[]
    NOT?: GameProxim8ScalarWhereInput | GameProxim8ScalarWhereInput[]
    id?: StringFilter<"GameProxim8"> | string
    gameAgentId?: StringFilter<"GameProxim8"> | string
    nftId?: StringFilter<"GameProxim8"> | string
    name?: StringFilter<"GameProxim8"> | string
    personality?: EnumProxim8PersonalityFilter<"GameProxim8"> | $Enums.Proxim8Personality
    level?: IntFilter<"GameProxim8"> | number
    experience?: IntFilter<"GameProxim8"> | number
    isDeployed?: BoolFilter<"GameProxim8"> | boolean
    lastMissionAt?: DateTimeNullableFilter<"GameProxim8"> | Date | string | null
    createdAt?: DateTimeFilter<"GameProxim8"> | Date | string
    updatedAt?: DateTimeFilter<"GameProxim8"> | Date | string
  }

  export type TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameAgentInput = {
    where: TrainingMissionDeploymentWhereUniqueInput
    update: XOR<TrainingMissionDeploymentUpdateWithoutGameAgentInput, TrainingMissionDeploymentUncheckedUpdateWithoutGameAgentInput>
    create: XOR<TrainingMissionDeploymentCreateWithoutGameAgentInput, TrainingMissionDeploymentUncheckedCreateWithoutGameAgentInput>
  }

  export type TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameAgentInput = {
    where: TrainingMissionDeploymentWhereUniqueInput
    data: XOR<TrainingMissionDeploymentUpdateWithoutGameAgentInput, TrainingMissionDeploymentUncheckedUpdateWithoutGameAgentInput>
  }

  export type TrainingMissionDeploymentUpdateManyWithWhereWithoutGameAgentInput = {
    where: TrainingMissionDeploymentScalarWhereInput
    data: XOR<TrainingMissionDeploymentUpdateManyMutationInput, TrainingMissionDeploymentUncheckedUpdateManyWithoutGameAgentInput>
  }

  export type TrainingMissionDeploymentScalarWhereInput = {
    AND?: TrainingMissionDeploymentScalarWhereInput | TrainingMissionDeploymentScalarWhereInput[]
    OR?: TrainingMissionDeploymentScalarWhereInput[]
    NOT?: TrainingMissionDeploymentScalarWhereInput | TrainingMissionDeploymentScalarWhereInput[]
    id?: StringFilter<"TrainingMissionDeployment"> | string
    deploymentId?: StringFilter<"TrainingMissionDeployment"> | string
    missionId?: StringFilter<"TrainingMissionDeployment"> | string
    gameAgentId?: StringFilter<"TrainingMissionDeployment"> | string
    gameProxim8Id?: StringFilter<"TrainingMissionDeployment"> | string
    approach?: EnumMissionApproachFilter<"TrainingMissionDeployment"> | $Enums.MissionApproach
    deployedAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    completesAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    duration?: IntFilter<"TrainingMissionDeployment"> | number
    status?: EnumDeploymentStatusFilter<"TrainingMissionDeployment"> | $Enums.DeploymentStatus
    currentPhase?: IntFilter<"TrainingMissionDeployment"> | number
    finalSuccessRate?: FloatFilter<"TrainingMissionDeployment"> | number
    phaseOutcomes?: JsonFilter<"TrainingMissionDeployment">
    result?: JsonNullableFilter<"TrainingMissionDeployment">
    createdAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingMissionDeployment"> | Date | string
  }

  export type GameAgentCreateWithoutProxim8sInput = {
    id?: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutGameAgentInput
    missionDeployments?: TrainingMissionDeploymentCreateNestedManyWithoutGameAgentInput
  }

  export type GameAgentUncheckedCreateWithoutProxim8sInput = {
    id?: string
    accountId: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    missionDeployments?: TrainingMissionDeploymentUncheckedCreateNestedManyWithoutGameAgentInput
  }

  export type GameAgentCreateOrConnectWithoutProxim8sInput = {
    where: GameAgentWhereUniqueInput
    create: XOR<GameAgentCreateWithoutProxim8sInput, GameAgentUncheckedCreateWithoutProxim8sInput>
  }

  export type TrainingMissionDeploymentCreateWithoutGameProxim8Input = {
    id?: string
    deploymentId: string
    missionId: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameAgent: GameAgentCreateNestedOneWithoutMissionDeploymentsInput
  }

  export type TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input = {
    id?: string
    deploymentId: string
    missionId: string
    gameAgentId: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionDeploymentCreateOrConnectWithoutGameProxim8Input = {
    where: TrainingMissionDeploymentWhereUniqueInput
    create: XOR<TrainingMissionDeploymentCreateWithoutGameProxim8Input, TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input>
  }

  export type TrainingMissionDeploymentCreateManyGameProxim8InputEnvelope = {
    data: TrainingMissionDeploymentCreateManyGameProxim8Input | TrainingMissionDeploymentCreateManyGameProxim8Input[]
  }

  export type GameAgentUpsertWithoutProxim8sInput = {
    update: XOR<GameAgentUpdateWithoutProxim8sInput, GameAgentUncheckedUpdateWithoutProxim8sInput>
    create: XOR<GameAgentCreateWithoutProxim8sInput, GameAgentUncheckedCreateWithoutProxim8sInput>
    where?: GameAgentWhereInput
  }

  export type GameAgentUpdateToOneWithWhereWithoutProxim8sInput = {
    where?: GameAgentWhereInput
    data: XOR<GameAgentUpdateWithoutProxim8sInput, GameAgentUncheckedUpdateWithoutProxim8sInput>
  }

  export type GameAgentUpdateWithoutProxim8sInput = {
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutGameAgentNestedInput
    missionDeployments?: TrainingMissionDeploymentUpdateManyWithoutGameAgentNestedInput
  }

  export type GameAgentUncheckedUpdateWithoutProxim8sInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    missionDeployments?: TrainingMissionDeploymentUncheckedUpdateManyWithoutGameAgentNestedInput
  }

  export type TrainingMissionDeploymentUpsertWithWhereUniqueWithoutGameProxim8Input = {
    where: TrainingMissionDeploymentWhereUniqueInput
    update: XOR<TrainingMissionDeploymentUpdateWithoutGameProxim8Input, TrainingMissionDeploymentUncheckedUpdateWithoutGameProxim8Input>
    create: XOR<TrainingMissionDeploymentCreateWithoutGameProxim8Input, TrainingMissionDeploymentUncheckedCreateWithoutGameProxim8Input>
  }

  export type TrainingMissionDeploymentUpdateWithWhereUniqueWithoutGameProxim8Input = {
    where: TrainingMissionDeploymentWhereUniqueInput
    data: XOR<TrainingMissionDeploymentUpdateWithoutGameProxim8Input, TrainingMissionDeploymentUncheckedUpdateWithoutGameProxim8Input>
  }

  export type TrainingMissionDeploymentUpdateManyWithWhereWithoutGameProxim8Input = {
    where: TrainingMissionDeploymentScalarWhereInput
    data: XOR<TrainingMissionDeploymentUpdateManyMutationInput, TrainingMissionDeploymentUncheckedUpdateManyWithoutGameProxim8Input>
  }

  export type GameAgentCreateWithoutMissionDeploymentsInput = {
    id?: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutGameAgentInput
    proxim8s?: GameProxim8CreateNestedManyWithoutGameAgentInput
  }

  export type GameAgentUncheckedCreateWithoutMissionDeploymentsInput = {
    id?: string
    accountId: string
    codename?: string | null
    rank?: $Enums.AgentRank
    timelinePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proxim8s?: GameProxim8UncheckedCreateNestedManyWithoutGameAgentInput
  }

  export type GameAgentCreateOrConnectWithoutMissionDeploymentsInput = {
    where: GameAgentWhereUniqueInput
    create: XOR<GameAgentCreateWithoutMissionDeploymentsInput, GameAgentUncheckedCreateWithoutMissionDeploymentsInput>
  }

  export type GameProxim8CreateWithoutMissionDeploymentsInput = {
    id?: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level?: number
    experience?: number
    isDeployed?: boolean
    lastMissionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameAgent: GameAgentCreateNestedOneWithoutProxim8sInput
  }

  export type GameProxim8UncheckedCreateWithoutMissionDeploymentsInput = {
    id?: string
    gameAgentId: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level?: number
    experience?: number
    isDeployed?: boolean
    lastMissionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameProxim8CreateOrConnectWithoutMissionDeploymentsInput = {
    where: GameProxim8WhereUniqueInput
    create: XOR<GameProxim8CreateWithoutMissionDeploymentsInput, GameProxim8UncheckedCreateWithoutMissionDeploymentsInput>
  }

  export type GameAgentUpsertWithoutMissionDeploymentsInput = {
    update: XOR<GameAgentUpdateWithoutMissionDeploymentsInput, GameAgentUncheckedUpdateWithoutMissionDeploymentsInput>
    create: XOR<GameAgentCreateWithoutMissionDeploymentsInput, GameAgentUncheckedCreateWithoutMissionDeploymentsInput>
    where?: GameAgentWhereInput
  }

  export type GameAgentUpdateToOneWithWhereWithoutMissionDeploymentsInput = {
    where?: GameAgentWhereInput
    data: XOR<GameAgentUpdateWithoutMissionDeploymentsInput, GameAgentUncheckedUpdateWithoutMissionDeploymentsInput>
  }

  export type GameAgentUpdateWithoutMissionDeploymentsInput = {
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutGameAgentNestedInput
    proxim8s?: GameProxim8UpdateManyWithoutGameAgentNestedInput
  }

  export type GameAgentUncheckedUpdateWithoutMissionDeploymentsInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    codename?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: EnumAgentRankFieldUpdateOperationsInput | $Enums.AgentRank
    timelinePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxim8s?: GameProxim8UncheckedUpdateManyWithoutGameAgentNestedInput
  }

  export type GameProxim8UpsertWithoutMissionDeploymentsInput = {
    update: XOR<GameProxim8UpdateWithoutMissionDeploymentsInput, GameProxim8UncheckedUpdateWithoutMissionDeploymentsInput>
    create: XOR<GameProxim8CreateWithoutMissionDeploymentsInput, GameProxim8UncheckedCreateWithoutMissionDeploymentsInput>
    where?: GameProxim8WhereInput
  }

  export type GameProxim8UpdateToOneWithWhereWithoutMissionDeploymentsInput = {
    where?: GameProxim8WhereInput
    data: XOR<GameProxim8UpdateWithoutMissionDeploymentsInput, GameProxim8UncheckedUpdateWithoutMissionDeploymentsInput>
  }

  export type GameProxim8UpdateWithoutMissionDeploymentsInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameAgent?: GameAgentUpdateOneRequiredWithoutProxim8sNestedInput
  }

  export type GameProxim8UncheckedUpdateWithoutMissionDeploymentsInput = {
    gameAgentId?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyAccountInput = {
    id?: string
    username: string
    bio?: string | null
    avatar?: string | null
    isPublic?: boolean
    socialLinks?: InputJsonValue | null
    preferences?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FingerprintCreateManyAccountInput = {
    id?: string
    fingerprint: string
    roles?: FingerprintCreaterolesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentCreateManyAccountInput = {
    id?: string
    name: string
    description?: string | null
    avatar?: string | null
    isActive?: boolean
    config?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyAccountInput = {
    id?: string
    nftId: string
    jobId: string
    status?: $Enums.VideoStatus
    title?: string | null
    description?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: number | null
    resolution?: string | null
    isPublic?: boolean
    metadata?: InputJsonValue | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyAccountInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: InputJsonValue | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTOwnershipCreateManyAccountInput = {
    id?: string
    nftId: string
    walletAddress: string
    contractAddress: string
    tokenId: string
    blockchain?: string
    verified?: boolean
    lastVerified?: Date | string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateWithoutAccountInput = {
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUpdateManyWithoutProfileNestedInput
    impressions?: ImpressionUpdateManyWithoutProfileNestedInput
    socialProfiles?: SocialProfileUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutAccountInput = {
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutProfileNestedInput
    impressions?: ImpressionUncheckedUpdateManyWithoutProfileNestedInput
    socialProfiles?: SocialProfileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutAccountInput = {
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: InputJsonValue | InputJsonValue | null
    preferences?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FingerprintUpdateWithoutAccountInput = {
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUpdateManyWithoutFingerprintNestedInput
  }

  export type FingerprintUncheckedUpdateWithoutAccountInput = {
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutFingerprintNestedInput
  }

  export type FingerprintUncheckedUpdateManyWithoutAccountInput = {
    fingerprint?: StringFieldUpdateOperationsInput | string
    roles?: FingerprintUpdaterolesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpdateWithoutAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateManyWithoutAgentNestedInput
    missions?: MissionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUncheckedUpdateManyWithoutAgentNestedInput
    missions?: MissionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutAccountInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutAccountInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyWithoutAccountInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutAccountInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutAccountInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutAccountInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: InputJsonValue | InputJsonValue | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTOwnershipUpdateWithoutAccountInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    blockchain?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    lastVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTOwnershipUncheckedUpdateWithoutAccountInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    blockchain?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    lastVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTOwnershipUncheckedUpdateManyWithoutAccountInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    contractAddress?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    blockchain?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    lastVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateManyProfileInput = {
    id?: string
    fingerprintId: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type ImpressionCreateManyProfileInput = {
    id?: string
    type: string
    context?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type SocialProfileCreateManyProfileInput = {
    id?: string
    platform: string
    username: string
    url?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitUpdateWithoutProfileInput = {
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fingerprint?: FingerprintUpdateOneRequiredWithoutVisitsNestedInput
  }

  export type VisitUncheckedUpdateWithoutProfileInput = {
    fingerprintId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUncheckedUpdateManyWithoutProfileInput = {
    fingerprintId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionUpdateWithoutProfileInput = {
    type?: StringFieldUpdateOperationsInput | string
    context?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionUncheckedUpdateWithoutProfileInput = {
    type?: StringFieldUpdateOperationsInput | string
    context?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionUncheckedUpdateManyWithoutProfileInput = {
    type?: StringFieldUpdateOperationsInput | string
    context?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileUpdateWithoutProfileInput = {
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileUncheckedUpdateWithoutProfileInput = {
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileUncheckedUpdateManyWithoutProfileInput = {
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateManyFingerprintInput = {
    id?: string
    profileId?: string | null
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referrer?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type VisitUpdateWithoutFingerprintInput = {
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutVisitsNestedInput
  }

  export type VisitUncheckedUpdateWithoutFingerprintInput = {
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUncheckedUpdateManyWithoutFingerprintInput = {
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCreateManyAgentInput = {
    id?: string
    title: string
    content: string
    type: string
    source?: string | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionCreateManyAgentInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.MissionStatus
    priority?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUpdateWithoutAgentInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeUncheckedUpdateWithoutAgentInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeUncheckedUpdateManyWithoutAgentInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionUpdateWithoutAgentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionUncheckedUpdateWithoutAgentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionUncheckedUpdateManyWithoutAgentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameProxim8CreateManyGameAgentInput = {
    id?: string
    nftId: string
    name: string
    personality: $Enums.Proxim8Personality
    level?: number
    experience?: number
    isDeployed?: boolean
    lastMissionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionDeploymentCreateManyGameAgentInput = {
    id?: string
    deploymentId: string
    missionId: string
    gameProxim8Id: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameProxim8UpdateWithoutGameAgentInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    missionDeployments?: TrainingMissionDeploymentUpdateManyWithoutGameProxim8NestedInput
  }

  export type GameProxim8UncheckedUpdateWithoutGameAgentInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    missionDeployments?: TrainingMissionDeploymentUncheckedUpdateManyWithoutGameProxim8NestedInput
  }

  export type GameProxim8UncheckedUpdateManyWithoutGameAgentInput = {
    nftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: EnumProxim8PersonalityFieldUpdateOperationsInput | $Enums.Proxim8Personality
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    isDeployed?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionDeploymentUpdateWithoutGameAgentInput = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameProxim8?: GameProxim8UpdateOneRequiredWithoutMissionDeploymentsNestedInput
  }

  export type TrainingMissionDeploymentUncheckedUpdateWithoutGameAgentInput = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    gameProxim8Id?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionDeploymentUncheckedUpdateManyWithoutGameAgentInput = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    gameProxim8Id?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionDeploymentCreateManyGameProxim8Input = {
    id?: string
    deploymentId: string
    missionId: string
    gameAgentId: string
    approach: $Enums.MissionApproach
    deployedAt?: Date | string
    completesAt: Date | string
    duration: number
    status?: $Enums.DeploymentStatus
    currentPhase?: number
    finalSuccessRate: number
    phaseOutcomes: InputJsonValue
    result?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingMissionDeploymentUpdateWithoutGameProxim8Input = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameAgent?: GameAgentUpdateOneRequiredWithoutMissionDeploymentsNestedInput
  }

  export type TrainingMissionDeploymentUncheckedUpdateWithoutGameProxim8Input = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    gameAgentId?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingMissionDeploymentUncheckedUpdateManyWithoutGameProxim8Input = {
    deploymentId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    gameAgentId?: StringFieldUpdateOperationsInput | string
    approach?: EnumMissionApproachFieldUpdateOperationsInput | $Enums.MissionApproach
    deployedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    currentPhase?: IntFieldUpdateOperationsInput | number
    finalSuccessRate?: FloatFieldUpdateOperationsInput | number
    phaseOutcomes?: InputJsonValue | InputJsonValue
    result?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}